//------------------------------------------------------------------------------------------------
// File: k3d_slv.cxx
//------------------------------------------------------------------------------------------------
#ifndef K3D_SLV_CXX
#define K3D_SLV_CXX

#include "k3d_slv.hxx"

#include <iostream>
#include <fstream>
#include <sstream>
#include <iosfwd>
#include <cstring>
#include <iomanip>
#include <algorithm>
#include <float.h>
#include <stdlib.h>
#include <stdio.h>
#include <map>

namespace k3d
{

//
// Multiply by super sparse matrix by rows and add result into prescribed positions
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CMvmSlv_impl < _Int,
      _Flt, _FltVect >::MvmA (char _oper, int _nlist, const vector < _Int > &_list_alu,
                              const vector < _Int > &_ia_alu,
                              const vector < _Int > &_ja_alu,
                              const vector < _Flt > &_a_alu, const _FltVect * _x,
                              _FltVect * _ax)
   {

      const _Int *p_list_a = &_list_alu[0];
      const _Int *p_ia_a = &_ia_alu[0];
      const _Int *p_ja_a = &_ja_alu[0];
      const _Flt *p_a_a = &_a_alu[0];

      int i, irow, j, jj;

      if (_oper == '+') {

         for (i = 0; i < _nlist; i++)
         {
            irow = (int) p_list_a[i];
            for (j = (int) p_ia_a[i]; j < p_ia_a[i + 1]; j++)
            {
               jj = (int) p_ja_a[j];
               _ax[irow] += (_FltVect) (p_a_a[j] * _x[jj]);
            }
         }

      } else if (_oper == '-') {

         for (i = 0; i < _nlist; i++) {
            irow = (int) p_list_a[i];
            for (j = (int) p_ia_a[i]; j < p_ia_a[i + 1]; j++) {
               jj = (int) p_ja_a[j];
               _ax[irow] -= (_FltVect) (p_a_a[j] * _x[jj]);
            }
         }

      }

   }

//
// Multiply by block diagonal by block rows, each diagonal block is blksize x blksize dense matrix
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CMvmSlv_impl < _Int,
      _Flt, _FltVect >::MvmDiagBlksize (int _blksize, int _nlist,
                                        const vector < _Flt > &_a_alu,
                                        const _FltVect * _x, _FltVect * _ax)
   {

      const _Flt *p_a_a = &_a_alu[0];

      int niloc = _nlist * _blksize;
      int blksize_2 = _blksize * _blksize;

      _FltVect fzero = (_FltVect) 0.0e0;

      CVector < _FltVect >::SetByZeroes (niloc, _ax);

      int i, ii, jj, ibs_i, ibs_a;
      _FltVect aux;

      for (i = 0; i < _nlist; i++) {
         ibs_i = i * _blksize;
         ibs_a = i * blksize_2;
         for (ii = 0; ii < _blksize; ii++) {
            aux = fzero;
            for (jj = 0; jj < _blksize; jj++) {
               aux += (_FltVect) (p_a_a[ibs_a + jj * _blksize + ii] * _x[ibs_i + jj]);
            }
            _ax[ibs_i + ii] = aux;
         }
      }

   }

//
// Multiply by block diagonal by block rows, each diagonal block is blksize x blksize dense matrix
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CMvmSlv_impl < _Int,
      _Flt, _FltVect >::MvmDiagTBlksize (int _blksize, int _nlist,
                                         const vector < _Flt > &_a_alu,
                                         const _FltVect * _x, _FltVect * _ax)
   {

      const _Flt *p_a_a = &_a_alu[0];

      int niloc = _nlist * _blksize;
      int blksize_2 = _blksize * _blksize;

      _FltVect fzero = (_FltVect) 0.0e0;

      CVector < _FltVect >::SetByZeroes (niloc, _ax);

      int i, ii, jj, ibs_i, ibs_a;
      _FltVect aux;

      for (i = 0; i < _nlist; i++) {
         ibs_i = i * _blksize;
         ibs_a = i * blksize_2;
         for (ii = 0; ii < _blksize; ii++) {
            aux = fzero;
            for (jj = 0; jj < _blksize; jj++) {
               aux += (_FltVect) (p_a_a[ibs_a + ii * _blksize + jj] * _x[ibs_i + jj]);
            }
            _ax[ibs_i + ii] = aux;
         }
      }

   }

//
// Multiply by super sparse matrix by columns and add result into prescribed positions
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CMvmSlv_impl < _Int,
      _Flt, _FltVect >::MvmAT (char _oper, int _nlist, const vector < _Int > &_list_alu,
                               const vector < _Int > &_ia_alu,
                               const vector < _Int > &_ja_alu,
                               const vector < _Flt > &_a_alu, const _FltVect * _x,
                               _FltVect * _ax)
   {

      const _Int *p_list_a = &_list_alu[0];
      const _Int *p_ia_a = &_ia_alu[0];
      const _Int *p_ja_a = &_ja_alu[0];
      const _Flt *p_a_a = &_a_alu[0];

      int i, irow, j, jj;

      if (_oper == '+') {

         for (i = 0; i < _nlist; i++) {
            irow = (int) p_list_a[i];
            for (j = (int) p_ia_a[i]; j < p_ia_a[i + 1]; j++) {
               jj = (int) p_ja_a[j];
               _ax[jj] += (_FltVect) (p_a_a[j] * _x[irow]);
            }
         }

      } else if (_oper == '-') {

         for (i = 0; i < _nlist; i++) {
            irow = (int) p_list_a[i];
            for (j = (int) p_ia_a[i]; j < p_ia_a[i + 1]; j++) {
               jj = (int) p_ja_a[j];
               _ax[jj] -= (_FltVect) (p_a_a[j] * _x[irow]);
            }
         }

      }

   }

//
// Solve with L, L is stored by columns (diag is inverted)
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CMvmSlv_impl < _Int,
      _Flt, _FltVect >::SolveL (int _n, const vector < _Int > &_ia_l,
                                const vector < _Int > &_ja_l, const vector < _Flt > &_a_l,
                                const _FltVect * _x, _FltVect * _lx)
   {

      int i;

      if (_lx != _x) {
         for (i = 0; i < _n; i++)
            _lx[i] = _x[i];
      }

      const _Int *p_ia_l = &_ia_l[0];
      const _Int *p_ja_l = &_ja_l[0];
      const _Flt *p_a_l = &_a_l[0];

      int j, jj, ibeg, iend;

      for (i = 0; i < _n; i++) {
         ibeg = (int) p_ia_l[i];
         iend = (int) p_ia_l[i + 1] - 1;
         _lx[i] *= (_FltVect) p_a_l[ibeg];
         for (j = ibeg + 1; j <= iend; j++) {
            jj = (int) p_ja_l[j];
            _lx[jj] -= (_FltVect) (p_a_l[j] * _lx[i]);
         }
      }

   }

//
// Solve with U, U is stored by rows (diag is inverted)
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CMvmSlv_impl < _Int,
      _Flt, _FltVect >::SolveU (int _n, const vector < _Int > &_ia_u,
                                const vector < _Int > &_ja_u, const vector < _Flt > &_a_u,
                                const _FltVect * _x, _FltVect * _ux)
   {

      int i;

      const _Int *p_ia_u = &_ia_u[0];
      const _Int *p_ja_u = &_ja_u[0];
      const _Flt *p_a_u = &_a_u[0];

      if (_ux != _x) {
         for (i = 0; i < _n; i++)
            _ux[i] = _x[i];
      }

      int j, jj, ibeg, iend;

      for (i = _n - 1; i >= 0; i--) {
         ibeg = (int) p_ia_u[i];
         iend = (int) p_ia_u[i + 1] - 1;
         for (j = ibeg + 1; j <= iend; j++) {
            jj = (int) p_ja_u[j];
            _ux[i] -= (_FltVect) (p_a_u[j] * _ux[jj]);
         }
         _ux[i] *= (_FltVect) p_a_u[ibeg];
      }

   }

//
// Print matrix data
//========================================================================================
   template < typename _Int, typename _Flt > void CFct < _Int,
      _Flt >::PrintMatrix (ofstream & _fout, CMatrix < _Int, _Flt > &_a_matr)
   {

      _fout << " CMatrix:" << endl;

      _fout << "    Nlist = " << _a_matr.GetNlist () << " Nlist2 = " << _a_matr.
         GetNlist2 () << endl;
      _fout << "    Nzja  = " << _a_matr.GetNzja () << " Nzja2  = " << _a_matr.
         GetNzja2 () << " Nzjachar  = " << _a_matr.GetNzjaChar () << " Nza = " << _a_matr.
         GetNza () << endl;

      if (_a_matr.GetNlist () > 0)
         PrintArray (_fout, "    List  = ", _a_matr.GetNlist (), _a_matr.GetListArr ());
      if (_a_matr.GetNlist2 () > 0)
         PrintArray (_fout, "    List2 = ", _a_matr.GetNlist2 (), _a_matr.GetList2Arr ());
      if (_a_matr.GetNlist () > 0)
         PrintArray (_fout, "    Ia    = ", _a_matr.GetNlist () + 1, _a_matr.GetIaArr ());
      if (_a_matr.GetNzja () > 0)
         PrintArray (_fout, "    Ja    = ", _a_matr.GetNzja (), _a_matr.GetJaArr ());
      if (_a_matr.GetNzja2 () > 0)
         PrintArray (_fout, "    Ja2   = ", _a_matr.GetNzja2 (), _a_matr.GetJa2Arr ());
      if (_a_matr.GetNzjaChar () > 0)
         PrintArray (_fout, "    JaChar = ", _a_matr.GetNzjaChar (),
                     _a_matr.GetJaCharArr ());
      if (_a_matr.GetNza () > 0)
         PrintArray (_fout, "    A     = ", _a_matr.GetNza (), _a_matr.GetAArr ());

   }

//
// Print matrix data over thresh
//========================================================================================
   template < typename _Int, typename _Flt > void CFct < _Int,
      _Flt >::PrintMatrixThresh (ofstream & _fout, CMatrix < _Int, _Flt > &_a_matr,
                                 double _thresh)
   {

      _fout << " CMatrix:" << endl;

      _fout << "    Nlist = " << _a_matr.GetNlist () << " Nlist2 = " << _a_matr.
         GetNlist2 () << endl;
      _fout << "    Nzja  = " << _a_matr.GetNzja () << " Nzja2  = " << _a_matr.GetNzja2 ()
         << " Nza = " << _a_matr.GetNza () << endl;

      int nlist_temp = _a_matr.GetNlist ();
      _Int *plist_temp = _a_matr.GetListArr ();
      _Int *pia_temp = _a_matr.GetIaArr ();
      _Int *pja_temp = _a_matr.GetJaArr ();
      _Flt *pa_temp = _a_matr.GetAArr ();

      int i, j, jj, ilist;
      double daux;

      for (i = 0; i < nlist_temp; i++) {
         ilist = (int) plist_temp[i];
         for (j = (int) pia_temp[i]; j < pia_temp[i + 1]; j++) {
            jj = (int) pja_temp[j];
            daux = (double) pa_temp[j];
            if (daux < 0.0e0)
               daux = -daux;
            if (daux > _thresh) {
               _fout << "       Irow = " << ilist << " Icol = " << jj << " Val = " <<
                  pa_temp[j] << endl;
            }
         }
      }

   }

//
// Print diagonal part of matrix data
//========================================================================================
   template < typename _Int, typename _Flt > void CFct < _Int,
      _Flt >::PrintMatrixDiag (ofstream & _fout, CMatrix < _Int, _Flt > &_a_matr)
   {

      _fout << " CMatrix:" << endl;

      _fout << "    Nlist = " << _a_matr.GetNlist () << " Nlist2 = " << _a_matr.
         GetNlist2 () << endl;
      _fout << "    Nzja  = " << _a_matr.GetNzja () << " Nzja2  = " << _a_matr.GetNzja2 ()
         << " Nza = " << _a_matr.GetNza () << endl;

      int nlist_temp = _a_matr.GetNlist ();
      _Int *plist_temp = _a_matr.GetListArr ();
      _Int *pia_temp = _a_matr.GetIaArr ();
      _Int *pja_temp = _a_matr.GetJaArr ();
      _Flt *pa_temp = _a_matr.GetAArr ();

      CVectorData < double >diag_data (nlist_temp);
      double *pdiag_data = diag_data.Ptr ();

      int i, j, jj, ilist;
      double daux;

      for (i = 0; i < nlist_temp; i++)
         pdiag_data[i] = 0.0e0;

      for (i = 0; i < nlist_temp; i++) {
         ilist = (int) plist_temp[i];
         for (j = (int) pia_temp[i]; j < pia_temp[i + 1]; j++) {
            jj = (int) pja_temp[j];
            if (jj == ilist) {
               daux = (double) pa_temp[j];
               pdiag_data[i] = daux;
            }
         }
      }

//      PrintArray (_fout, "    List  = ", _a_matr.GetNlist (), _a_matr.GetListArr ());
      PrintArray (_fout, "    Diag  = ", _a_matr.GetNlist (), pdiag_data);

   }

//
// Print diagonal part of matrix data in pairs format
//========================================================================================
   template < typename _Int, typename _Flt > void CFct < _Int,
      _Flt >::PrintMatrixDiagPair (ofstream & _fout, CMatrix < _Int, _Flt > &_a_matr)
   {

      _fout << " CMatrix:" << endl;

      _fout << "    Nlist = " << _a_matr.GetNlist () << " Nlist2 = " << _a_matr.
         GetNlist2 () << endl;
      _fout << "    Nzja  = " << _a_matr.GetNzja () << " Nzja2  = " << _a_matr.GetNzja2 ()
         << " Nza = " << _a_matr.GetNza () << endl;

      int nlist_temp = _a_matr.GetNlist ();
      _Int *plist_temp = _a_matr.GetListArr ();
      _Int *pia_temp = _a_matr.GetIaArr ();
      _Int *pja_temp = _a_matr.GetJaArr ();
      _Flt *pa_temp = _a_matr.GetAArr ();

      CVectorData < double >diag_data (nlist_temp * 2);
      double *pdiag_data = diag_data.Ptr ();

      int i, j, jj, ilist;
      double daux;

      for (i = 0; i < nlist_temp * 2; i++)
         pdiag_data[i] = 0.0e0;

      for (i = 0; i < nlist_temp; i++) {
         ilist = (int) plist_temp[i];
         for (j = (int) pia_temp[i]; j < pia_temp[i + 1]; j++) {
            jj = (int) pja_temp[j];
            if (jj == ilist) {
               daux = (double) pa_temp[j * 2];
               pdiag_data[i * 2] = daux;
               daux = (double) pa_temp[j * 2 + 1];
               pdiag_data[i * 2 + 1] = daux;
            }
         }
      }

      PrintArray (_fout, "    List  = ", _a_matr.GetNlist (), _a_matr.GetListArr ());
      PrintArray (_fout, "    Diag Pairs  = ", 2 * _a_matr.GetNlist (), pdiag_data);

   }


// Init by data
//========================================================================================
   template < typename _Int, typename _Flt, typename _Flt2 > void CMatrixConv < _Int,
      _Flt, _Flt2 >::InitAndConv (int _n, _Int * _ia, _Int * _ja, _Flt * _a,
                                  CMatrix < _Int, _Flt2 > &_amatr)
   {

      CMatrix < _Int, _Flt2 > a_temp (_n, _ia, _ja);

      vector < _Flt2 > *pa = a_temp.GetA ();

      int nzja = (int) _ia[_n];

      pa->resize (nzja + 1);

      _Flt2 *p_ptr_a = &((*pa)[0]);

      int i;

      for (i = 0; i < nzja; i++)
         p_ptr_a[i] = (_Flt2) _a[i];

      _amatr.ReplaceFree (a_temp);

   }

// Init by data
//========================================================================================
   template < typename _Int, typename _Flt, typename _Flt2 > void CMatrixConv < _Int,
      _Flt, _Flt2 >::InitAndConv (CMatrix < _Int, _Flt > &_amatr_ini, CMatrix < _Int,
                                  _Flt2 > &_amatr_fin)
   {

      int nlistloc = _amatr_ini.GetNlist ();
      int nlist2loc = _amatr_ini.GetNlist2 ();
      int nzjaloc = _amatr_ini.GetNzja ();
      int nzja2loc = _amatr_ini.GetNzja2 ();
      int nzaloc = _amatr_ini.GetNza ();

      _Int *plist_ini = _amatr_ini.GetListArr ();
      _Int *plist2_ini = _amatr_ini.GetList2Arr ();
      _Int *pia_ini = _amatr_ini.GetIaArr ();
      _Int *pja_ini = _amatr_ini.GetJaArr ();
      _Int *pja2_ini = _amatr_ini.GetJa2Arr ();
      _Flt *pa_ini = _amatr_ini.GetAArr ();

      _amatr_fin.ResizeAndSetAll (nlistloc, nlist2loc, nzjaloc, nzja2loc, nzaloc);

      _Int *plist_fin = _amatr_fin.GetListArr ();
      _Int *plist2_fin = _amatr_fin.GetList2Arr ();
      _Int *pia_fin = _amatr_fin.GetIaArr ();
      _Int *pja_fin = _amatr_fin.GetJaArr ();
      _Int *pja2_fin = _amatr_fin.GetJa2Arr ();
      _Flt2 *pa_fin = _amatr_fin.GetAArr ();

      int i;

      for (i = 0; i < nlistloc; i++)
         plist_fin[i] = plist_ini[i];
      for (i = 0; i < nlist2loc; i++)
         plist2_fin[i] = plist2_ini[i];
      for (i = 0; i <= nlistloc; i++)
         pia_fin[i] = pia_ini[i];
      for (i = 0; i < nzjaloc; i++)
         pja_fin[i] = pja_ini[i];
      for (i = 0; i < nzja2loc; i++)
         pja2_fin[i] = pja2_ini[i];
      for (i = 0; i < nzaloc; i++)
         pa_fin[i] = (_Flt2) pa_ini[i];

   }

// Init by data
//========================================================================================
   template < typename _Int, typename _Flt, typename _Flt2 > void CMatrixConv < _Int,
      _Flt, _Flt2 >::InitAndConv (CBMatrix < _Int, _Flt > &_ahmatr_ini, CBMatrix < _Int,
                                  _Flt2 > &_ahmatr_fin)
   {

      int nzblk = _ahmatr_ini.GetNzblk ();
      CMatrix < int, float >*phmatr_ini = _ahmatr_ini.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub_ini = _ahmatr_ini.GetASubArr ();

      _ahmatr_fin.SetNzblk (nzblk);
      _ahmatr_fin.ResizeASub (nzblk);

      CMatrix < int, float >*phmatr_fin = _ahmatr_fin.GetHMatrStr ();
      CMatrix < _Int, _Flt2 > *pA_sub_fin = _ahmatr_fin.GetASubArr ();

      *phmatr_fin = *phmatr_ini;

#ifdef USE_THREADS
#pragma omp parallel for
#endif
      for (int ipar = 0; ipar < nzblk; ipar++) {
         CMatrixConv < _Int, _Flt, _Flt2 >::InitAndConv (pA_sub_ini[ipar],
                                                         pA_sub_fin[ipar]);
      }

   }

// Copy constructor
//========================================================================================
   template < typename _Int, typename _Flt > CBMatrix < _Int,
      _Flt >::CBMatrix (const CBMatrix < _Int, _Flt > &_aa)
   {

      this->nzblk = _aa.nzblk;
      this->hmatr_str = _aa.hmatr_str;
      this->asub_arr.resize (_aa.nzblk + 1);
      const CMatrix < _Int, _Flt > *pasub_arr_aa = &(_aa.asub_arr[0]);
      CMatrix < _Int, _Flt > *pasub_arr = &(this->asub_arr[0]);
      for (int i = 0; i < _aa.nzblk; i++)
         pasub_arr[i] = pasub_arr_aa[i];

   }

// Equality operator
//========================================================================================
   template < typename _Int, typename _Flt > CBMatrix < _Int, _Flt > &CBMatrix < _Int,
      _Flt >::operator= (const CBMatrix < _Int, _Flt > &_aa)
   {

      this->nzblk = _aa.nzblk;
      this->hmatr_str = _aa.hmatr_str;
      this->asub_arr.resize (_aa.nzblk + 1);
      const CMatrix < _Int, _Flt > *pasub_arr_aa = &(_aa.asub_arr[0]);
      CMatrix < _Int, _Flt > *pasub_arr = &(this->asub_arr[0]);
      for (int i = 0; i < _aa.nzblk; i++)
         pasub_arr[i] = pasub_arr_aa[i];

      return *this;

   }

// Add operator
//========================================================================================
   template < typename _Int, typename _Flt > CBMatrix < _Int, _Flt > &CBMatrix < _Int,
      _Flt >::operator+= (const CBMatrix < _Int, _Flt > &_aa) {

      if (_aa.GetNzblk () == 0)
         return *this;

// Add sparsities

      CMatrix < int, float >sum_str;

      sum_str.AddBlocksSp (this->hmatr_str, _aa.hmatr_str);

// Open sparsities

      int nlistloc = this->hmatr_str.GetNlist ();
      int nlist2loc = this->hmatr_str.GetNlist2 ();
      int nzjaloc = this->hmatr_str.GetNzja ();
      int nzja2loc = this->hmatr_str.GetNzja2 ();
      int *plist = this->hmatr_str.GetListArr ();
      int *plist2 = this->hmatr_str.GetList2Arr ();
      int *pia = this->hmatr_str.GetIaArr ();
      int *pja = this->hmatr_str.GetJaArr ();
      int *pja2 = this->hmatr_str.GetJa2Arr ();

      int nlist_aa = _aa.hmatr_str.GetNlist ();
      int nlist2_aa = _aa.hmatr_str.GetNlist2 ();
      int nzja_aa = _aa.hmatr_str.GetNzja ();
      int nzja2_aa = _aa.hmatr_str.GetNzja2 ();
      const int *plist_aa = _aa.hmatr_str.GetListArr ();
      const int *plist2_aa = _aa.hmatr_str.GetList2Arr ();
      const int *pia_aa = _aa.hmatr_str.GetIaArr ();
      const int *pja_aa = _aa.hmatr_str.GetJaArr ();
      const int *pja2_aa = _aa.hmatr_str.GetJa2Arr ();

      int nlist_sum = sum_str.GetNlist ();
      int nlist2_sum = sum_str.GetNlist2 ();
      int nzja_sum = sum_str.GetNzja ();
      int nzja2_sum = sum_str.GetNzja2 ();
      int *plist_sum = sum_str.GetListArr ();
      int *plist2_sum = sum_str.GetList2Arr ();
      int *pia_sum = sum_str.GetIaArr ();
      int *pja_sum = sum_str.GetJaArr ();
      int *pja2_sum = sum_str.GetJa2Arr ();

// Detect 2 and 3 indices case

      if ((nlistloc != nlist2loc || nzjaloc != nzja2loc)
          || (nlist_aa != nlist2_aa || nzja_aa != nzja2_aa)
          || (nlist_sum != nlist2_sum || nzja_sum != nzja2_sum)) {
         throw " CBMatrix<_Int,_Flt>::operator+=: incorrect block sparsity ";
      }
// Allocate new set of blocks

      vector < CMatrix < _Int, _Flt > >sum_ablks (nzja_sum + 1);

// Add and free blocks in parallel

      CMatrix < _Int, _Flt > *pASub = &this->asub_arr[0];
      const CMatrix < _Int, _Flt > *pASub_aa = &_aa.asub_arr[0];
      CMatrix < _Int, _Flt > *pASub_sum = &sum_ablks[0];

      int iend1 = nlistloc - 1;
      int iend2 = nlist_aa - 1;

      int ilist, ip1, ip2, iblk1, iblk2, jend, jend1, jend2, jp, jp1, jp2;

      int irow, iirow, irow1, iirow1, irow2, iirow2;
      int jj, jjj, jj1, jjj1, jj2, jjj2;

      CMatrix < _Int, _Flt > *pBlock_a_free = NULL;
      const CMatrix < _Int, _Flt > *pBlock_b = NULL;
      CMatrix < _Int, _Flt > *pBlock_sum = NULL;

      ip1 = 0;
      ip2 = 0;

      for (ilist = 0; ilist < nlist_sum; ilist++) {
         irow = plist_sum[ilist];
         iirow = plist2_sum[ilist];
         iblk1 = 0;
         if (ip1 <= iend1) {
            irow1 = plist[ip1];
            iirow1 = plist2[ip1];
            if (irow1 != irow || iirow1 != iirow) {
               iblk1 = -1;
               if (iirow1 < iirow || (iirow1 == iirow && irow1 < irow))
                  throw
                     " CBMatrix<_Int,_Flt>::operator+=: sparsity structure is not inclusive ";
            }
         } else {
            iblk1 = -1;
         }
         iblk2 = 0;
         if (ip2 <= iend2) {
            irow2 = plist_aa[ip2];
            iirow2 = plist2_aa[ip2];
            if (irow2 != irow || iirow2 != iirow) {
               iblk2 = -1;
               if (iirow2 < iirow || (iirow2 == iirow && irow2 < irow))
                  throw
                     " CBMatrix<_Int,_Flt>::operator+=: sparsity structure is not inclusive ";
            }
         } else {
            iblk2 = -1;
         }
         jp = pia_sum[ilist];
         jend = pia_sum[ilist + 1] - 1;
         jp1 = -1;
         jend1 = -1;
         if (iblk1 >= 0) {
            jp1 = pia[ip1];
            jend1 = pia[ip1 + 1] - 1;
            ip1++;
         }
         jp2 = -1;
         jend2 = -1;
         if (iblk2 >= 0) {
            jp2 = pia_aa[ip2];
            jend2 = pia_aa[ip2 + 1] - 1;
            ip2++;
         }

         while (jp <= jend) {

            jj = pja_sum[jp];
            jjj = pja2_sum[jp];

            pBlock_a_free = NULL;
            pBlock_b = NULL;
            pBlock_sum = pASub_sum + jp;

            if (iblk1 >= 0) {
               if (jp1 <= jend1) {
                  jj1 = pja[jp1];
                  jjj1 = pja2[jp1];
                  if (jjj1 == jjj) {
                     if (jj1 == jj) {
                        pBlock_a_free = pASub + jp1;
                        jp1++;
                     } else if (jj1 < jj) {
                        throw
                           " CBMatrix<_Int,_Flt>::operator+=: sparsity structure is not inclusive ";
                     }
                  } else if (jjj1 < jjj) {
                     throw
                        " CBMatrix<_Int,_Flt>::operator+=: sparsity structure is not inclusive ";
                  }
               }
            }

            if (iblk2 >= 0) {
               if (jp2 <= jend2) {
                  jj2 = pja_aa[jp2];
                  jjj2 = pja2_aa[jp2];
                  if (jjj2 == jjj) {
                     if (jj2 == jj) {
                        pBlock_b = pASub_aa + jp2;
                        jp2++;
                     } else if (jj2 < jj) {
                        throw
                           " CBMatrix<_Int,_Flt>::operator+=: sparsity structure is not inclusive ";
                     }
                  } else if (jjj2 < jjj) {
                     throw
                        " CBMatrix<_Int,_Flt>::operator+=: sparsity structure is not inclusive ";
                  }
               }
            }

            if (pBlock_a_free != NULL && pBlock_b == NULL) {
               pBlock_sum->ReplaceFree (*pBlock_a_free);
            } else if (pBlock_a_free == NULL && pBlock_b != NULL) {
               *pBlock_sum = *pBlock_b;
            } else {
               *pBlock_a_free += *pBlock_b;
               pBlock_sum->ReplaceFree (*pBlock_a_free);
            }

            jp++;

         }
      }

// Replace the results

      this->SetNzblk (nzja_sum);

      this->hmatr_str.ReplaceFree (sum_str);
      this->asub_arr.swap (sum_ablks);

      return *this;
   }

// Add operator for pairs
//========================================================================================
   template < typename _Int, typename _Flt > CBMatrix < _Int, _Flt > &CBMatrix < _Int,
      _Flt >::operator%= (const CBMatrix < _Int, _Flt > &_aa) {

      if (_aa.GetNzblk () == 0)
         return *this;

// Add sparsities

      CMatrix < int, float >sum_str;

      sum_str.AddBlocksSp (this->hmatr_str, _aa.hmatr_str);

// Open sparsities

      int nlistloc = this->hmatr_str.GetNlist ();
      int nlist2loc = this->hmatr_str.GetNlist2 ();
      int nzjaloc = this->hmatr_str.GetNzja ();
      int nzja2loc = this->hmatr_str.GetNzja2 ();
      int *plist = this->hmatr_str.GetListArr ();
      int *plist2 = this->hmatr_str.GetList2Arr ();
      int *pia = this->hmatr_str.GetIaArr ();
      int *pja = this->hmatr_str.GetJaArr ();
      int *pja2 = this->hmatr_str.GetJa2Arr ();

      int nlist_aa = _aa.hmatr_str.GetNlist ();
      int nlist2_aa = _aa.hmatr_str.GetNlist2 ();
      int nzja_aa = _aa.hmatr_str.GetNzja ();
      int nzja2_aa = _aa.hmatr_str.GetNzja2 ();
      const int *plist_aa = _aa.hmatr_str.GetListArr ();
      const int *plist2_aa = _aa.hmatr_str.GetList2Arr ();
      const int *pia_aa = _aa.hmatr_str.GetIaArr ();
      const int *pja_aa = _aa.hmatr_str.GetJaArr ();
      const int *pja2_aa = _aa.hmatr_str.GetJa2Arr ();

      int nlist_sum = sum_str.GetNlist ();
      int nlist2_sum = sum_str.GetNlist2 ();
      int nzja_sum = sum_str.GetNzja ();
      int nzja2_sum = sum_str.GetNzja2 ();
      int *plist_sum = sum_str.GetListArr ();
      int *plist2_sum = sum_str.GetList2Arr ();
      int *pia_sum = sum_str.GetIaArr ();
      int *pja_sum = sum_str.GetJaArr ();
      int *pja2_sum = sum_str.GetJa2Arr ();

// Detect 2 and 3 indices case

      if ((nlistloc != nlist2loc || nzjaloc != nzja2loc)
          || (nlist_aa != nlist2_aa || nzja_aa != nzja2_aa)
          || (nlist_sum != nlist2_sum || nzja_sum != nzja2_sum)) {
         throw " CBMatrix<_Int,_Flt>::operator%=: incorrect block sparsity ";
      }
// Allocate new set of blocks

      vector < CMatrix < _Int, _Flt > >sum_ablks (nzja_sum + 1);

// Add and free blocks in parallel

      CMatrix < _Int, _Flt > *pASub = &this->asub_arr[0];
      const CMatrix < _Int, _Flt > *pASub_aa = &_aa.asub_arr[0];
      CMatrix < _Int, _Flt > *pASub_sum = &sum_ablks[0];

      int iend1 = nlistloc - 1;
      int iend2 = nlist_aa - 1;

      int ilist, ip1, ip2, iblk1, iblk2, jend, jend1, jend2, jp, jp1, jp2;

      int irow, iirow, irow1, iirow1, irow2, iirow2;
      int jj, jjj, jj1, jjj1, jj2, jjj2;

      CMatrix < _Int, _Flt > *pBlock_a_free = NULL;
      const CMatrix < _Int, _Flt > *pBlock_b = NULL;
      CMatrix < _Int, _Flt > *pBlock_sum = NULL;

      ip1 = 0;
      ip2 = 0;

      for (ilist = 0; ilist < nlist_sum; ilist++) {
         irow = plist_sum[ilist];
         iirow = plist2_sum[ilist];
         iblk1 = 0;
         if (ip1 <= iend1) {
            irow1 = plist[ip1];
            iirow1 = plist2[ip1];
            if (irow1 != irow || iirow1 != iirow) {
               iblk1 = -1;
               if (iirow1 < iirow || (iirow1 == iirow && irow1 < irow))
                  throw
                     " CBMatrix<_Int,_Flt>::operator%=: sparsity structure is not inclusive ";
            }
         } else {
            iblk1 = -1;
         }
         iblk2 = 0;
         if (ip2 <= iend2) {
            irow2 = plist_aa[ip2];
            iirow2 = plist2_aa[ip2];
            if (irow2 != irow || iirow2 != iirow) {
               iblk2 = -1;
               if (iirow2 < iirow || (iirow2 == iirow && irow2 < irow))
                  throw
                     " CBMatrix<_Int,_Flt>::operator%=: sparsity structure is not inclusive ";
            }
         } else {
            iblk2 = -1;
         }
         jp = pia_sum[ilist];
         jend = pia_sum[ilist + 1] - 1;
         jp1 = -1;
         jend1 = -1;
         if (iblk1 >= 0) {
            jp1 = pia[ip1];
            jend1 = pia[ip1 + 1] - 1;
            ip1++;
         }
         jp2 = -1;
         jend2 = -1;
         if (iblk2 >= 0) {
            jp2 = pia_aa[ip2];
            jend2 = pia_aa[ip2 + 1] - 1;
            ip2++;
         }

         while (jp <= jend) {

            jj = pja_sum[jp];
            jjj = pja2_sum[jp];

            pBlock_a_free = NULL;
            pBlock_b = NULL;
            pBlock_sum = pASub_sum + jp;

            if (iblk1 >= 0) {
               if (jp1 <= jend1) {
                  jj1 = pja[jp1];
                  jjj1 = pja2[jp1];
                  if (jjj1 == jjj) {
                     if (jj1 == jj) {
                        pBlock_a_free = pASub + jp1;
                        jp1++;
                     } else if (jj1 < jj) {
                        throw
                           " CBMatrix<_Int,_Flt>::operator%=: sparsity structure is not inclusive ";
                     }
                  } else if (jjj1 < jjj) {
                     throw
                        " CBMatrix<_Int,_Flt>::operator%=: sparsity structure is not inclusive ";
                  }
               }
            }

            if (iblk2 >= 0) {
               if (jp2 <= jend2) {
                  jj2 = pja_aa[jp2];
                  jjj2 = pja2_aa[jp2];
                  if (jjj2 == jjj) {
                     if (jj2 == jj) {
                        pBlock_b = pASub_aa + jp2;
                        jp2++;
                     } else if (jj2 < jj) {
                        throw
                           " CBMatrix<_Int,_Flt>::operator%=: sparsity structure is not inclusive ";
                     }
                  } else if (jjj2 < jjj) {
                     throw
                        " CBMatrix<_Int,_Flt>::operator%=: sparsity structure is not inclusive ";
                  }
               }
            }

            if (pBlock_a_free != NULL && pBlock_b == NULL) {
               pBlock_sum->ReplaceFree (*pBlock_a_free);
            } else if (pBlock_a_free == NULL && pBlock_b != NULL) {
               *pBlock_sum = *pBlock_b;
            } else {
               *pBlock_a_free %= *pBlock_b;
               pBlock_sum->ReplaceFree (*pBlock_a_free);
            }

            jp++;

         }
      }

// Replace the results

      this->SetNzblk (nzja_sum);

      this->hmatr_str.ReplaceFree (sum_str);
      this->asub_arr.swap (sum_ablks);

      return *this;
   }

// Add replace operator for sparsity only (threads version)
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::AddReplaceSpThr (bool _b_use_thr, const CBMatrix < _Int, _Flt > &_aa)
   {

      if (_aa.GetNzblk () == 0)
         return;

// Add sparsities

      CMatrix < int, float >sum_str;

      sum_str.AddBlocksSp (this->hmatr_str, _aa.hmatr_str);

// Open sparsities

      int nlistloc = this->hmatr_str.GetNlist ();
      int nlist2loc = this->hmatr_str.GetNlist2 ();
      int nzjaloc = this->hmatr_str.GetNzja ();
      int nzja2loc = this->hmatr_str.GetNzja2 ();
      int *plist = this->hmatr_str.GetListArr ();
      int *plist2 = this->hmatr_str.GetList2Arr ();
      int *pia = this->hmatr_str.GetIaArr ();
      int *pja = this->hmatr_str.GetJaArr ();
      int *pja2 = this->hmatr_str.GetJa2Arr ();

      int nlist_aa = _aa.hmatr_str.GetNlist ();
      int nlist2_aa = _aa.hmatr_str.GetNlist2 ();
      int nzja_aa = _aa.hmatr_str.GetNzja ();
      int nzja2_aa = _aa.hmatr_str.GetNzja2 ();
      const int *plist_aa = _aa.hmatr_str.GetListArr ();
      const int *plist2_aa = _aa.hmatr_str.GetList2Arr ();
      const int *pia_aa = _aa.hmatr_str.GetIaArr ();
      const int *pja_aa = _aa.hmatr_str.GetJaArr ();
      const int *pja2_aa = _aa.hmatr_str.GetJa2Arr ();

      int nlist_sum = sum_str.GetNlist ();
      int nlist2_sum = sum_str.GetNlist2 ();
      int nzja_sum = sum_str.GetNzja ();
      int nzja2_sum = sum_str.GetNzja2 ();
      int *plist_sum = sum_str.GetListArr ();
      int *plist2_sum = sum_str.GetList2Arr ();
      int *pia_sum = sum_str.GetIaArr ();
      int *pja_sum = sum_str.GetJaArr ();
      int *pja2_sum = sum_str.GetJa2Arr ();

// Detect 2 and 3 indices case

      if ((nlistloc != nlist2loc || nzjaloc != nzja2loc)
          || (nlist_aa != nlist2_aa || nzja_aa != nzja2_aa)
          || (nlist_sum != nlist2_sum || nzja_sum != nzja2_sum)) {
         throw " CBMatrix<_Int,_Flt>::AddReplaceSpThr: incorrect block sparsity ";
      }
// Allocate new set of blocks

      vector < CMatrix < _Int, _Flt > >sum_ablks (nzja_sum + 1);

// Add and free blocks in parallel

      CMatrix < _Int, _Flt > *pASub = &this->asub_arr[0];
      const CMatrix < _Int, _Flt > *pASub_aa = &_aa.asub_arr[0];
      CMatrix < _Int, _Flt > *pASub_sum = &sum_ablks[0];

      int iend1 = nlistloc - 1;
      int iend2 = nlist_aa - 1;

      int ilist, ip1, ip2, iblk1, iblk2, jend, jend1, jend2, jp, jp1, jp2;

      int irow, iirow, irow1, iirow1, irow2, iirow2;
      int jj, jjj, jj1, jjj1, jj2, jjj2;

      CMatrix < _Int, _Flt > *pBlock_a_free = NULL;
      const CMatrix < _Int, _Flt > *pBlock_b = NULL;

      vector < CMatrix < _Int, _Flt > *>ptr_a (nzja_sum + 1);
      vector < const CMatrix < _Int, _Flt > *>ptr_b (nzja_sum + 1);

      CMatrix < _Int, _Flt > **pptr_a = &ptr_a[0];
      const CMatrix < _Int, _Flt > **pptr_b = &ptr_b[0];

      ip1 = 0;
      ip2 = 0;

      for (ilist = 0; ilist < nlist_sum; ilist++) {
         irow = plist_sum[ilist];
         iirow = plist2_sum[ilist];
         iblk1 = 0;
         if (ip1 <= iend1) {
            irow1 = plist[ip1];
            iirow1 = plist2[ip1];
            if (irow1 != irow || iirow1 != iirow) {
               iblk1 = -1;
               if (iirow1 < iirow || (iirow1 == iirow && irow1 < irow))
                  throw
                     " CBMatrix<_Int,_Flt>::AddReplaceSpThr: sparsity structure is not inclusive ";
            }
         } else {
            iblk1 = -1;
         }
         iblk2 = 0;
         if (ip2 <= iend2) {
            irow2 = plist_aa[ip2];
            iirow2 = plist2_aa[ip2];
            if (irow2 != irow || iirow2 != iirow) {
               iblk2 = -1;
               if (iirow2 < iirow || (iirow2 == iirow && irow2 < irow))
                  throw
                     " CBMatrix<_Int,_Flt>::AddReplaceSpThr: sparsity structure is not inclusive ";
            }
         } else {
            iblk2 = -1;
         }
         jp = pia_sum[ilist];
         jend = pia_sum[ilist + 1] - 1;
         jp1 = -1;
         jend1 = -1;
         if (iblk1 >= 0) {
            jp1 = pia[ip1];
            jend1 = pia[ip1 + 1] - 1;
            ip1++;
         }
         jp2 = -1;
         jend2 = -1;
         if (iblk2 >= 0) {
            jp2 = pia_aa[ip2];
            jend2 = pia_aa[ip2 + 1] - 1;
            ip2++;
         }

         while (jp <= jend) {

            jj = pja_sum[jp];
            jjj = pja2_sum[jp];

            pBlock_a_free = NULL;
            pBlock_b = NULL;

            if (iblk1 >= 0) {
               if (jp1 <= jend1) {
                  jj1 = pja[jp1];
                  jjj1 = pja2[jp1];
                  if (jjj1 == jjj) {
                     if (jj1 == jj) {
                        pBlock_a_free = pASub + jp1;
                        jp1++;
                     } else if (jj1 < jj) {
                        throw
                           " CBMatrix<_Int,_Flt>::AddReplaceSpThr: sparsity structure is not inclusive ";
                     }
                  } else if (jjj1 < jjj) {
                     throw
                        " CBMatrix<_Int,_Flt>::AddReplaceSpThr: sparsity structure is not inclusive ";
                  }
               }
            }

            if (iblk2 >= 0) {
               if (jp2 <= jend2) {
                  jj2 = pja_aa[jp2];
                  jjj2 = pja2_aa[jp2];
                  if (jjj2 == jjj) {
                     if (jj2 == jj) {
                        pBlock_b = pASub_aa + jp2;
                        jp2++;
                     } else if (jj2 < jj) {
                        throw
                           " CBMatrix<_Int,_Flt>::AddReplaceSpThr: sparsity structure is not inclusive ";
                     }
                  } else if (jjj2 < jjj) {
                     throw
                        " CBMatrix<_Int,_Flt>::AddReplacePairsThr: sparsity structure is not inclusive ";
                  }
               }
            }

            pptr_a[jp] = pBlock_a_free;
            pptr_b[jp] = pBlock_b;

            jp++;

         }
      }

      if (_b_use_thr) {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nzja_sum; ipar++) {

            CMatrix < _Int, _Flt > *pBlock_a_free = pptr_a[ipar];
            const CMatrix < _Int, _Flt > *pBlock_b = pptr_b[ipar];
            CMatrix < _Int, _Flt > *pBlock_sum = pASub_sum + ipar;

            if (pBlock_a_free != NULL && pBlock_b == NULL) {
               pBlock_sum->ReplaceFree (*pBlock_a_free);
            } else if (pBlock_a_free == NULL && pBlock_b != NULL) {
               *pBlock_sum = *pBlock_b;
            } else {
               pBlock_sum->AddBlocksSp (*pBlock_a_free, *pBlock_b);
               pBlock_a_free->Clean ();
            }

         }
      } else {
         for (int ipar = 0; ipar < nzja_sum; ipar++) {

            CMatrix < _Int, _Flt > *pBlock_a_free = pptr_a[ipar];
            const CMatrix < _Int, _Flt > *pBlock_b = pptr_b[ipar];
            CMatrix < _Int, _Flt > *pBlock_sum = pASub_sum + ipar;

            if (pBlock_a_free != NULL && pBlock_b == NULL) {
               pBlock_sum->ReplaceFree (*pBlock_a_free);
            } else if (pBlock_a_free == NULL && pBlock_b != NULL) {
               *pBlock_sum = *pBlock_b;
            } else {
               pBlock_sum->AddBlocksSp (*pBlock_a_free, *pBlock_b);
               pBlock_a_free->Clean ();
            }

         }
      }

// Replace the results

      this->SetNzblk (nzja_sum);

      this->hmatr_str.ReplaceFree (sum_str);
      this->asub_arr.swap (sum_ablks);

   }

// Add replace operator for pairs (threads version)
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::AddReplacePairsThr (bool _b_use_thr, const CBMatrix < _Int, _Flt > &_aa)
   {

      if (_aa.GetNzblk () == 0)
         return;

// Add sparsities

      CMatrix < int, float >sum_str;

      sum_str.AddBlocksSp (this->hmatr_str, _aa.hmatr_str);

// Open sparsities

      int nlistloc = this->hmatr_str.GetNlist ();
      int nlist2loc = this->hmatr_str.GetNlist2 ();
      int nzjaloc = this->hmatr_str.GetNzja ();
      int nzja2loc = this->hmatr_str.GetNzja2 ();
      int *plist = this->hmatr_str.GetListArr ();
      int *plist2 = this->hmatr_str.GetList2Arr ();
      int *pia = this->hmatr_str.GetIaArr ();
      int *pja = this->hmatr_str.GetJaArr ();
      int *pja2 = this->hmatr_str.GetJa2Arr ();

      int nlist_aa = _aa.hmatr_str.GetNlist ();
      int nlist2_aa = _aa.hmatr_str.GetNlist2 ();
      int nzja_aa = _aa.hmatr_str.GetNzja ();
      int nzja2_aa = _aa.hmatr_str.GetNzja2 ();
      const int *plist_aa = _aa.hmatr_str.GetListArr ();
      const int *plist2_aa = _aa.hmatr_str.GetList2Arr ();
      const int *pia_aa = _aa.hmatr_str.GetIaArr ();
      const int *pja_aa = _aa.hmatr_str.GetJaArr ();
      const int *pja2_aa = _aa.hmatr_str.GetJa2Arr ();

      int nlist_sum = sum_str.GetNlist ();
      int nlist2_sum = sum_str.GetNlist2 ();
      int nzja_sum = sum_str.GetNzja ();
      int nzja2_sum = sum_str.GetNzja2 ();
      int *plist_sum = sum_str.GetListArr ();
      int *plist2_sum = sum_str.GetList2Arr ();
      int *pia_sum = sum_str.GetIaArr ();
      int *pja_sum = sum_str.GetJaArr ();
      int *pja2_sum = sum_str.GetJa2Arr ();

// Detect 2 and 3 indices case

      if ((nlistloc != nlist2loc || nzjaloc != nzja2loc)
          || (nlist_aa != nlist2_aa || nzja_aa != nzja2_aa)
          || (nlist_sum != nlist2_sum || nzja_sum != nzja2_sum)) {
         throw " CBMatrix<_Int,_Flt>::AddReplacePairsThr: incorrect block sparsity ";
      }
// Allocate new set of blocks

      vector < CMatrix < _Int, _Flt > >sum_ablks (nzja_sum + 1);

// Add and free blocks in parallel

      CMatrix < _Int, _Flt > *pASub = &this->asub_arr[0];
      const CMatrix < _Int, _Flt > *pASub_aa = &_aa.asub_arr[0];
      CMatrix < _Int, _Flt > *pASub_sum = &sum_ablks[0];

      int iend1 = nlistloc - 1;
      int iend2 = nlist_aa - 1;

      int ilist, ip1, ip2, iblk1, iblk2, jend, jend1, jend2, jp, jp1, jp2;

      int irow, iirow, irow1, iirow1, irow2, iirow2;
      int jj, jjj, jj1, jjj1, jj2, jjj2;

      CMatrix < _Int, _Flt > *pBlock_a_free = NULL;
      const CMatrix < _Int, _Flt > *pBlock_b = NULL;

      vector < CMatrix < _Int, _Flt > *>ptr_a (nzja_sum + 1);
      vector < const CMatrix < _Int, _Flt > *>ptr_b (nzja_sum + 1);

      CMatrix < _Int, _Flt > **pptr_a = &ptr_a[0];
      const CMatrix < _Int, _Flt > **pptr_b = &ptr_b[0];

      ip1 = 0;
      ip2 = 0;

      for (ilist = 0; ilist < nlist_sum; ilist++) {
         irow = plist_sum[ilist];
         iirow = plist2_sum[ilist];
         iblk1 = 0;
         if (ip1 <= iend1) {
            irow1 = plist[ip1];
            iirow1 = plist2[ip1];
            if (irow1 != irow || iirow1 != iirow) {
               iblk1 = -1;
               if (iirow1 < iirow || (iirow1 == iirow && irow1 < irow))
                  throw
                     " CBMatrix<_Int,_Flt>::AddReplacePairsThr: sparsity structure is not inclusive ";
            }
         } else {
            iblk1 = -1;
         }
         iblk2 = 0;
         if (ip2 <= iend2) {
            irow2 = plist_aa[ip2];
            iirow2 = plist2_aa[ip2];
            if (irow2 != irow || iirow2 != iirow) {
               iblk2 = -1;
               if (iirow2 < iirow || (iirow2 == iirow && irow2 < irow))
                  throw
                     " CBMatrix<_Int,_Flt>::AddReplacePairsThr: sparsity structure is not inclusive ";
            }
         } else {
            iblk2 = -1;
         }
         jp = pia_sum[ilist];
         jend = pia_sum[ilist + 1] - 1;
         jp1 = -1;
         jend1 = -1;
         if (iblk1 >= 0) {
            jp1 = pia[ip1];
            jend1 = pia[ip1 + 1] - 1;
            ip1++;
         }
         jp2 = -1;
         jend2 = -1;
         if (iblk2 >= 0) {
            jp2 = pia_aa[ip2];
            jend2 = pia_aa[ip2 + 1] - 1;
            ip2++;
         }

         while (jp <= jend) {

            jj = pja_sum[jp];
            jjj = pja2_sum[jp];

            pBlock_a_free = NULL;
            pBlock_b = NULL;

            if (iblk1 >= 0) {
               if (jp1 <= jend1) {
                  jj1 = pja[jp1];
                  jjj1 = pja2[jp1];
                  if (jjj1 == jjj) {
                     if (jj1 == jj) {
                        pBlock_a_free = pASub + jp1;
                        jp1++;
                     } else if (jj1 < jj) {
                        throw
                           " CBMatrix<_Int,_Flt>::AddReplacePairsThr: sparsity structure is not inclusive ";
                     }
                  } else if (jjj1 < jjj) {
                     throw
                        " CBMatrix<_Int,_Flt>::AddReplacePairsThr: sparsity structure is not inclusive ";
                  }
               }
            }

            if (iblk2 >= 0) {
               if (jp2 <= jend2) {
                  jj2 = pja_aa[jp2];
                  jjj2 = pja2_aa[jp2];
                  if (jjj2 == jjj) {
                     if (jj2 == jj) {
                        pBlock_b = pASub_aa + jp2;
                        jp2++;
                     } else if (jj2 < jj) {
                        throw
                           " CBMatrix<_Int,_Flt>::AddReplacePairsThr: sparsity structure is not inclusive ";
                     }
                  } else if (jjj2 < jjj) {
                     throw
                        " CBMatrix<_Int,_Flt>::AddReplacePairsThr: sparsity structure is not inclusive ";
                  }
               }
            }

            pptr_a[jp] = pBlock_a_free;
            pptr_b[jp] = pBlock_b;

            jp++;

         }
      }

      if (_b_use_thr) {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nzja_sum; ipar++) {

            CMatrix < _Int, _Flt > *pBlock_a_free = pptr_a[ipar];
            const CMatrix < _Int, _Flt > *pBlock_b = pptr_b[ipar];
            CMatrix < _Int, _Flt > *pBlock_sum = pASub_sum + ipar;

            if (pBlock_a_free != NULL && pBlock_b == NULL) {
               pBlock_sum->ReplaceFree (*pBlock_a_free);
            } else if (pBlock_a_free == NULL && pBlock_b != NULL) {
               *pBlock_sum = *pBlock_b;
            } else {
               *pBlock_a_free %= *pBlock_b;
               pBlock_sum->ReplaceFree (*pBlock_a_free);
            }

         }
      } else {
         for (int ipar = 0; ipar < nzja_sum; ipar++) {

            CMatrix < _Int, _Flt > *pBlock_a_free = pptr_a[ipar];
            const CMatrix < _Int, _Flt > *pBlock_b = pptr_b[ipar];
            CMatrix < _Int, _Flt > *pBlock_sum = pASub_sum + ipar;

            if (pBlock_a_free != NULL && pBlock_b == NULL) {
               pBlock_sum->ReplaceFree (*pBlock_a_free);
            } else if (pBlock_a_free == NULL && pBlock_b != NULL) {
               *pBlock_sum = *pBlock_b;
            } else {
               *pBlock_a_free %= *pBlock_b;
               pBlock_sum->ReplaceFree (*pBlock_a_free);
            }

         }
      }

// Replace the results

      this->SetNzblk (nzja_sum);

      this->hmatr_str.ReplaceFree (sum_str);
      this->asub_arr.swap (sum_ablks);

   }

// Add replace operator (threads version)
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::AddReplaceBxBThr (bool _b_use_thr, int _blksize, const CBMatrix < _Int,
                                _Flt > &_aa)
   {

      if (_aa.GetNzblk () == 0)
         return;

// Add sparsities

      CMatrix < int, float >sum_str;

      sum_str.AddBlocksSp (this->hmatr_str, _aa.hmatr_str);

// Open sparsities

      int nlistloc = this->hmatr_str.GetNlist ();
      int nlist2loc = this->hmatr_str.GetNlist2 ();
      int nzjaloc = this->hmatr_str.GetNzja ();
      int nzja2loc = this->hmatr_str.GetNzja2 ();
      int *plist = this->hmatr_str.GetListArr ();
      int *plist2 = this->hmatr_str.GetList2Arr ();
      int *pia = this->hmatr_str.GetIaArr ();
      int *pja = this->hmatr_str.GetJaArr ();
      int *pja2 = this->hmatr_str.GetJa2Arr ();

      int nlist_aa = _aa.hmatr_str.GetNlist ();
      int nlist2_aa = _aa.hmatr_str.GetNlist2 ();
      int nzja_aa = _aa.hmatr_str.GetNzja ();
      int nzja2_aa = _aa.hmatr_str.GetNzja2 ();
      const int *plist_aa = _aa.hmatr_str.GetListArr ();
      const int *plist2_aa = _aa.hmatr_str.GetList2Arr ();
      const int *pia_aa = _aa.hmatr_str.GetIaArr ();
      const int *pja_aa = _aa.hmatr_str.GetJaArr ();
      const int *pja2_aa = _aa.hmatr_str.GetJa2Arr ();

      int nlist_sum = sum_str.GetNlist ();
      int nlist2_sum = sum_str.GetNlist2 ();
      int nzja_sum = sum_str.GetNzja ();
      int nzja2_sum = sum_str.GetNzja2 ();
      int *plist_sum = sum_str.GetListArr ();
      int *plist2_sum = sum_str.GetList2Arr ();
      int *pia_sum = sum_str.GetIaArr ();
      int *pja_sum = sum_str.GetJaArr ();
      int *pja2_sum = sum_str.GetJa2Arr ();

// Detect 2 and 3 indices case

      if ((nlistloc != nlist2loc || nzjaloc != nzja2loc)
          || (nlist_aa != nlist2_aa || nzja_aa != nzja2_aa)
          || (nlist_sum != nlist2_sum || nzja_sum != nzja2_sum)) {
         throw " CBMatrix<_Int,_Flt>::AddReplacePairsThr_BxB: incorrect block sparsity ";
      }
// Allocate new set of blocks

      vector < CMatrix < _Int, _Flt > >sum_ablks (nzja_sum + 1);

// Add and free blocks in parallel

      CMatrix < _Int, _Flt > *pASub = &this->asub_arr[0];
      const CMatrix < _Int, _Flt > *pASub_aa = &_aa.asub_arr[0];
      CMatrix < _Int, _Flt > *pASub_sum = &sum_ablks[0];

      int iend1 = nlistloc - 1;
      int iend2 = nlist_aa - 1;

      int ilist, ip1, ip2, iblk1, iblk2, jend, jend1, jend2, jp, jp1, jp2;

      int irow, iirow, irow1, iirow1, irow2, iirow2;
      int jj, jjj, jj1, jjj1, jj2, jjj2;

      CMatrix < _Int, _Flt > *pBlock_a_free = NULL;
      const CMatrix < _Int, _Flt > *pBlock_b = NULL;

      vector < CMatrix < _Int, _Flt > *>ptr_a (nzja_sum + 1);
      vector < const CMatrix < _Int, _Flt > *>ptr_b (nzja_sum + 1);

      CMatrix < _Int, _Flt > **pptr_a = &ptr_a[0];
      const CMatrix < _Int, _Flt > **pptr_b = &ptr_b[0];

      ip1 = 0;
      ip2 = 0;

      for (ilist = 0; ilist < nlist_sum; ilist++) {
         irow = plist_sum[ilist];
         iirow = plist2_sum[ilist];
         iblk1 = 0;
         if (ip1 <= iend1) {
            irow1 = plist[ip1];
            iirow1 = plist2[ip1];
            if (irow1 != irow || iirow1 != iirow) {
               iblk1 = -1;
               if (iirow1 < iirow || (iirow1 == iirow && irow1 < irow))
                  throw
                     " CBMatrix<_Int,_Flt>::AddReplacePairsThr_BxB: sparsity structure is not inclusive ";
            }
         } else {
            iblk1 = -1;
         }
         iblk2 = 0;
         if (ip2 <= iend2) {
            irow2 = plist_aa[ip2];
            iirow2 = plist2_aa[ip2];
            if (irow2 != irow || iirow2 != iirow) {
               iblk2 = -1;
               if (iirow2 < iirow || (iirow2 == iirow && irow2 < irow))
                  throw
                     " CBMatrix<_Int,_Flt>::AddReplacePairsThr_BxB: sparsity structure is not inclusive ";
            }
         } else {
            iblk2 = -1;
         }
         jp = pia_sum[ilist];
         jend = pia_sum[ilist + 1] - 1;
         jp1 = -1;
         jend1 = -1;
         if (iblk1 >= 0) {
            jp1 = pia[ip1];
            jend1 = pia[ip1 + 1] - 1;
            ip1++;
         }
         jp2 = -1;
         jend2 = -1;
         if (iblk2 >= 0) {
            jp2 = pia_aa[ip2];
            jend2 = pia_aa[ip2 + 1] - 1;
            ip2++;
         }

         while (jp <= jend) {

            jj = pja_sum[jp];
            jjj = pja2_sum[jp];

            pBlock_a_free = NULL;
            pBlock_b = NULL;

            if (iblk1 >= 0) {
               if (jp1 <= jend1) {
                  jj1 = pja[jp1];
                  jjj1 = pja2[jp1];
                  if (jjj1 == jjj) {
                     if (jj1 == jj) {
                        pBlock_a_free = pASub + jp1;
                        jp1++;
                     } else if (jj1 < jj) {
                        throw
                           " CBMatrix<_Int,_Flt>::AddReplacePairsThr_BxB: sparsity structure is not inclusive ";
                     }
                  } else if (jjj1 < jjj) {
                     throw
                        " CBMatrix<_Int,_Flt>::AddReplacePairsThr_BxB: sparsity structure is not inclusive ";
                  }
               }
            }

            if (iblk2 >= 0) {
               if (jp2 <= jend2) {
                  jj2 = pja_aa[jp2];
                  jjj2 = pja2_aa[jp2];
                  if (jjj2 == jjj) {
                     if (jj2 == jj) {
                        pBlock_b = pASub_aa + jp2;
                        jp2++;
                     } else if (jj2 < jj) {
                        throw
                           " CBMatrix<_Int,_Flt>::AddReplacePairsThr_BxB: sparsity structure is not inclusive ";
                     }
                  } else if (jjj2 < jjj) {
                     throw
                        " CBMatrix<_Int,_Flt>::AddReplacePairsThr_BxB: sparsity structure is not inclusive ";
                  }
               }
            }

            pptr_a[jp] = pBlock_a_free;
            pptr_b[jp] = pBlock_b;

            jp++;

         }
      }

      if (_b_use_thr) {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nzja_sum; ipar++) {

            CMatrix < _Int, _Flt > *pBlock_a_free = pptr_a[ipar];
            const CMatrix < _Int, _Flt > *pBlock_b = pptr_b[ipar];
            CMatrix < _Int, _Flt > *pBlock_sum = pASub_sum + ipar;

            if (pBlock_a_free != NULL && pBlock_b == NULL) {
               pBlock_sum->ReplaceFree (*pBlock_a_free);
            } else if (pBlock_a_free == NULL && pBlock_b != NULL) {
               *pBlock_sum = *pBlock_b;
            } else {

               pBlock_sum->AddBlocksBxB ('+', _blksize, *pBlock_a_free, *pBlock_b);

               pBlock_a_free->Clean ();

            }

         }
      } else {
         for (int ipar = 0; ipar < nzja_sum; ipar++) {

            CMatrix < _Int, _Flt > *pBlock_a_free = pptr_a[ipar];
            const CMatrix < _Int, _Flt > *pBlock_b = pptr_b[ipar];
            CMatrix < _Int, _Flt > *pBlock_sum = pASub_sum + ipar;

            if (pBlock_a_free != NULL && pBlock_b == NULL) {
               pBlock_sum->ReplaceFree (*pBlock_a_free);
            } else if (pBlock_a_free == NULL && pBlock_b != NULL) {
               *pBlock_sum = *pBlock_b;
            } else {

               pBlock_sum->AddBlocksBxB ('+', _blksize, *pBlock_a_free, *pBlock_b);

               pBlock_a_free->Clean ();

            }

         }
      }

// Replace the results

      this->SetNzblk (nzja_sum);

      this->hmatr_str.ReplaceFree (sum_str);
      this->asub_arr.swap (sum_ablks);

   }

// Add replace operator for pairs (threads version)
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::AddReplacePairsBxBThr (bool _b_use_thr, int _blksize, const CBMatrix < _Int,
                                     _Flt > &_aa)
   {

      if (_aa.GetNzblk () == 0)
         return;

// Add sparsities

      CMatrix < int, float >sum_str;

      sum_str.AddBlocksSp (this->hmatr_str, _aa.hmatr_str);

// Open sparsities

      int nlistloc = this->hmatr_str.GetNlist ();
      int nlist2loc = this->hmatr_str.GetNlist2 ();
      int nzjaloc = this->hmatr_str.GetNzja ();
      int nzja2loc = this->hmatr_str.GetNzja2 ();
      int *plist = this->hmatr_str.GetListArr ();
      int *plist2 = this->hmatr_str.GetList2Arr ();
      int *pia = this->hmatr_str.GetIaArr ();
      int *pja = this->hmatr_str.GetJaArr ();
      int *pja2 = this->hmatr_str.GetJa2Arr ();

      int nlist_aa = _aa.hmatr_str.GetNlist ();
      int nlist2_aa = _aa.hmatr_str.GetNlist2 ();
      int nzja_aa = _aa.hmatr_str.GetNzja ();
      int nzja2_aa = _aa.hmatr_str.GetNzja2 ();
      const int *plist_aa = _aa.hmatr_str.GetListArr ();
      const int *plist2_aa = _aa.hmatr_str.GetList2Arr ();
      const int *pia_aa = _aa.hmatr_str.GetIaArr ();
      const int *pja_aa = _aa.hmatr_str.GetJaArr ();
      const int *pja2_aa = _aa.hmatr_str.GetJa2Arr ();

      int nlist_sum = sum_str.GetNlist ();
      int nlist2_sum = sum_str.GetNlist2 ();
      int nzja_sum = sum_str.GetNzja ();
      int nzja2_sum = sum_str.GetNzja2 ();
      int *plist_sum = sum_str.GetListArr ();
      int *plist2_sum = sum_str.GetList2Arr ();
      int *pia_sum = sum_str.GetIaArr ();
      int *pja_sum = sum_str.GetJaArr ();
      int *pja2_sum = sum_str.GetJa2Arr ();

// Detect 2 and 3 indices case

      if ((nlistloc != nlist2loc || nzjaloc != nzja2loc)
          || (nlist_aa != nlist2_aa || nzja_aa != nzja2_aa)
          || (nlist_sum != nlist2_sum || nzja_sum != nzja2_sum)) {
         throw " CBMatrix<_Int,_Flt>::AddReplacePairsThr_BxB: incorrect block sparsity ";
      }
// Allocate new set of blocks

      vector < CMatrix < _Int, _Flt > >sum_ablks (nzja_sum + 1);

// Add and free blocks in parallel

      CMatrix < _Int, _Flt > *pASub = &this->asub_arr[0];
      const CMatrix < _Int, _Flt > *pASub_aa = &_aa.asub_arr[0];
      CMatrix < _Int, _Flt > *pASub_sum = &sum_ablks[0];

      int iend1 = nlistloc - 1;
      int iend2 = nlist_aa - 1;

      int ilist, ip1, ip2, iblk1, iblk2, jend, jend1, jend2, jp, jp1, jp2;

      int irow, iirow, irow1, iirow1, irow2, iirow2;
      int jj, jjj, jj1, jjj1, jj2, jjj2;

      CMatrix < _Int, _Flt > *pBlock_a_free = NULL;
      const CMatrix < _Int, _Flt > *pBlock_b = NULL;

      vector < CMatrix < _Int, _Flt > *>ptr_a (nzja_sum + 1);
      vector < const CMatrix < _Int, _Flt > *>ptr_b (nzja_sum + 1);

      CMatrix < _Int, _Flt > **pptr_a = &ptr_a[0];
      const CMatrix < _Int, _Flt > **pptr_b = &ptr_b[0];

      ip1 = 0;
      ip2 = 0;

      for (ilist = 0; ilist < nlist_sum; ilist++) {
         irow = plist_sum[ilist];
         iirow = plist2_sum[ilist];
         iblk1 = 0;
         if (ip1 <= iend1) {
            irow1 = plist[ip1];
            iirow1 = plist2[ip1];
            if (irow1 != irow || iirow1 != iirow) {
               iblk1 = -1;
               if (iirow1 < iirow || (iirow1 == iirow && irow1 < irow))
                  throw
                     " CBMatrix<_Int,_Flt>::AddReplacePairsThr_BxB: sparsity structure is not inclusive ";
            }
         } else {
            iblk1 = -1;
         }
         iblk2 = 0;
         if (ip2 <= iend2) {
            irow2 = plist_aa[ip2];
            iirow2 = plist2_aa[ip2];
            if (irow2 != irow || iirow2 != iirow) {
               iblk2 = -1;
               if (iirow2 < iirow || (iirow2 == iirow && irow2 < irow))
                  throw
                     " CBMatrix<_Int,_Flt>::AddReplacePairsThr_BxB: sparsity structure is not inclusive ";
            }
         } else {
            iblk2 = -1;
         }
         jp = pia_sum[ilist];
         jend = pia_sum[ilist + 1] - 1;
         jp1 = -1;
         jend1 = -1;
         if (iblk1 >= 0) {
            jp1 = pia[ip1];
            jend1 = pia[ip1 + 1] - 1;
            ip1++;
         }
         jp2 = -1;
         jend2 = -1;
         if (iblk2 >= 0) {
            jp2 = pia_aa[ip2];
            jend2 = pia_aa[ip2 + 1] - 1;
            ip2++;
         }

         while (jp <= jend) {

            jj = pja_sum[jp];
            jjj = pja2_sum[jp];

            pBlock_a_free = NULL;
            pBlock_b = NULL;

            if (iblk1 >= 0) {
               if (jp1 <= jend1) {
                  jj1 = pja[jp1];
                  jjj1 = pja2[jp1];
                  if (jjj1 == jjj) {
                     if (jj1 == jj) {
                        pBlock_a_free = pASub + jp1;
                        jp1++;
                     } else if (jj1 < jj) {
                        throw
                           " CBMatrix<_Int,_Flt>::AddReplacePairsThr_BxB: sparsity structure is not inclusive ";
                     }
                  } else if (jjj1 < jjj) {
                     throw
                        " CBMatrix<_Int,_Flt>::AddReplacePairsThr_BxB: sparsity structure is not inclusive ";
                  }
               }
            }

            if (iblk2 >= 0) {
               if (jp2 <= jend2) {
                  jj2 = pja_aa[jp2];
                  jjj2 = pja2_aa[jp2];
                  if (jjj2 == jjj) {
                     if (jj2 == jj) {
                        pBlock_b = pASub_aa + jp2;
                        jp2++;
                     } else if (jj2 < jj) {
                        throw
                           " CBMatrix<_Int,_Flt>::AddReplacePairsThr_BxB: sparsity structure is not inclusive ";
                     }
                  } else if (jjj2 < jjj) {
                     throw
                        " CBMatrix<_Int,_Flt>::AddReplacePairsThr_BxB: sparsity structure is not inclusive ";
                  }
               }
            }

            pptr_a[jp] = pBlock_a_free;
            pptr_b[jp] = pBlock_b;

            jp++;

         }
      }

      if (_b_use_thr) {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nzja_sum; ipar++) {

            CMatrix < _Int, _Flt > *pBlock_a_free = pptr_a[ipar];
            const CMatrix < _Int, _Flt > *pBlock_b = pptr_b[ipar];
            CMatrix < _Int, _Flt > *pBlock_sum = pASub_sum + ipar;

            if (pBlock_a_free != NULL && pBlock_b == NULL) {
               pBlock_sum->ReplaceFree (*pBlock_a_free);
            } else if (pBlock_a_free == NULL && pBlock_b != NULL) {
               *pBlock_sum = *pBlock_b;
            } else {

               pBlock_sum->AddBlocksPairsBxB ('+', _blksize, *pBlock_a_free, *pBlock_b);

               pBlock_a_free->Clean ();

            }

         }
      } else {
         for (int ipar = 0; ipar < nzja_sum; ipar++) {

            CMatrix < _Int, _Flt > *pBlock_a_free = pptr_a[ipar];
            const CMatrix < _Int, _Flt > *pBlock_b = pptr_b[ipar];
            CMatrix < _Int, _Flt > *pBlock_sum = pASub_sum + ipar;

            if (pBlock_a_free != NULL && pBlock_b == NULL) {
               pBlock_sum->ReplaceFree (*pBlock_a_free);
            } else if (pBlock_a_free == NULL && pBlock_b != NULL) {
               *pBlock_sum = *pBlock_b;
            } else {

               pBlock_sum->AddBlocksPairsBxB ('+', _blksize, *pBlock_a_free, *pBlock_b);

               pBlock_a_free->Clean ();

            }

         }
      }

// Replace the results

      this->SetNzblk (nzja_sum);

      this->hmatr_str.ReplaceFree (sum_str);
      this->asub_arr.swap (sum_ablks);

   }

//
// Init by data
//========================================================================================
   template < typename _Int, typename _Flt > CBMatrix < _Int, _Flt >::CBMatrix (int _iblk,
                                                                                int
                                                                                _nlist,
                                                                                _Int *
                                                                                _list,
                                                                                _Int *
                                                                                _ia,
                                                                                _Int *
                                                                                _ja,
                                                                                _Flt * _a,
                                                                                int
                                                                                _nblks,
                                                                                long long
                                                                                *_blks,
                                                                                int
                                                                                &_icycle,
                                                                                int
                                                                                *_imaskblk)
   {

// Check list array

      int i;

      long long jj;

      for (i = 0; i < _nlist; i++) {
         jj = _list[i];
         if (jj < _blks[_iblk] || jj >= _blks[_iblk + 1]) {
            throw " CBMatrix<>::CBMatrix: error: incorrect list array ";
         }
      }

// Create sorted ja and a data

      int nzja = (int) _ia[_nlist];

      int nirowmax = 0;

      int nirowloc;

      for (i = 0; i < _nlist; i++) {
         nirowloc = (int) (_ia[i + 1] - _ia[i]);
         if (nirowloc > nirowmax)
            nirowmax = nirowloc;
      }

      vector < _Int > jasort (nzja + 1);
      vector < _Flt > asort (nzja + 1);

      _Int *pjasort = &jasort[0];
      _Flt *pasort = &asort[0];

      vector < CSortInt > iiarr (nirowmax + 1);

      CSortInt *piiarr = &iiarr[0];

      int ibeg, j;

      for (i = 0; i < _nlist; i++) {
         nirowloc = (int) (_ia[i + 1] - _ia[i]);
         ibeg = (int) _ia[i];
         for (j = 0; j < nirowloc; j++) {
            piiarr[j].ival = (int) _ja[j + ibeg];
            piiarr[j].i2val = j + ibeg;
         }
         sort (piiarr, piiarr + nirowloc);
         for (j = 0; j < nirowloc; j++) {
            pjasort[j + ibeg] = piiarr[j].ival;
            pasort[j + ibeg] = _a[piiarr[j].i2val];
         }
      }

// Compute ja2 array

      vector < _Int > ja2 (nzja + 1);
      _Int *pja2 = &ja2[0];

      CBMatrix < _Int, _Flt >::ComputeJa2 (_nblks, _blks, _nlist, _ia, pjasort, pja2);

// Create list of block numbers

      _icycle++;

      int nlistblk = 0;

      vector < int >listblk;

      _imaskblk[_iblk] = _icycle;
      nlistblk++;
      listblk.push_back (_iblk);

      int jblk;

      for (i = 0; i < nzja; i++) {
         jblk = (int) pja2[i];
         if (_imaskblk[jblk] != _icycle) {
            _imaskblk[jblk] = _icycle;
            nlistblk++;
            listblk.push_back (jblk);
         }
      }

      int *plistblk = NULL;
      if (nlistblk > 0)
         plistblk = &listblk[0];

      sort (plistblk, plistblk + nlistblk);

      int *pindlistblk = _imaskblk + _nblks;

      for (i = 0; i < nlistblk; i++) {
         jblk = (int) plistblk[i];
         pindlistblk[jblk] = i;
      }

// Split block row into blocks

      int *pnzblk = _imaskblk + 2 * _nblks;

      for (i = 0; i < nlistblk; i++) {
         jblk = plistblk[i];
         pnzblk[jblk] = 0;
      }

      for (i = 0; i < nzja; i++) {
         jblk = (int) pja2[i];
         pnzblk[jblk]++;
      }

      pnzblk[_iblk] += _nlist;

      vector < int >imask_dia (_nlist + 1);
      int *pimask_dia = &imask_dia[0];

      for (i = 0; i < _nlist; i++)
         pimask_dia[i] = -1;

      vector < vector < _Int > >irowarr_blk (nlistblk + 1);
      vector < vector < _Int > >icolarr_blk (nlistblk + 1);
      vector < vector < _Flt > >valarr_blk (nlistblk + 1);

      vector < _Int > *pirowarr_blk = &irowarr_blk[0];
      vector < _Int > *picolarr_blk = &icolarr_blk[0];
      vector < _Flt > *pvalarr_blk = &valarr_blk[0];

      for (i = 0; i < nlistblk; i++) {
         jblk = (int) plistblk[i];
         pirowarr_blk[i].resize (pnzblk[jblk] + 1);
         picolarr_blk[i].resize (pnzblk[jblk] + 1);
         pvalarr_blk[i].resize (pnzblk[jblk] + 1);
      }

      for (i = 0; i < nlistblk; i++) {
         jblk = plistblk[i];
         pnzblk[jblk] = 0;
      }

      _Int *ppirowarr_blk;
      _Int *ppicolarr_blk;
      _Flt *ppvalarr_blk;

      int ind, k;

      for (i = 0; i < _nlist; i++) {
         for (j = (int) _ia[i]; j < _ia[i + 1]; j++) {
            jj = (int) pjasort[j];
            jblk = (int) pja2[j];
            jj -= (int) _blks[jblk];
            ind = (int) pindlistblk[jblk];
            ppirowarr_blk = &(pirowarr_blk[ind][0]);
            ppicolarr_blk = &(picolarr_blk[ind][0]);
            ppvalarr_blk = &(pvalarr_blk[ind][0]);
            k = (int) pnzblk[jblk];
            ppirowarr_blk[k] = (_Int) (_list[i] - _blks[_iblk]);
            ppicolarr_blk[k] = (_Int) jj;
            ppvalarr_blk[k] = pasort[j];
            pnzblk[jblk]++;
            if (jblk == _iblk) {
               if (i == jj) {
                  pimask_dia[i] = 1;
               }
            }
         }
      }

      jasort.resize (0);
      asort.resize (0);

// Add zero diagonal elems

      int nz_add_dia = 0;

      _Flt fzero = (_Flt) 0.0e0;

      for (i = 0; i < nlistblk; i++) {
         jblk = (int) plistblk[i];
         if (jblk == _iblk) {
            ind = (int) pindlistblk[jblk];
            ppirowarr_blk = &(pirowarr_blk[ind][0]);
            ppicolarr_blk = &(picolarr_blk[ind][0]);
            ppvalarr_blk = &(pvalarr_blk[ind][0]);
            for (j = 0; j < _nlist; j++) {
               if (pimask_dia[j] < 0) {
                  k = (int) pnzblk[jblk];
                  ppirowarr_blk[k] = (_Int) j;
                  ppicolarr_blk[k] = (_Int) j;
                  ppvalarr_blk[k] = fzero;
                  pnzblk[jblk]++;
                  nz_add_dia++;
               }
            }
         }
      }

// Store block sparsity matrix

      this->nzblk = nlistblk;

      int ia_1blk[2];

      ia_1blk[0] = 0;
      ia_1blk[1] = nlistblk;

      CMatrix < int, float >hmatr_str_temp (1, &_iblk, ia_1blk, plistblk);

      this->hmatr_str.ReplaceFree (hmatr_str_temp);

// For each block compute the list of rows and ia arrays

      int nimax = 0;

      int ni;

      for (i = 0; i < nlistblk; i++) {
         jblk = plistblk[i];
         ni = (int) (_blks[jblk + 1] - _blks[jblk]);
         if (ni > nimax)
            nimax = ni;
      }

      vector < int >imask (nimax + 1);
      vector < int >list (nimax + 1);
      vector < int >indlist (nimax + 1);
      vector < int >iptr (nimax + 1);
      vector < CSortInt > iiarr2 (nimax + 1);
      vector < _Int > jasort2 (nimax + 1);
      vector < _Flt > asort2 (nimax + 1);

      int *pimask = &imask[0];
      int *plist = &list[0];
      int *pindlist = &indlist[0];
      int *piptr = &iptr[0];
      CSortInt *piiarr2 = &iiarr2[0];
      _Int *pjasort2 = &jasort2[0];
      _Flt *pasort2 = &asort2[0];

      int icycle = -1;

      for (i = 0; i < nimax; i++)
         pimask[i] = -1;

      vector < int >nlistarr_blk (nlistblk + 1);
      vector < vector < _Int > >listarr_blk (nlistblk + 1);
      vector < vector < _Int > >iaarr_blk (nlistblk + 1);
      vector < vector < _Int > >jaarr_blk (nlistblk + 1);
      vector < vector < _Flt > >aarr_blk (nlistblk + 1);

      int *pnlistarr_blk = &nlistarr_blk[0];
      vector < _Int > *plistarr_blk = &listarr_blk[0];
      vector < _Int > *piaarr_blk = &iaarr_blk[0];
      vector < _Int > *pjaarr_blk = &jaarr_blk[0];
      vector < _Flt > *paarr_blk = &aarr_blk[0];

      for (i = 0; i < nlistblk; i++)
         pnlistarr_blk[i] = 0;

      int nlistloc;
      _Int *pplistarr_blk;
      _Int *ppiaarr_blk;
      _Int *ppjaarr_blk;
      _Flt *ppaarr_blk;

      int i1;

      for (i = 0; i < nlistblk; i++) {
         jblk = plistblk[i];
         icycle++;
         ppirowarr_blk = &(pirowarr_blk[i][0]);
         ppicolarr_blk = &(picolarr_blk[i][0]);
         ppvalarr_blk = &(pvalarr_blk[i][0]);
         nlistloc = 0;
         for (j = 0; j < pnzblk[jblk]; j++) {
            jj = ppirowarr_blk[j];
            if (pimask[jj] != icycle) {
               plist[nlistloc] = (int) jj;
               nlistloc++;
               pimask[jj] = icycle;
            }
         }
         pnlistarr_blk[i] = nlistloc;
         sort (plist, plist + nlistloc);
         for (j = 0; j < nlistloc; j++) {
            jj = plist[j];
            pindlist[jj] = j;
         }
         plistarr_blk[i].resize (nlistloc + 1);
         piaarr_blk[i].resize (nlistloc + 1);
         pjaarr_blk[i].resize (pnzblk[jblk] + 1);
         paarr_blk[i].resize (pnzblk[jblk] + 1);
         pplistarr_blk = &(plistarr_blk[i][0]);
         ppiaarr_blk = &(piaarr_blk[i][0]);
         ppjaarr_blk = &(pjaarr_blk[i][0]);
         ppaarr_blk = &(paarr_blk[i][0]);
         for (j = 0; j < nlistloc; j++)
            pplistarr_blk[j] = plist[j];
         for (j = 0; j <= nlistloc; j++)
            ppiaarr_blk[j] = 0;
         for (j = 0; j < pnzblk[jblk]; j++) {
            jj = ppirowarr_blk[j];
            ind = pindlist[jj];
            ppiaarr_blk[ind + 1]++;
         }
         for (j = 0; j < nlistloc; j++)
            ppiaarr_blk[j + 1] = ppiaarr_blk[j] + ppiaarr_blk[j + 1];
         for (j = 0; j < nlistloc; j++)
            piptr[j] = (int) ppiaarr_blk[j];
         for (j = 0; j < pnzblk[jblk]; j++) {
            jj = ppirowarr_blk[j];
            ind = pindlist[jj];
            k = piptr[ind];
            ppjaarr_blk[k] = ppicolarr_blk[j];
            ppaarr_blk[k] = ppvalarr_blk[j];
            piptr[ind]++;
         }
         for (i1 = 0; i1 < nlistloc; i1++) {
            nirowloc = (int) (ppiaarr_blk[i1 + 1] - ppiaarr_blk[i1]);
            ibeg = (int) ppiaarr_blk[i1];
            for (j = 0; j < nirowloc; j++) {
               piiarr2[j].ival = (int) ppjaarr_blk[j + ibeg];
               piiarr2[j].i2val = j + ibeg;
            }
            sort (piiarr, piiarr + nirowloc);
            for (j = 0; j < nirowloc; j++) {
               pjasort2[j] = piiarr2[j].ival;
               pasort2[j] = ppaarr_blk[piiarr2[j].i2val];
            }
            for (j = 0; j < nirowloc; j++) {
               ppjaarr_blk[j + ibeg] = pjasort2[j];
               ppaarr_blk[j + ibeg] = pasort2[j];
            }
         }
      }

// Store results as hmatrix data

      vector < CMatrix < _Int, _Flt > >asub_arr_temp (nlistblk + 1);

      CMatrix < _Int, _Flt > *pasub_arr_temp = &asub_arr_temp[0];

      for (i = 0; i < nlistblk; i++) {
         jblk = plistblk[i];
         vector < _Int > *plist_temp = pasub_arr_temp[i].GetList ();
         vector < _Int > *pia_temp = pasub_arr_temp[i].GetIa ();
         vector < _Int > *pja_temp = pasub_arr_temp[i].GetJa ();
         vector < _Flt > *pa_temp = pasub_arr_temp[i].GetA ();
         pasub_arr_temp[i].SetNlist (pnlistarr_blk[i]);
         pasub_arr_temp[i].SetNzja (pnzblk[jblk]);
         pasub_arr_temp[i].SetNza (pnzblk[jblk]);
         plist_temp->swap (plistarr_blk[i]);
         pia_temp->swap (piaarr_blk[i]);
         pja_temp->swap (pjaarr_blk[i]);
         pa_temp->swap (paarr_blk[i]);
      }

      this->asub_arr.resize (nlistblk + 1);

      CMatrix < _Int, _Flt > *pasub_arr = &(this->asub_arr[0]);

      for (i = 0; i < nlistblk; i++)
         pasub_arr[i].ReplaceFree (pasub_arr_temp[i]);

   }

//
// Init by data
//========================================================================================
   template < typename _Int, typename _Flt > CBMatrix < _Int,
      _Flt >::CBMatrix (int _blksize, int _iblk, int _nlist, _Int * _list, _Int * _ia,
                        _Int * _ja, _Flt * _a, int _nblks, long long *_blks, int &_icycle,
                        int *_imaskblk)
   {

      int b_2 = _blksize * _blksize;

// Check list array

      int i;

      long long jj;

      for (i = 0; i < _nlist; i++) {
         jj = _list[i];
         if (jj < _blks[_iblk] || jj >= _blks[_iblk + 1]) {
            throw " CBMatrix<>::CBMatrix: error: incorrect list array ";
         }
      }

// Create sorted ja and a data

      int nzja = (int) _ia[_nlist];

      int nirowmax = 0;

      int nirowloc;

      for (i = 0; i < _nlist; i++) {
         nirowloc = (int) (_ia[i + 1] - _ia[i]);
         if (nirowloc > nirowmax)
            nirowmax = nirowloc;
      }

      vector < _Int > jasort (nzja + 1);
      vector < _Flt > asort (nzja * b_2 + 1);

      _Int *pjasort = &jasort[0];
      _Flt *pasort = &asort[0];

      vector < CSortInt > iiarr (nirowmax + 1);

      CSortInt *piiarr = &iiarr[0];

      int ibeg, j;

      for (i = 0; i < _nlist; i++) {
         nirowloc = (int) (_ia[i + 1] - _ia[i]);
         ibeg = (int) _ia[i];
         for (j = 0; j < nirowloc; j++) {
            piiarr[j].ival = (int) _ja[j + ibeg];
            piiarr[j].i2val = j + ibeg;
         }
         sort (piiarr, piiarr + nirowloc);
         for (j = 0; j < nirowloc; j++) {
            pjasort[j + ibeg] = piiarr[j].ival;
            CVector < _Flt >::CopyVector (b_2, _a + piiarr[j].i2val * b_2,
                                          pasort + (j + ibeg) * b_2);
         }
      }

// Compute ja2 array

      vector < _Int > ja2 (nzja + 1);
      _Int *pja2 = &ja2[0];

      CBMatrix < _Int, _Flt >::ComputeJa2 (_nblks, _blks, _nlist, _ia, pjasort, pja2);

// Create list of block numbers

      _icycle++;

      int nlistblk = 0;

      vector < int >listblk;

      _imaskblk[_iblk] = _icycle;
      nlistblk++;
      listblk.push_back (_iblk);

      int jblk;

      for (i = 0; i < nzja; i++) {
         jblk = (int) pja2[i];
         if (_imaskblk[jblk] != _icycle) {
            _imaskblk[jblk] = _icycle;
            nlistblk++;
            listblk.push_back (jblk);
         }
      }

      int *plistblk = NULL;
      if (nlistblk > 0)
         plistblk = &listblk[0];

      sort (plistblk, plistblk + nlistblk);

      int *pindlistblk = _imaskblk + _nblks;

      for (i = 0; i < nlistblk; i++) {
         jblk = (int) plistblk[i];
         pindlistblk[jblk] = i;
      }

// Split block row into blocks

      int *pnzblk = _imaskblk + 2 * _nblks;

      for (i = 0; i < nlistblk; i++) {
         jblk = plistblk[i];
         pnzblk[jblk] = 0;
      }

      for (i = 0; i < nzja; i++) {
         jblk = (int) pja2[i];
         pnzblk[jblk]++;
      }

      pnzblk[_iblk] += _nlist;

      vector < int >imask_dia (_nlist + 1);
      int *pimask_dia = &imask_dia[0];

      for (i = 0; i < _nlist; i++)
         pimask_dia[i] = -1;

      vector < vector < _Int > >irowarr_blk (nlistblk + 1);
      vector < vector < _Int > >icolarr_blk (nlistblk + 1);
      vector < vector < _Flt > >valarr_blk (nlistblk + 1);

      vector < _Int > *pirowarr_blk = &irowarr_blk[0];
      vector < _Int > *picolarr_blk = &icolarr_blk[0];
      vector < _Flt > *pvalarr_blk = &valarr_blk[0];

      for (i = 0; i < nlistblk; i++) {
         jblk = (int) plistblk[i];
         pirowarr_blk[i].resize (pnzblk[jblk] + 1);
         picolarr_blk[i].resize (pnzblk[jblk] + 1);
         pvalarr_blk[i].resize (b_2 * (pnzblk[jblk] + 1));
      }

      for (i = 0; i < nlistblk; i++) {
         jblk = plistblk[i];
         pnzblk[jblk] = 0;
      }

      _Int *ppirowarr_blk;
      _Int *ppicolarr_blk;
      _Flt *ppvalarr_blk;

      int ind, k;

      for (i = 0; i < _nlist; i++) {
         for (j = (int) _ia[i]; j < _ia[i + 1]; j++) {
            jj = (int) pjasort[j];
            jblk = (int) pja2[j];
            jj -= (int) _blks[jblk];
            ind = (int) pindlistblk[jblk];
            ppirowarr_blk = &(pirowarr_blk[ind][0]);
            ppicolarr_blk = &(picolarr_blk[ind][0]);
            ppvalarr_blk = &(pvalarr_blk[ind][0]);
            k = (int) pnzblk[jblk];
            ppirowarr_blk[k] = (_Int) (_list[i] - _blks[_iblk]);
            ppicolarr_blk[k] = (_Int) jj;
            CVector < _Flt >::CopyVector (b_2, pasort + j * b_2, ppvalarr_blk + k * b_2);
            pnzblk[jblk]++;
            if (jblk == _iblk) {
               if (i == jj) {
                  pimask_dia[i] = 1;
               }
            }
         }
      }

      jasort.resize (0);
      asort.resize (0);

// Add zero diagonal elems

      int nz_add_dia = 0;

      _Flt fzero = (_Flt) 0.0e0;

      for (i = 0; i < nlistblk; i++) {
         jblk = (int) plistblk[i];
         if (jblk == _iblk) {
            ind = (int) pindlistblk[jblk];
            ppirowarr_blk = &(pirowarr_blk[ind][0]);
            ppicolarr_blk = &(picolarr_blk[ind][0]);
            ppvalarr_blk = &(pvalarr_blk[ind][0]);
            for (j = 0; j < _nlist; j++) {
               if (pimask_dia[j] < 0) {
                  k = (int) pnzblk[jblk];
                  ppirowarr_blk[k] = (_Int) j;
                  ppicolarr_blk[k] = (_Int) j;
                  CVector < _Flt >::SetByZeroes (b_2, ppvalarr_blk + k * b_2);
                  pnzblk[jblk]++;
                  nz_add_dia++;
               }
            }
         }
      }

// Store block sparsity matrix

      this->nzblk = nlistblk;

      int ia_1blk[2];

      ia_1blk[0] = 0;
      ia_1blk[1] = nlistblk;

      CMatrix < int, float >hmatr_str_temp (1, &_iblk, ia_1blk, plistblk);

      this->hmatr_str.ReplaceFree (hmatr_str_temp);

// For each block compute the list of rows and ia arrays

      int nimax = 0;

      int ni;

      for (i = 0; i < nlistblk; i++) {
         jblk = plistblk[i];
         ni = (int) (_blks[jblk + 1] - _blks[jblk]);
         if (ni > nimax)
            nimax = ni;
      }

      vector < int >imask (nimax + 1);
      vector < int >list (nimax + 1);
      vector < int >indlist (nimax + 1);
      vector < int >iptr (nimax + 1);
      vector < CSortInt > iiarr2 (nimax + 1);
      vector < _Int > jasort2 (nimax + 1);
      vector < _Flt > asort2 (nimax * b_2 + 1);

      int *pimask = &imask[0];
      int *plist = &list[0];
      int *pindlist = &indlist[0];
      int *piptr = &iptr[0];
      CSortInt *piiarr2 = &iiarr2[0];
      _Int *pjasort2 = &jasort2[0];
      _Flt *pasort2 = &asort2[0];

      int icycle = -1;

      for (i = 0; i < nimax; i++)
         pimask[i] = -1;

      vector < int >nlistarr_blk (nlistblk + 1);
      vector < vector < _Int > >listarr_blk (nlistblk + 1);
      vector < vector < _Int > >iaarr_blk (nlistblk + 1);
      vector < vector < _Int > >jaarr_blk (nlistblk + 1);
      vector < vector < _Flt > >aarr_blk (nlistblk + 1);

      int *pnlistarr_blk = &nlistarr_blk[0];
      vector < _Int > *plistarr_blk = &listarr_blk[0];
      vector < _Int > *piaarr_blk = &iaarr_blk[0];
      vector < _Int > *pjaarr_blk = &jaarr_blk[0];
      vector < _Flt > *paarr_blk = &aarr_blk[0];

      for (i = 0; i < nlistblk; i++)
         pnlistarr_blk[i] = 0;

      int nlistloc;
      _Int *pplistarr_blk;
      _Int *ppiaarr_blk;
      _Int *ppjaarr_blk;
      _Flt *ppaarr_blk;

      int i1;

      for (i = 0; i < nlistblk; i++) {
         jblk = plistblk[i];
         icycle++;
         ppirowarr_blk = &(pirowarr_blk[i][0]);
         ppicolarr_blk = &(picolarr_blk[i][0]);
         ppvalarr_blk = &(pvalarr_blk[i][0]);
         nlistloc = 0;
         for (j = 0; j < pnzblk[jblk]; j++) {
            jj = ppirowarr_blk[j];
            if (pimask[jj] != icycle) {
               plist[nlistloc] = (int) jj;
               nlistloc++;
               pimask[jj] = icycle;
            }
         }
         pnlistarr_blk[i] = nlistloc;
         sort (plist, plist + nlistloc);
         for (j = 0; j < nlistloc; j++) {
            jj = plist[j];
            pindlist[jj] = j;
         }
         plistarr_blk[i].resize (nlistloc + 1);
         piaarr_blk[i].resize (nlistloc + 1);
         pjaarr_blk[i].resize (pnzblk[jblk] + 1);
         paarr_blk[i].resize (pnzblk[jblk] * b_2 + 1);
         pplistarr_blk = &(plistarr_blk[i][0]);
         ppiaarr_blk = &(piaarr_blk[i][0]);
         ppjaarr_blk = &(pjaarr_blk[i][0]);
         ppaarr_blk = &(paarr_blk[i][0]);
         for (j = 0; j < nlistloc; j++)
            pplistarr_blk[j] = plist[j];
         for (j = 0; j <= nlistloc; j++)
            ppiaarr_blk[j] = 0;
         for (j = 0; j < pnzblk[jblk]; j++) {
            jj = ppirowarr_blk[j];
            ind = pindlist[jj];
            ppiaarr_blk[ind + 1]++;
         }
         for (j = 0; j < nlistloc; j++)
            ppiaarr_blk[j + 1] = ppiaarr_blk[j] + ppiaarr_blk[j + 1];
         for (j = 0; j < nlistloc; j++)
            piptr[j] = (int) ppiaarr_blk[j];
         for (j = 0; j < pnzblk[jblk]; j++) {
            jj = ppirowarr_blk[j];
            ind = pindlist[jj];
            k = piptr[ind];
            ppjaarr_blk[k] = ppicolarr_blk[j];
            CVector < _Flt >::CopyVector (b_2, ppvalarr_blk + j * b_2,
                                          ppaarr_blk + k * b_2);
            piptr[ind]++;
         }
         for (i1 = 0; i1 < nlistloc; i1++) {
            nirowloc = (int) (ppiaarr_blk[i1 + 1] - ppiaarr_blk[i1]);
            ibeg = (int) ppiaarr_blk[i1];
            for (j = 0; j < nirowloc; j++) {
               piiarr2[j].ival = (int) ppjaarr_blk[j + ibeg];
               piiarr2[j].i2val = j + ibeg;
            }
            sort (piiarr, piiarr + nirowloc);
            for (j = 0; j < nirowloc; j++) {
               pjasort2[j] = piiarr2[j].ival;
               CVector < _Flt >::CopyVector (b_2, ppaarr_blk + piiarr2[j].i2val * b_2,
                                             pasort2 + j * b_2);
            }
            for (j = 0; j < nirowloc; j++) {
               ppjaarr_blk[j + ibeg] = pjasort2[j];
               CVector < _Flt >::CopyVector (b_2, pasort2 + j * b_2,
                                             ppaarr_blk + (j + ibeg) * b_2);
            }
         }
      }

// Store results as hmatrix data

      vector < CMatrix < _Int, _Flt > >asub_arr_temp (nlistblk + 1);

      CMatrix < _Int, _Flt > *pasub_arr_temp = &asub_arr_temp[0];

      for (i = 0; i < nlistblk; i++) {
         jblk = plistblk[i];
         vector < _Int > *plist_temp = pasub_arr_temp[i].GetList ();
         vector < _Int > *pia_temp = pasub_arr_temp[i].GetIa ();
         vector < _Int > *pja_temp = pasub_arr_temp[i].GetJa ();
         vector < _Flt > *pa_temp = pasub_arr_temp[i].GetA ();
         pasub_arr_temp[i].SetNlist (pnlistarr_blk[i]);
         pasub_arr_temp[i].SetNzja (pnzblk[jblk]);
         pasub_arr_temp[i].SetNza (pnzblk[jblk]);
         plist_temp->swap (plistarr_blk[i]);
         pia_temp->swap (piaarr_blk[i]);
         pja_temp->swap (pjaarr_blk[i]);
         pa_temp->swap (paarr_blk[i]);
      }

      this->asub_arr.resize (nlistblk + 1);

      CMatrix < _Int, _Flt > *pasub_arr = &(this->asub_arr[0]);

      for (i = 0; i < nlistblk; i++)
         pasub_arr[i].ReplaceFree (pasub_arr_temp[i]);

   }

// Compute the symmetrized submatrices
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::SymmetrizeSubmatrices (void *_comm, int _nblks, long long *_blks,
                                     int *_blk2cpu, CBMatrix < _Int, _Flt > *_hmatr_arr,
                                     CBMatrix < _Int, _Flt > *_hmatr_symm_arr)
   {

      int myid = CMPIDataExchange::GetMyid (_comm);
      int nproc = CMPIDataExchange::GetNproc (_comm);

// Create cpu reg data

      int icyclecpu = -1;

      vector < int >imaskcpu (nproc);
      vector < int >listcpu (nproc);
      vector < int >indcpu (nproc);

      int *pimaskcpu = &imaskcpu[0];
      int *plistcpu = &listcpu[0];
      int *pindcpu = &indcpu[0];

      int i;

      for (i = 0; i < nproc; i++) {
         pimaskcpu[i] = icyclecpu;
      }

// For own blocks compute the list of cpus

      icyclecpu++;

      int nlistcpu = 0;

      int iblk, j, jj, jcpu;

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[iblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            for (i = 0; i < nlist_hmatr; i++) {
               for (j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
                  jj = pja_hmatr[j];
                  if (jj != iblk) {
                     jcpu = _blk2cpu[jj];
                     if (pimaskcpu[jcpu] != icyclecpu) {
                        plistcpu[nlistcpu] = jcpu;
                        nlistcpu++;
                        pimaskcpu[jcpu] = icyclecpu;
                     }
                  }
               }
            }
         }
      }

      sort (plistcpu, plistcpu + nlistcpu);

      for (i = 0; i < nlistcpu; i++) {
         jcpu = plistcpu[i];
         pindcpu[jcpu] = i;
      }

// Compute number of blocks send to each cpu (except diagonal one)

      vector < int >nzblk_cpu (nlistcpu + 1);
      int *pnzblk_cpu = &nzblk_cpu[0];

      for (i = 0; i < nlistcpu; i++)
         pnzblk_cpu[i] = 0;

      int ind;

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[iblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            for (i = 0; i < nlist_hmatr; i++) {
               for (j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
                  jj = pja_hmatr[j];
                  if (jj != iblk) {
                     jcpu = _blk2cpu[jj];
                     ind = pindcpu[jcpu];
                     pnzblk_cpu[ind]++;
                  }
               }
            }
         }
      }

// Prepare send hblock data

      vector < CBMatrix < _Int, _Flt > >hblk_send (nlistcpu + 1);

      CBMatrix < _Int, _Flt > *phblk_send = &hblk_send[0];

      for (i = 0; i < nlistcpu; i++) {
         CMatrix < int, float >astr_temp;
         astr_temp.ResizeAndSetAllSp (0, 0, pnzblk_cpu[i], pnzblk_cpu[i]);
         CMatrix < int, float >*pHMatrStr = phblk_send[i].GetHMatrStr ();
         pHMatrStr->ReplaceFree (astr_temp);
         phblk_send[i].SetNzblk (pnzblk_cpu[i]);
         phblk_send[i].ResizeASub (pnzblk_cpu[i] + 1);
      }

      int nimax = 0;

      int niloc;

      for (i = 0; i < _nblks; i++) {
         niloc = (int) (_blks[i + 1] - _blks[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

      vector < int >imaskblk (nimax + 1);
      vector < int >listblk (nimax + 1);
      vector < int >indblk (nimax + 1);
      vector < int >iablk (nimax + 1);
      vector < int >iptrblk (nimax + 1);

      int *pimaskblk = &imaskblk[0];
      int *plistblk = &listblk[0];
      int *pindblk = &indblk[0];
      int *piablk = &iablk[0];
      int *piptrblk = &iptrblk[0];

      int icycleblk = -1;

      for (i = 0; i < nimax; i++)
         pimaskblk[i] = icycleblk;

      for (i = 0; i < nlistcpu; i++)
         pnzblk_cpu[i] = 0;

      int k;

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[iblk].GetASubArr ();
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[iblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            for (i = 0; i < nlist_hmatr; i++) {
               for (j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
                  jj = pja_hmatr[j];
                  if (jj != iblk) {
                     jcpu = _blk2cpu[jj];
                     ind = pindcpu[jcpu];
                     k = pnzblk_cpu[ind];
                     CMatrix < _Int, _Flt > *pA_cpu = phblk_send[ind].GetASubArr ();
                     CMatrix < int, float >*pHMatr_cpu = phblk_send[ind].GetHMatrStr ();
                     int *pja_cpu = pHMatr_cpu->GetJaArr ();
                     int *pja2_cpu = pHMatr_cpu->GetJa2Arr ();
                     pja_cpu[k] = jj;
                     pja2_cpu[k] = iblk;
                     CMatrix < _Int, _Flt > a_sp;
                     a_sp.GetSparsity (pA_sub[j]);
                     a_sp.TransposedSparsityListSp (icycleblk, pimaskblk, pindblk,
                                                    piptrblk, plistblk, piablk,
                                                    pA_cpu[k]);
                     pnzblk_cpu[ind]++;
                  }
               }
            }
         }
      }

// Pack send data

      vector < int >CpuIDSend (nlistcpu);
      vector < vector < char > >ObjSend (nlistcpu);

      int *pCpuIDSend = NULL;
      vector < char >*pObjSend = NULL;

      if (nlistcpu > 0) {
         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];
      }

      long long isize;
      char *pobj;

      for (i = 0; i < nlistcpu; i++) {
         pCpuIDSend[i] = plistcpu[i];
         isize = phblk_send[i].GetPackedSize ();
         pObjSend[i].resize ((size_t) isize);
         pobj = &(pObjSend[i][0]);
         phblk_send[i].FillPacked (isize, pobj);
         phblk_send[i].Clean ();
      }

// Exchange

      vector < int >CpuIDRecv;
      vector < vector < char > >ObjRecv;

      CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      int nrecv = (int) CpuIDRecv.size ();

      vector < char >*pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      vector < CBMatrix < _Int, _Flt > >hblk_recv (nrecv + 1);

      CBMatrix < _Int, _Flt > *phblk_recv = &hblk_recv[0];

      for (i = 0; i < nrecv; i++) {
         isize = (long long) pObjRecv[i].size ();
         pobj = &(pObjRecv[i][0]);
         phblk_recv[i].UnPack (isize, pobj);
      }

// Free recv data

      {
         vector < int >CpuIDRecv_temp;
         vector < vector < char > >ObjRecv_temp;
         CpuIDRecv.swap (CpuIDRecv_temp);
         ObjRecv.swap (ObjRecv_temp);
      }

// Store received block sparsity for each own block row

      vector < int >iablk_recv (_nblks + 1);
      int *piablk_recv = &iablk_recv[0];

      for (i = 0; i <= _nblks; i++)
         piablk_recv[i] = 0;

      for (i = 0; i < nrecv; i++) {
         CMatrix < int, float >*pHMatr_sub = phblk_recv[i].GetHMatrStr ();
         int nzja_hmatr = pHMatr_sub->GetNzja ();
         int *pja_hmatr = pHMatr_sub->GetJaArr ();
         for (j = 0; j < nzja_hmatr; j++) {
            iblk = pja_hmatr[j];
            piablk_recv[iblk + 1]++;
         }
      }

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            piablk_recv[iblk + 1]++;
         }
      }

      for (i = 0; i < _nblks; i++)
         piablk_recv[i + 1] = piablk_recv[i] + piablk_recv[i + 1];

      int nzblk_recv = piablk_recv[_nblks];

      vector < int >iptr_recv (_nblks);
      vector < int >jablk_recv (nzblk_recv + 1);
      vector < CMatrix < _Int, _Flt > >ablk_recv (nzblk_recv + 1);

      int *piptr_recv = &iptr_recv[0];
      int *pjablk_recv = &jablk_recv[0];
      CMatrix < _Int, _Flt > *pablk_recv = &ablk_recv[0];

      for (i = 0; i < _nblks; i++)
         piptr_recv[i] = piablk_recv[i];

      int jblk;

      for (i = 0; i < nrecv; i++) {
         CMatrix < _Int, _Flt > *pA_sub = phblk_recv[i].GetASubArr ();
         CMatrix < int, float >*pHMatr_sub = phblk_recv[i].GetHMatrStr ();
         int nzja_hmatr = pHMatr_sub->GetNzja ();
         int *pja_hmatr = pHMatr_sub->GetJaArr ();
         int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
         for (j = 0; j < nzja_hmatr; j++) {
            iblk = pja_hmatr[j];
            jblk = pja2_hmatr[j];
            k = piptr_recv[iblk];
            pjablk_recv[k] = jblk;
            pablk_recv[k].ReplaceFree (pA_sub[j]);
            piptr_recv[iblk]++;
         }
      }

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            k = piptr_recv[iblk];
            pjablk_recv[k] = iblk;
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[iblk].GetASubArr ();
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[iblk].GetHMatrStr ();
            int nzja_hmatr = pHMatr_sub->GetNzja ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            ind = -1;
            for (j = 0; j < nzja_hmatr; j++) {
               jblk = pja_hmatr[j];
               if (jblk == iblk)
                  ind = j;
            }
            if (ind < 0) {
               throw
                  " CBMatrix<>::SymmetrizeSubmatrices: error: incorrect block sparsity ";
            }
            CMatrix < _Int, _Flt > a_sp;
            a_sp.GetSparsity (pA_sub[ind]);
            a_sp.TransposedSparsityListSp (icycleblk, pimaskblk, pindblk, piptrblk,
                                           plistblk, piablk, pablk_recv[k]);
            piptr_recv[iblk]++;
         }
      }

// Free received hblock data

      for (i = 0; i < nrecv; i++) {
         phblk_recv[i].Clean ();
      }

// Compute symmetrized blocks

      vector < CSortInt > iiarr (_nblks);
      CSortInt *piiarr = &iiarr[0];

      int nlist_t, ibeg, nlist_new, ip, ip_t, jj_t;

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            nlist_t = piablk_recv[iblk + 1] - piablk_recv[iblk];
            ibeg = piablk_recv[iblk];
            for (j = 0; j < nlist_t; j++) {
               piiarr[j].ival = pjablk_recv[j + ibeg];
               piiarr[j].i2val = j + ibeg;
            }
            sort (piiarr, piiarr + nlist_t);
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[iblk].GetASubArr ();
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[iblk].GetHMatrStr ();
            int nzja_hmatr = pHMatr_sub->GetNzja ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            nlist_new = 0;
            ip = 0;
            ip_t = 0;
            while (ip < nzja_hmatr || ip_t < nlist_t) {
               if (ip < nzja_hmatr && ip_t < nlist_t) {
                  jj = pja_hmatr[ip];
                  jj_t = piiarr[ip_t].ival;
                  if (jj == jj_t) {
                     nlist_new++;
                     ip++;
                     ip_t++;
                  } else if (jj < jj_t) {
                     nlist_new++;
                     ip++;
                  } else {
                     nlist_new++;
                     ip_t++;
                  }
               } else if (ip < nzja_hmatr) {
                  nlist_new++;
                  ip++;
               } else {
                  nlist_new++;
                  ip_t++;
               }
            }
            _hmatr_symm_arr[iblk].ResizeASub (nlist_new + 1);
            _hmatr_symm_arr[iblk].SetNzblk (nlist_new);
            CMatrix < _Int, _Flt > *pASymm_sub = _hmatr_symm_arr[iblk].GetASubArr ();
            CMatrix < int, float >*pHMatrSymm_sub = _hmatr_symm_arr[iblk].GetHMatrStr ();
            pHMatrSymm_sub->ResizeAndSetAllSp (1, 0, nlist_new, 0);
            int *plist_hmatrsymm = pHMatrSymm_sub->GetListArr ();
            int *pia_hmatrsymm = pHMatrSymm_sub->GetIaArr ();
            int *pja_hmatrsymm = pHMatrSymm_sub->GetJaArr ();
            plist_hmatrsymm[0] = iblk;
            pia_hmatrsymm[0] = 0;
            pia_hmatrsymm[1] = nlist_new;
            nlist_new = 0;
            ip = 0;
            ip_t = 0;
            while (ip < nzja_hmatr || ip_t < nlist_t) {
               if (ip < nzja_hmatr && ip_t < nlist_t) {
                  jj = pja_hmatr[ip];
                  jj_t = piiarr[ip_t].ival;
                  if (jj == jj_t) {
                     pja_hmatrsymm[nlist_new] = jj;
                     ind = piiarr[ip_t].i2val;
                     pA_sub[ip].ExtendSparsity (pablk_recv[ind], pASymm_sub[nlist_new]);
                     nlist_new++;
                     ip++;
                     ip_t++;
                  } else if (jj < jj_t) {
                     pja_hmatrsymm[nlist_new] = jj;
                     pASymm_sub[nlist_new] = pA_sub[ip];
                     nlist_new++;
                     ip++;
                  } else {
                     pja_hmatrsymm[nlist_new] = jj_t;
                     ind = piiarr[ip_t].i2val;
                     CMatrix < _Int, _Flt > atemp;
                     atemp.ExtendSparsity (pablk_recv[ind], pASymm_sub[nlist_new]);
                     nlist_new++;
                     ip_t++;
                  }
               } else if (ip < nzja_hmatr) {
                  pja_hmatrsymm[nlist_new] = pja_hmatr[ip];
                  pASymm_sub[nlist_new] = pA_sub[ip];
                  nlist_new++;
                  ip++;
               } else {
                  pja_hmatrsymm[nlist_new] = piiarr[ip_t].ival;
                  ind = piiarr[ip_t].i2val;
                  CMatrix < _Int, _Flt > atemp;
                  atemp.ExtendSparsity (pablk_recv[ind], pASymm_sub[nlist_new]);
                  nlist_new++;
                  ip_t++;
               }
            }
         }
      }

   }

// Compute the symmetrized submatrices
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::SymmetrizeSubmatrices (void *_comm, int _nhblks, int *_hblk2cpu,
                                     int *_hblk2blks, int *_blk2hblks, long long *_blks,
                                     CBMatrix < _Int, _Flt > *_hmatr_arr, CBMatrix < _Int,
                                     _Flt > *_hmatr_symm_arr)
   {

      int myid = 0;
      int nproc = 1;

      if (_comm != NULL) {
         myid = CMPIDataExchange::GetMyid (_comm);
         nproc = CMPIDataExchange::GetNproc (_comm);
      }
// Create cpu reg data

      int icyclecpu = -1;

      vector < int >imaskcpu (nproc);
      vector < int >listcpu (nproc);
      vector < int >indcpu (nproc);

      int *pimaskcpu = &imaskcpu[0];
      int *plistcpu = &listcpu[0];
      int *pindcpu = &indcpu[0];

      int i;

      for (i = 0; i < nproc; i++) {
         pimaskcpu[i] = icyclecpu;
      }

// For own blocks compute the list of cpus

      icyclecpu++;

      int nlistcpu = 0;

      int ihblk;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
            for (i = 0; i < nlist_hmatr; i++) {
               for (int j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
                  int jj2 = pja2_hmatr[j];
                  if (jj2 != ihblk) {
                     int jcpu = _hblk2cpu[jj2];
                     if (pimaskcpu[jcpu] != icyclecpu) {
                        plistcpu[nlistcpu] = jcpu;
                        nlistcpu++;
                        pimaskcpu[jcpu] = icyclecpu;
                     }
                  }
               }
            }
         }
      }

      sort (plistcpu, plistcpu + nlistcpu);

      for (i = 0; i < nlistcpu; i++) {
         int jcpu = plistcpu[i];
         pindcpu[jcpu] = i;
      }

// Compute number of blocks send to each cpu (except diagonal one)

      vector < int >nzblk_cpu (nlistcpu + 1);
      int *pnzblk_cpu = &nzblk_cpu[0];

      for (i = 0; i < nlistcpu; i++)
         pnzblk_cpu[i] = 0;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
            for (i = 0; i < nlist_hmatr; i++) {
               for (int j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
                  int jj2 = pja2_hmatr[j];
                  if (jj2 != ihblk) {
                     int jcpu = _hblk2cpu[jj2];
                     int ind = pindcpu[jcpu];
                     pnzblk_cpu[ind]++;
                  }
               }
            }
         }
      }

// Prepare send hblock data

      vector < CBMatrix < _Int, _Flt > >hblk_send (nlistcpu + 1);

      CBMatrix < _Int, _Flt > *phblk_send = &hblk_send[0];

      for (i = 0; i < nlistcpu; i++) {
         CMatrix < int, float >astr_temp;
         astr_temp.ResizeAndSetAllSp (0, 0, 2 * pnzblk_cpu[i], 2 * pnzblk_cpu[i]);
         CMatrix < int, float >*pHMatrStr = phblk_send[i].GetHMatrStr ();
         pHMatrStr->ReplaceFree (astr_temp);
         phblk_send[i].SetNzblk (pnzblk_cpu[i]);
         phblk_send[i].ResizeASub (pnzblk_cpu[i]);
      }

      int nimax = 0;

      int nblks = _hblk2blks[_nhblks];

      for (i = 0; i < nblks; i++) {
         int niloc = (int) (_blks[i + 1] - _blks[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      vector < int >icycle_thr (n_thr + 1);
      vector < CVectorData < int > >imaskblk_thr (n_thr + 1);

      int *picycle_thr = &icycle_thr[0];
      CVectorData < int >*pimaskblk_thr = &imaskblk_thr[0];

      for (i = 0; i < n_thr; i++)
         picycle_thr[i] = -1;

      int nztot = 0;

      for (i = 0; i < nlistcpu; i++) {
         nztot += pnzblk_cpu[i];
      }

      CVectorData < CMatrix < _Int, _Flt > *>ptr_pairs (nztot * 2);

      CMatrix < _Int, _Flt > **pptr_pairs = ptr_pairs.Ptr ();

      for (i = 0; i < nlistcpu; i++)
         pnzblk_cpu[i] = 0;

      nztot = 0;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[ihblk].GetASubArr ();
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
            for (int ipar = 0; ipar < nlist_hmatr; ipar++) {
               for (int j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
                  int jj = pja_hmatr[j];
                  int jj2 = pja2_hmatr[j];
                  if (jj2 != ihblk) {
                     int jcpu = _hblk2cpu[jj2];
                     int ind = pindcpu[jcpu];
                     int k = pnzblk_cpu[ind];
                     CMatrix < _Int, _Flt > *pA_cpu = phblk_send[ind].GetASubArr ();
                     CMatrix < int, float >*pHMatr_cpu = phblk_send[ind].GetHMatrStr ();
                     int *pja_cpu = pHMatr_cpu->GetJaArr ();
                     int *pja2_cpu = pHMatr_cpu->GetJa2Arr ();
                     pja_cpu[k * 2] = jj;
                     pja_cpu[k * 2 + 1] = jj2;
                     pja2_cpu[k * 2] = ipar;
                     pja2_cpu[k * 2 + 1] = ihblk;
                     pptr_pairs[nztot * 2] = pA_sub + j;
                     pptr_pairs[nztot * 2 + 1] = pA_cpu + k;
                     nztot++;
                     pnzblk_cpu[ind]++;
                  }
               }
            }
         }
      }

#ifdef USE_THREADS
#pragma omp parallel for
#endif
      for (int ipar = 0; ipar < nztot; ipar++) {
         int my_thr = 0;
#ifdef USE_THREADS
         my_thr = omp_get_thread_num ();
#endif
         if (picycle_thr[my_thr] == -1) {
            pimaskblk_thr[my_thr].resize (5 * nimax + 1);
            int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
            for (int j = 0; j < nimax; j++)
               pimaskblk[j] = -1;
         }
         int icycleblk = picycle_thr[my_thr];
         int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
         icycleblk++;
         CMatrix < _Int, _Flt > a_sp;
         a_sp.GetSparsity (*pptr_pairs[2 * ipar]);
         a_sp.TransposedSparsityListSp (icycleblk, pimaskblk, pimaskblk + nimax,
                                        pimaskblk + 2 * nimax, pimaskblk + 3 * nimax,
                                        pimaskblk + 4 * nimax, *pptr_pairs[2 * ipar + 1]);
         picycle_thr[my_thr] = icycleblk;
      }

// Pack send data

      vector < int >CpuIDSend (nlistcpu);
      vector < vector < char > >ObjSend (nlistcpu);

      int *pCpuIDSend = NULL;
      vector < char >*pObjSend = NULL;

      if (nlistcpu > 0) {
         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];
      }

      long long isize;
      char *pobj;

      for (i = 0; i < nlistcpu; i++) {
         pCpuIDSend[i] = plistcpu[i];
         isize = phblk_send[i].GetPackedSize ();
         pObjSend[i].resize ((size_t) isize);
         pobj = &(pObjSend[i][0]);
         phblk_send[i].FillPacked_thr (isize, pobj);
         phblk_send[i].Clean ();
      }

// Exchange

      vector < int >CpuIDRecv;
      vector < vector < char > >ObjRecv;

      if (_comm != NULL) {
         CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);
      } else {
         CpuIDRecv.swap (CpuIDSend);
         ObjRecv.swap (ObjSend);
      }

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      int nrecv = (int) CpuIDRecv.size ();

      vector < char >*pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      vector < CBMatrix < _Int, _Flt > >hblk_recv (nrecv + 1);

      CBMatrix < _Int, _Flt > *phblk_recv = &hblk_recv[0];

      for (i = 0; i < nrecv; i++) {
         isize = (long long) pObjRecv[i].size ();
         pobj = &(pObjRecv[i][0]);
         phblk_recv[i].UnPack_thr (isize, pobj);
      }

// Free recv data

      {
         vector < int >CpuIDRecv_temp;
         vector < vector < char > >ObjRecv_temp;
         CpuIDRecv.swap (CpuIDRecv_temp);
         ObjRecv.swap (ObjRecv_temp);
      }

// Store received block sparsity for each own block row

      vector < int >iablk_recv (nblks + 1);
      int *piablk_recv = &iablk_recv[0];

      for (i = 0; i <= nblks; i++)
         piablk_recv[i] = 0;

      for (i = 0; i < nrecv; i++) {
         CMatrix < int, float >*pHMatr_sub = phblk_recv[i].GetHMatrStr ();
         int nzja_temp = pHMatr_sub->GetNzja () / 2;
         int *pja_temp = pHMatr_sub->GetJaArr ();
         for (int j = 0; j < nzja_temp; j++) {
            int iblk = pja_temp[j * 2];
            int ihblk = pja_temp[j * 2 + 1];
            int iblkgl = _hblk2blks[ihblk] + iblk;
            piablk_recv[iblkgl + 1]++;
         }
      }

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
            for (i = 0; i < nlist_hmatr; i++) {
               for (int j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
                  int jj = pja_hmatr[j];
                  int jj2 = pja2_hmatr[j];
                  if (jj2 == ihblk) {
                     int jblkgl = _hblk2blks[jj2] + jj;
                     piablk_recv[jblkgl + 1]++;
                  }
               }
            }
         }
      }

      for (i = 0; i < nblks; i++)
         piablk_recv[i + 1] = piablk_recv[i] + piablk_recv[i + 1];

      int nzblk_recv = piablk_recv[nblks];

      vector < int >iptr_recv (nblks);
      vector < int >jablk_recv (nzblk_recv + 1);
      vector < int >ja2blk_recv (nzblk_recv + 1);
      vector < CMatrix < _Int, _Flt > >ablk_recv (nzblk_recv + 1);

      int *piptr_recv = &iptr_recv[0];
      int *pjablk_recv = &jablk_recv[0];
      int *pja2blk_recv = &ja2blk_recv[0];
      CMatrix < _Int, _Flt > *pablk_recv = &ablk_recv[0];

      for (i = 0; i < nblks; i++)
         piptr_recv[i] = piablk_recv[i];

      int jblk, jhblk;

      for (i = 0; i < nrecv; i++) {
         CMatrix < _Int, _Flt > *pA_sub = phblk_recv[i].GetASubArr ();
         CMatrix < int, float >*pHMatr_sub = phblk_recv[i].GetHMatrStr ();
         int nzja_temp = pHMatr_sub->GetNzja () / 2;
         int *pja_temp = pHMatr_sub->GetJaArr ();
         int *pja2_temp = pHMatr_sub->GetJa2Arr ();
         for (int j = 0; j < nzja_temp; j++) {
            int iblk = pja_temp[j * 2];
            int ihblk = pja_temp[j * 2 + 1];
            int iblkgl = _hblk2blks[ihblk] + iblk;
            int jblk = pja2_temp[j * 2];
            int jhblk = pja2_temp[j * 2 + 1];
            int k = piptr_recv[iblkgl];
            pjablk_recv[k] = jblk;
            pja2blk_recv[k] = jhblk;
            pablk_recv[k].ReplaceFree (pA_sub[j]);
            piptr_recv[iblkgl]++;
         }
      }

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[ihblk].GetASubArr ();
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int nzja_hmatr = pHMatr_sub->GetNzja ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
            vector < int >ind2t (2 * nzja_hmatr + 1);
            int *pind2t = &ind2t[0];
            int nzja_hmatr_dia = 0;
            for (i = 0; i < nlist_hmatr; i++) {
               for (int j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
                  int jj = pja_hmatr[j];
                  int jj2 = pja2_hmatr[j];
                  int jblkgl = _hblk2blks[jj2] + jj;
                  if (jj2 == ihblk) {
                     int k = piptr_recv[jblkgl];
                     pjablk_recv[k] = i;
                     pja2blk_recv[k] = ihblk;
                     pind2t[nzja_hmatr_dia * 2] = j;
                     pind2t[nzja_hmatr_dia * 2 + 1] = k;
                     nzja_hmatr_dia++;
                     piptr_recv[jblkgl]++;
                  }
               }
            }
#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nzja_hmatr_dia; ipar++) {

               int my_thr = 0;
#ifdef USE_THREADS
               my_thr = omp_get_thread_num ();
#endif

               if (picycle_thr[my_thr] == -1) {
                  pimaskblk_thr[my_thr].resize (5 * nimax + 1);
                  int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
                  for (int j = 0; j < nimax; j++)
                     pimaskblk[j] = -1;
               }
               int icycleblk = picycle_thr[my_thr];
               int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
               icycleblk++;
               CMatrix < _Int, _Flt > a_sp;
               int ind = pind2t[ipar * 2];
               a_sp.GetSparsity (pA_sub[ind]);
               int k = pind2t[ipar * 2 + 1];
               a_sp.TransposedSparsityListSp (icycleblk, pimaskblk, pimaskblk + nimax,
                                              pimaskblk + 2 * nimax,
                                              pimaskblk + 3 * nimax,
                                              pimaskblk + 4 * nimax, pablk_recv[k]);
               picycle_thr[my_thr] = icycleblk;
            }
         }
      }

// Free received hblock data

      for (i = 0; i < nrecv; i++) {
         phblk_recv[i].Clean ();
      }

// Compute symmetrized blocks

      vector < CSortInt > iiarr (nblks + 1);
      CSortInt *piiarr = &iiarr[0];

      int iblkbeg, iblkend, niblk, nlist_t, ibeg, ipbeg, ipend, ip, ip_t, jj_t;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            iblkbeg = _hblk2blks[ihblk];
            iblkend = _hblk2blks[ihblk + 1] - 1;
            niblk = iblkend + 1 - iblkbeg;
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[ihblk].GetASubArr ();
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
            int nzja_hmatr = pHMatr_sub->GetNzja ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
            int nzja_new = nzja_hmatr + piablk_recv[iblkend + 1] - piablk_recv[iblkbeg];
            vector < int >ia_new (niblk + 1);
            vector < int >ja_new (nzja_new + 1);
            vector < int >ja2_new (nzja_new + 1);
            vector < int >ind_new (2 * nzja_new + 1);
            int *pia_new = &ia_new[0];
            int *pja_new = &ja_new[0];
            int *pja2_new = &ja2_new[0];
            int *pind_new = &ind_new[0];
            pia_new[0] = 0;
            nzja_new = 0;
            for (int iblk = iblkbeg; iblk <= iblkend; iblk++) {
               nlist_t = piablk_recv[iblk + 1] - piablk_recv[iblk];
               ibeg = piablk_recv[iblk];
               nlist_t = piablk_recv[iblk + 1] - piablk_recv[iblk];
               for (int j = 0; j < nlist_t; j++) {
                  jblk = pjablk_recv[j + ibeg];
                  jhblk = pja2blk_recv[j + ibeg];
                  int jblkgl = _hblk2blks[jhblk] + jblk;
                  piiarr[j].ival = jblkgl;
                  piiarr[j].i2val = j + ibeg;
               }
               sort (piiarr, piiarr + nlist_t);
               ipbeg = pia_hmatr[iblk - iblkbeg];
               ipend = pia_hmatr[iblk + 1 - iblkbeg] - 1;
               ip = ipbeg;
               ip_t = 0;
               while (ip <= ipend || ip_t < nlist_t) {
                  if (ip <= ipend && ip_t < nlist_t) {
                     int jj = pja_hmatr[ip];
                     int jj2 = pja2_hmatr[ip];
                     int jblkgl = _hblk2blks[jj2] + jj;
                     jj_t = piiarr[ip_t].ival;
                     if (jblkgl == jj_t) {
                        pja_new[nzja_new] = jj;
                        pja2_new[nzja_new] = jj2;
                        pind_new[nzja_new * 2] = ip;
                        int k = piiarr[ip_t].i2val;
                        pind_new[nzja_new * 2 + 1] = k;
                        nzja_new++;
                        ip++;
                        ip_t++;
                     } else if (jblkgl < jj_t) {
                        pja_new[nzja_new] = jj;
                        pja2_new[nzja_new] = jj2;
                        pind_new[nzja_new * 2] = ip;
                        pind_new[nzja_new * 2 + 1] = -1;
                        nzja_new++;
                        ip++;
                     } else {
                        int k = piiarr[ip_t].i2val;
                        pja_new[nzja_new] = pjablk_recv[k];
                        pja2_new[nzja_new] = pja2blk_recv[k];
                        pind_new[nzja_new * 2] = -1;
                        pind_new[nzja_new * 2 + 1] = k;
                        nzja_new++;
                        ip_t++;
                     }
                  } else if (ip <= ipend) {
                     pja_new[nzja_new] = pja_hmatr[ip];
                     pja2_new[nzja_new] = pja2_hmatr[ip];
                     pind_new[nzja_new * 2] = ip;
                     pind_new[nzja_new * 2 + 1] = -1;
                     nzja_new++;
                     ip++;
                  } else {
                     int k = piiarr[ip_t].i2val;
                     pja_new[nzja_new] = pjablk_recv[k];
                     pja2_new[nzja_new] = pja2blk_recv[k];
                     pind_new[nzja_new * 2] = -1;
                     pind_new[nzja_new * 2 + 1] = k;
                     nzja_new++;
                     ip_t++;
                  }
               }
               pia_new[iblk + 1 - iblkbeg] = nzja_new;
            }
            _hmatr_symm_arr[ihblk].ResizeASub (nzja_new + 1);
            _hmatr_symm_arr[ihblk].SetNzblk (nzja_new);
            CMatrix < _Int, _Flt > *pASymm_sub = _hmatr_symm_arr[ihblk].GetASubArr ();
            CMatrix < int, float >*pHMatrSymm_sub = _hmatr_symm_arr[ihblk].GetHMatrStr ();
            pHMatrSymm_sub->ResizeAndSetAllSp (niblk, niblk, nzja_new, nzja_new);
            int *plist_hmatrsymm = pHMatrSymm_sub->GetListArr ();
            int *plist2_hmatrsymm = pHMatrSymm_sub->GetList2Arr ();
            int *pia_hmatrsymm = pHMatrSymm_sub->GetIaArr ();
            int *pja_hmatrsymm = pHMatrSymm_sub->GetJaArr ();
            int *pja2_hmatrsymm = pHMatrSymm_sub->GetJa2Arr ();
            for (i = 0; i < niblk; i++)
               plist_hmatrsymm[i] = i;
            for (i = 0; i < niblk; i++)
               plist2_hmatrsymm[i] = ihblk;
            for (i = 0; i <= niblk; i++)
               pia_hmatrsymm[i] = pia_new[i];
            for (i = 0; i < nzja_new; i++)
               pja_hmatrsymm[i] = pja_new[i];
            for (i = 0; i < nzja_new; i++)
               pja2_hmatrsymm[i] = pja2_new[i];
#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nzja_new; ipar++) {

#ifdef USE_THREADS
               //my_thr = omp_get_thread_num ();
#endif

               int ind1, ind2;

               ind1 = pind_new[ipar * 2];
               ind2 = pind_new[ipar * 2 + 1];
               if (ind1 >= 0 && ind2 >= 0) {
                  pA_sub[ind1].ExtendSparsity (pablk_recv[ind2], pASymm_sub[ipar]);
               } else if (ind1 >= 0) {
                  pASymm_sub[ipar] = pA_sub[ind1];
               } else {
                  CMatrix < _Int, _Flt > atemp;
                  atemp.ExtendSparsity (pablk_recv[ind2], pASymm_sub[ipar]);
               }
            }

         }
      }

   }

// Compute the symmetrized submatrices
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::SymmetrizeSubmatrices_BxB (void *_comm, int _blksize, int _nhblks,
                                         int *_hblk2cpu, int *_hblk2blks, int *_blk2hblks,
                                         long long *_blks, CBMatrix < _Int,
                                         _Flt > *_hmatr_arr, CBMatrix < _Int,
                                         _Flt > *_hmatr_symm_arr)
   {

      int myid = 0;
      int nproc = 1;

      if (_comm != NULL) {
         myid = CMPIDataExchange::GetMyid (_comm);
         nproc = CMPIDataExchange::GetNproc (_comm);
      }
// Create cpu reg data

      int icyclecpu = -1;

      vector < int >imaskcpu (nproc);
      vector < int >listcpu (nproc);
      vector < int >indcpu (nproc);

      int *pimaskcpu = &imaskcpu[0];
      int *plistcpu = &listcpu[0];
      int *pindcpu = &indcpu[0];

      int i;

      for (i = 0; i < nproc; i++) {
         pimaskcpu[i] = icyclecpu;
      }

// For own blocks compute the list of cpus

      icyclecpu++;

      int nlistcpu = 0;

      int ihblk;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
            for (i = 0; i < nlist_hmatr; i++) {
               for (int j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
                  int jj2 = pja2_hmatr[j];
                  if (jj2 != ihblk) {
                     int jcpu = _hblk2cpu[jj2];
                     if (pimaskcpu[jcpu] != icyclecpu) {
                        plistcpu[nlistcpu] = jcpu;
                        nlistcpu++;
                        pimaskcpu[jcpu] = icyclecpu;
                     }
                  }
               }
            }
         }
      }

      sort (plistcpu, plistcpu + nlistcpu);

      for (i = 0; i < nlistcpu; i++) {
         int jcpu = plistcpu[i];
         pindcpu[jcpu] = i;
      }

// Compute number of blocks send to each cpu (except diagonal one)

      vector < int >nzblk_cpu (nlistcpu + 1);
      int *pnzblk_cpu = &nzblk_cpu[0];

      for (i = 0; i < nlistcpu; i++)
         pnzblk_cpu[i] = 0;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
            for (i = 0; i < nlist_hmatr; i++) {
               for (int j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
                  int jj2 = pja2_hmatr[j];
                  if (jj2 != ihblk) {
                     int jcpu = _hblk2cpu[jj2];
                     int ind = pindcpu[jcpu];
                     pnzblk_cpu[ind]++;
                  }
               }
            }
         }
      }

// Prepare send hblock data

      vector < CBMatrix < _Int, _Flt > >hblk_send (nlistcpu + 1);

      CBMatrix < _Int, _Flt > *phblk_send = &hblk_send[0];

      for (i = 0; i < nlistcpu; i++) {
         CMatrix < int, float >astr_temp;
         astr_temp.ResizeAndSetAllSp (0, 0, 2 * pnzblk_cpu[i], 2 * pnzblk_cpu[i]);
         CMatrix < int, float >*pHMatrStr = phblk_send[i].GetHMatrStr ();
         pHMatrStr->ReplaceFree (astr_temp);
         phblk_send[i].SetNzblk (pnzblk_cpu[i]);
         phblk_send[i].ResizeASub (pnzblk_cpu[i]);
      }

      int nimax = 0;

      int nblks = _hblk2blks[_nhblks];

      for (i = 0; i < nblks; i++) {
         int niloc = (int) (_blks[i + 1] - _blks[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      vector < int >icycle_thr (n_thr + 1);
      vector < CVectorData < int > >imaskblk_thr (n_thr + 1);

      int *picycle_thr = &icycle_thr[0];
      CVectorData < int >*pimaskblk_thr = &imaskblk_thr[0];

      for (i = 0; i < n_thr; i++)
         picycle_thr[i] = -1;

      int nztot = 0;

      for (i = 0; i < nlistcpu; i++) {
         nztot += pnzblk_cpu[i];
      }

      CVectorData < CMatrix < _Int, _Flt > *>ptr_pairs (nztot * 2);

      CMatrix < _Int, _Flt > **pptr_pairs = ptr_pairs.Ptr ();

      for (i = 0; i < nlistcpu; i++)
         pnzblk_cpu[i] = 0;

      nztot = 0;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[ihblk].GetASubArr ();
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
            for (int ipar = 0; ipar < nlist_hmatr; ipar++) {
               for (int j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
                  int jj = pja_hmatr[j];
                  int jj2 = pja2_hmatr[j];
                  if (jj2 != ihblk) {
                     int jcpu = _hblk2cpu[jj2];
                     int ind = pindcpu[jcpu];
                     int k = pnzblk_cpu[ind];
                     CMatrix < _Int, _Flt > *pA_cpu = phblk_send[ind].GetASubArr ();
                     CMatrix < int, float >*pHMatr_cpu = phblk_send[ind].GetHMatrStr ();
                     int *pja_cpu = pHMatr_cpu->GetJaArr ();
                     int *pja2_cpu = pHMatr_cpu->GetJa2Arr ();
                     pja_cpu[k * 2] = jj;
                     pja_cpu[k * 2 + 1] = jj2;
                     pja2_cpu[k * 2] = ipar;
                     pja2_cpu[k * 2 + 1] = ihblk;
                     pptr_pairs[nztot * 2] = pA_sub + j;
                     pptr_pairs[nztot * 2 + 1] = pA_cpu + k;
                     nztot++;
                     pnzblk_cpu[ind]++;
                  }
               }
            }
         }
      }

#ifdef USE_THREADS
#pragma omp parallel for
#endif
      for (int ipar = 0; ipar < nztot; ipar++) {
         int my_thr = 0;
#ifdef USE_THREADS
         my_thr = omp_get_thread_num ();
#endif
         if (picycle_thr[my_thr] == -1) {
            pimaskblk_thr[my_thr].resize (5 * nimax + 1);
            int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
            for (int j = 0; j < nimax; j++)
               pimaskblk[j] = -1;
         }
         int icycleblk = picycle_thr[my_thr];
         int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
         icycleblk++;
         CMatrix < _Int, _Flt > a_sp;
         a_sp.GetSparsity (*pptr_pairs[2 * ipar]);
         a_sp.TransposedSparsityListSp (icycleblk, pimaskblk, pimaskblk + nimax,
                                        pimaskblk + 2 * nimax, pimaskblk + 3 * nimax,
                                        pimaskblk + 4 * nimax, *pptr_pairs[2 * ipar + 1]);
         picycle_thr[my_thr] = icycleblk;
      }

// Pack send data

      vector < int >CpuIDSend (nlistcpu);
      vector < vector < char > >ObjSend (nlistcpu);

      int *pCpuIDSend = NULL;
      vector < char >*pObjSend = NULL;

      if (nlistcpu > 0) {
         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];
      }

      long long isize;
      char *pobj;

      for (i = 0; i < nlistcpu; i++) {
         pCpuIDSend[i] = plistcpu[i];
         isize = phblk_send[i].GetPackedSize ();
         pObjSend[i].resize ((size_t) isize);
         pobj = &(pObjSend[i][0]);
         phblk_send[i].FillPacked_thr (isize, pobj);
         phblk_send[i].Clean ();
      }

// Exchange

      vector < int >CpuIDRecv;
      vector < vector < char > >ObjRecv;

      if (_comm != NULL) {
         CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);
      } else {
         CpuIDRecv.swap (CpuIDSend);
         ObjRecv.swap (ObjSend);
      }

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      int nrecv = (int) CpuIDRecv.size ();

      vector < char >*pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      vector < CBMatrix < _Int, _Flt > >hblk_recv (nrecv + 1);

      CBMatrix < _Int, _Flt > *phblk_recv = &hblk_recv[0];

      for (i = 0; i < nrecv; i++) {
         isize = (long long) pObjRecv[i].size ();
         pobj = &(pObjRecv[i][0]);
         phblk_recv[i].UnPack_thr (isize, pobj);
      }

// Free recv data

      {
         vector < int >CpuIDRecv_temp;
         vector < vector < char > >ObjRecv_temp;
         CpuIDRecv.swap (CpuIDRecv_temp);
         ObjRecv.swap (ObjRecv_temp);
      }

// Store received block sparsity for each own block row

      vector < int >iablk_recv (nblks + 1);
      int *piablk_recv = &iablk_recv[0];

      for (i = 0; i <= nblks; i++)
         piablk_recv[i] = 0;

      for (i = 0; i < nrecv; i++) {
         CMatrix < int, float >*pHMatr_sub = phblk_recv[i].GetHMatrStr ();
         int nzja_temp = pHMatr_sub->GetNzja () / 2;
         int *pja_temp = pHMatr_sub->GetJaArr ();
         for (int j = 0; j < nzja_temp; j++) {
            int iblk = pja_temp[j * 2];
            int ihblk = pja_temp[j * 2 + 1];
            int iblkgl = _hblk2blks[ihblk] + iblk;
            piablk_recv[iblkgl + 1]++;
         }
      }

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
            for (i = 0; i < nlist_hmatr; i++) {
               for (int j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
                  int jj = pja_hmatr[j];
                  int jj2 = pja2_hmatr[j];
                  if (jj2 == ihblk) {
                     int jblkgl = _hblk2blks[jj2] + jj;
                     piablk_recv[jblkgl + 1]++;
                  }
               }
            }
         }
      }

      for (i = 0; i < nblks; i++)
         piablk_recv[i + 1] = piablk_recv[i] + piablk_recv[i + 1];

      int nzblk_recv = piablk_recv[nblks];

      vector < int >iptr_recv (nblks);
      vector < int >jablk_recv (nzblk_recv + 1);
      vector < int >ja2blk_recv (nzblk_recv + 1);
      vector < CMatrix < _Int, _Flt > >ablk_recv (nzblk_recv + 1);

      int *piptr_recv = &iptr_recv[0];
      int *pjablk_recv = &jablk_recv[0];
      int *pja2blk_recv = &ja2blk_recv[0];
      CMatrix < _Int, _Flt > *pablk_recv = &ablk_recv[0];

      for (i = 0; i < nblks; i++)
         piptr_recv[i] = piablk_recv[i];

      int jblk, jhblk;

      for (i = 0; i < nrecv; i++) {
         CMatrix < _Int, _Flt > *pA_sub = phblk_recv[i].GetASubArr ();
         CMatrix < int, float >*pHMatr_sub = phblk_recv[i].GetHMatrStr ();
         int nzja_temp = pHMatr_sub->GetNzja () / 2;
         int *pja_temp = pHMatr_sub->GetJaArr ();
         int *pja2_temp = pHMatr_sub->GetJa2Arr ();
         for (int j = 0; j < nzja_temp; j++) {
            int iblk = pja_temp[j * 2];
            int ihblk = pja_temp[j * 2 + 1];
            int iblkgl = _hblk2blks[ihblk] + iblk;
            int jblk = pja2_temp[j * 2];
            int jhblk = pja2_temp[j * 2 + 1];
            int k = piptr_recv[iblkgl];
            pjablk_recv[k] = jblk;
            pja2blk_recv[k] = jhblk;
            pablk_recv[k].ReplaceFree (pA_sub[j]);
            piptr_recv[iblkgl]++;
         }
      }

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[ihblk].GetASubArr ();
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int nzja_hmatr = pHMatr_sub->GetNzja ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
            vector < int >ind2t (2 * nzja_hmatr + 1);
            int *pind2t = &ind2t[0];
            int nzja_hmatr_dia = 0;
            for (i = 0; i < nlist_hmatr; i++) {
               for (int j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
                  int jj = pja_hmatr[j];
                  int jj2 = pja2_hmatr[j];
                  int jblkgl = _hblk2blks[jj2] + jj;
                  if (jj2 == ihblk) {
                     int k = piptr_recv[jblkgl];
                     pjablk_recv[k] = i;
                     pja2blk_recv[k] = ihblk;
                     pind2t[nzja_hmatr_dia * 2] = j;
                     pind2t[nzja_hmatr_dia * 2 + 1] = k;
                     nzja_hmatr_dia++;
                     piptr_recv[jblkgl]++;
                  }
               }
            }
#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nzja_hmatr_dia; ipar++) {

               int my_thr = 0;
#ifdef USE_THREADS
               my_thr = omp_get_thread_num ();
#endif

               if (picycle_thr[my_thr] == -1) {
                  pimaskblk_thr[my_thr].resize (5 * nimax + 1);
                  int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
                  for (int j = 0; j < nimax; j++)
                     pimaskblk[j] = -1;
               }
               int icycleblk = picycle_thr[my_thr];
               int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
               icycleblk++;
               CMatrix < _Int, _Flt > a_sp;
               int ind = pind2t[ipar * 2];
               a_sp.GetSparsity (pA_sub[ind]);
               int k = pind2t[ipar * 2 + 1];
               a_sp.TransposedSparsityListSp (icycleblk, pimaskblk, pimaskblk + nimax,
                                              pimaskblk + 2 * nimax,
                                              pimaskblk + 3 * nimax,
                                              pimaskblk + 4 * nimax, pablk_recv[k]);
               picycle_thr[my_thr] = icycleblk;
            }
         }
      }

// Free received hblock data

      for (i = 0; i < nrecv; i++) {
         phblk_recv[i].Clean ();
      }

// Compute symmetrized blocks

      vector < CSortInt > iiarr (nblks + 1);
      CSortInt *piiarr = &iiarr[0];

      int iblkbeg, iblkend, niblk, nlist_t, ibeg, ipbeg, ipend, ip, ip_t, jj_t;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            iblkbeg = _hblk2blks[ihblk];
            iblkend = _hblk2blks[ihblk + 1] - 1;
            niblk = iblkend + 1 - iblkbeg;
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[ihblk].GetASubArr ();
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
            int nzja_hmatr = pHMatr_sub->GetNzja ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
            int nzja_new = nzja_hmatr + piablk_recv[iblkend + 1] - piablk_recv[iblkbeg];
            vector < int >ia_new (niblk + 1);
            vector < int >ja_new (nzja_new + 1);
            vector < int >ja2_new (nzja_new + 1);
            vector < int >ind_new (2 * nzja_new + 1);
            int *pia_new = &ia_new[0];
            int *pja_new = &ja_new[0];
            int *pja2_new = &ja2_new[0];
            int *pind_new = &ind_new[0];
            pia_new[0] = 0;
            nzja_new = 0;
            for (int iblk = iblkbeg; iblk <= iblkend; iblk++) {
               nlist_t = piablk_recv[iblk + 1] - piablk_recv[iblk];
               ibeg = piablk_recv[iblk];
               nlist_t = piablk_recv[iblk + 1] - piablk_recv[iblk];
               for (int j = 0; j < nlist_t; j++) {
                  jblk = pjablk_recv[j + ibeg];
                  jhblk = pja2blk_recv[j + ibeg];
                  int jblkgl = _hblk2blks[jhblk] + jblk;
                  piiarr[j].ival = jblkgl;
                  piiarr[j].i2val = j + ibeg;
               }
               sort (piiarr, piiarr + nlist_t);
               ipbeg = pia_hmatr[iblk - iblkbeg];
               ipend = pia_hmatr[iblk + 1 - iblkbeg] - 1;
               ip = ipbeg;
               ip_t = 0;
               while (ip <= ipend || ip_t < nlist_t) {
                  if (ip <= ipend && ip_t < nlist_t) {
                     int jj = pja_hmatr[ip];
                     int jj2 = pja2_hmatr[ip];
                     int jblkgl = _hblk2blks[jj2] + jj;
                     jj_t = piiarr[ip_t].ival;
                     if (jblkgl == jj_t) {
                        pja_new[nzja_new] = jj;
                        pja2_new[nzja_new] = jj2;
                        pind_new[nzja_new * 2] = ip;
                        int k = piiarr[ip_t].i2val;
                        pind_new[nzja_new * 2 + 1] = k;
                        nzja_new++;
                        ip++;
                        ip_t++;
                     } else if (jblkgl < jj_t) {
                        pja_new[nzja_new] = jj;
                        pja2_new[nzja_new] = jj2;
                        pind_new[nzja_new * 2] = ip;
                        pind_new[nzja_new * 2 + 1] = -1;
                        nzja_new++;
                        ip++;
                     } else {
                        int k = piiarr[ip_t].i2val;
                        pja_new[nzja_new] = pjablk_recv[k];
                        pja2_new[nzja_new] = pja2blk_recv[k];
                        pind_new[nzja_new * 2] = -1;
                        pind_new[nzja_new * 2 + 1] = k;
                        nzja_new++;
                        ip_t++;
                     }
                  } else if (ip <= ipend) {
                     pja_new[nzja_new] = pja_hmatr[ip];
                     pja2_new[nzja_new] = pja2_hmatr[ip];
                     pind_new[nzja_new * 2] = ip;
                     pind_new[nzja_new * 2 + 1] = -1;
                     nzja_new++;
                     ip++;
                  } else {
                     int k = piiarr[ip_t].i2val;
                     pja_new[nzja_new] = pjablk_recv[k];
                     pja2_new[nzja_new] = pja2blk_recv[k];
                     pind_new[nzja_new * 2] = -1;
                     pind_new[nzja_new * 2 + 1] = k;
                     nzja_new++;
                     ip_t++;
                  }
               }
               pia_new[iblk + 1 - iblkbeg] = nzja_new;
            }
            _hmatr_symm_arr[ihblk].ResizeASub (nzja_new + 1);
            _hmatr_symm_arr[ihblk].SetNzblk (nzja_new);
            CMatrix < _Int, _Flt > *pASymm_sub = _hmatr_symm_arr[ihblk].GetASubArr ();
            CMatrix < int, float >*pHMatrSymm_sub = _hmatr_symm_arr[ihblk].GetHMatrStr ();
            pHMatrSymm_sub->ResizeAndSetAllSp (niblk, niblk, nzja_new, nzja_new);
            int *plist_hmatrsymm = pHMatrSymm_sub->GetListArr ();
            int *plist2_hmatrsymm = pHMatrSymm_sub->GetList2Arr ();
            int *pia_hmatrsymm = pHMatrSymm_sub->GetIaArr ();
            int *pja_hmatrsymm = pHMatrSymm_sub->GetJaArr ();
            int *pja2_hmatrsymm = pHMatrSymm_sub->GetJa2Arr ();
            for (i = 0; i < niblk; i++)
               plist_hmatrsymm[i] = i;
            for (i = 0; i < niblk; i++)
               plist2_hmatrsymm[i] = ihblk;
            for (i = 0; i <= niblk; i++)
               pia_hmatrsymm[i] = pia_new[i];
            for (i = 0; i < nzja_new; i++)
               pja_hmatrsymm[i] = pja_new[i];
            for (i = 0; i < nzja_new; i++)
               pja2_hmatrsymm[i] = pja2_new[i];
#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nzja_new; ipar++) {

#ifdef USE_THREADS
               //my_thr = omp_get_thread_num ();
#endif

               int ind1, ind2;

               ind1 = pind_new[ipar * 2];
               ind2 = pind_new[ipar * 2 + 1];
               if (ind1 >= 0 && ind2 >= 0) {
                  pA_sub[ind1].ExtendSparsity_BxB (_blksize, pablk_recv[ind2],
                                                   pASymm_sub[ipar]);
               } else if (ind1 >= 0) {
                  pASymm_sub[ipar] = pA_sub[ind1];
               } else {
                  CMatrix < _Int, _Flt > atemp;
                  atemp.ExtendSparsity_BxB (_blksize, pablk_recv[ind2], pASymm_sub[ipar]);
               }
            }

         }
      }

   }

// Compute the extended lists
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ExtendedLists (void *_comm, int _ncycle, int _nblks, long long *_blks,
                             int *_blk2cpu, CBMatrix < _Int, _Flt > *_hmatr_arr,
                             int *_nlist_ext_arr, vector < int >*_list_ext_arr)
   {

      int myid = CMPIDataExchange::GetMyid (_comm);
      int nproc = CMPIDataExchange::GetNproc (_comm);

// Compute the maximal block size

      int nimax = 0;

      int i;
      int niloc;

      for (i = 0; i < _nblks; i++) {
         niloc = (int) (_blks[i + 1] - _blks[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

      vector < int >imaskblk (nimax + 1);
      vector < int >listblk (nimax + 1);
      vector < int >iablk (nimax + 1);

      int *pimaskblk = &imaskblk[0];
      int *plistblk = &listblk[0];
      int *piablk = &iablk[0];

      int icycleblk = -1;

      for (i = 0; i < nimax; i++)
         pimaskblk[i] = icycleblk;

// Compute output data for simple cases

      for (i = 0; i < _nblks; i++)
         _nlist_ext_arr[i] = 0;

      int iblk, j, jj, k, kk, nlistnew;

      if (_ncycle == 0) {
         return;
      } else if (_ncycle == 1) {

         for (iblk = 0; iblk < _nblks; iblk++) {
            if (_blk2cpu[iblk] == myid) {
               CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[iblk].GetASubArr ();
               CMatrix < int, float >*pHMatr_sub = _hmatr_arr[iblk].GetHMatrStr ();
               int nzja_hmatr = pHMatr_sub->GetNzja ();
               int *pja_hmatr = pHMatr_sub->GetJaArr ();
               nlistnew = 0;
               for (j = 0; j < nzja_hmatr; j++) {
                  jj = pja_hmatr[j];
                  if (jj != iblk) {
                     icycleblk++;
                     int nzja_sub = pA_sub[j].GetNzja ();
                     _Int *pja_sub = pA_sub[j].GetJaArr ();
                     for (k = 0; k < nzja_sub; k++) {
                        kk = (int) pja_sub[k];
                        if (pimaskblk[kk] != icycleblk) {
                           nlistnew++;
                           pimaskblk[kk] = icycleblk;
                        }
                     }
                  }
               }
               _nlist_ext_arr[iblk] = nlistnew;
               _list_ext_arr[iblk].resize (nlistnew * 2 + 1);
               int *p_list_ext_arr = &(_list_ext_arr[iblk][0]);
               nlistnew = 0;
               for (j = 0; j < nzja_hmatr; j++) {
                  jj = pja_hmatr[j];
                  if (jj != iblk) {
                     icycleblk++;
                     int nzja_sub = pA_sub[j].GetNzja ();
                     _Int *pja_sub = pA_sub[j].GetJaArr ();
                     int nlist_temp = 0;
                     for (k = 0; k < nzja_sub; k++) {
                        kk = (int) pja_sub[k];
                        if (pimaskblk[kk] != icycleblk) {
                           plistblk[nlist_temp] = kk;
                           nlist_temp++;
                           pimaskblk[kk] = icycleblk;
                        }
                     }
                     sort (plistblk, plistblk + nlist_temp);
                     for (k = 0; k < nlist_temp; k++) {
                        p_list_ext_arr[nlistnew * 2] = plistblk[k];
                        p_list_ext_arr[nlistnew * 2 + 1] = jj;
                        nlistnew++;
                     }
                  }
               }
            }
         }
         return;
      }
// Compute data as two index rows block structures

      vector < CMatrix < _Int, _Flt > >blkrows (_nblks);
      CMatrix < _Int, _Flt > *pblkrows = &blkrows[0];

      int nzjanew, ind, kj;

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[iblk].GetASubArr ();
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[iblk].GetHMatrStr ();
            int nzja_hmatr = pHMatr_sub->GetNzja ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            nzjanew = 0;
            for (j = 0; j < nzja_hmatr; j++) {
               nzjanew += pA_sub[j].GetNzja ();
            }
            nlistnew = (int) (_blks[iblk + 1] - _blks[iblk]);
            CMatrix < _Int, _Flt > anew;
            anew.ResizeAndSetAllSp (nlistnew, nlistnew, nzjanew, nzjanew);
            _Int *plist_new = anew.GetListArr ();
            _Int *plist2_new = anew.GetList2Arr ();
            _Int *pia_new = anew.GetIaArr ();
            _Int *pja_new = anew.GetJaArr ();
            _Int *pja2_new = anew.GetJa2Arr ();
            for (j = 0; j < nlistnew; j++)
               plist_new[j] = (_Int) j;
            for (j = 0; j < nlistnew; j++)
               plist2_new[j] = (_Int) iblk;
            for (j = 0; j <= nlistnew; j++)
               pia_new[j] = 0;
            for (j = 0; j < nzja_hmatr; j++) {
               int nlistloc = pA_sub[j].GetNlist ();
               _Int *plistloc = pA_sub[j].GetListArr ();
               _Int *pialoc = pA_sub[j].GetIaArr ();
               for (k = 0; k < nlistloc; k++) {
                  kk = (int) plistloc[k];
                  pia_new[kk + 1] += (pialoc[k + 1] - pialoc[k]);
               }
            }
            for (j = 0; j < nlistnew; j++)
               pia_new[j + 1] = pia_new[j] + pia_new[j + 1];
            for (j = 0; j < nlistnew; j++)
               piablk[j] = (int) pia_new[j];
            for (j = 0; j < nzja_hmatr; j++) {
               jj = (int) pja_hmatr[j];
               int nlistloc = pA_sub[j].GetNlist ();
               _Int *plistloc = pA_sub[j].GetListArr ();
               _Int *pialoc = pA_sub[j].GetIaArr ();
               _Int *pjaloc = pA_sub[j].GetJaArr ();
               for (k = 0; k < nlistloc; k++) {
                  kk = (int) plistloc[k];
                  ind = (int) piablk[kk];
                  for (kj = (int) pialoc[k]; kj < pialoc[k + 1]; kj++) {
                     pja_new[ind] = pjaloc[kj];
                     pja2_new[ind] = jj;
                     ind++;
                  }
                  piablk[kk] = ind;
               }
            }
            pblkrows[iblk].ReplaceFree (anew);
         }
      }

// Prepare initial lists data

      vector < int >nlist_arr (_nblks);
      vector < vector < int > >list_arr (_nblks);
      vector < int >nlist_arr_prev (_nblks);
      vector < vector < int > >list_arr_prev (_nblks);

      int *pnlist_arr_prev = &nlist_arr_prev[0];
      int *pnlist_arr = &nlist_arr[0];
      vector < int >*plist_arr = &list_arr[0];
      vector < int >*plist_arr_prev = &list_arr_prev[0];

      for (iblk = 0; iblk < _nblks; iblk++)
         pnlist_arr_prev[iblk] = 0;
      for (iblk = 0; iblk < _nblks; iblk++)
         pnlist_arr[iblk] = 0;

      int jj2;

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            nlistnew = pblkrows[iblk].GetNlist ();
            nzjanew = pblkrows[iblk].GetNzja ();
            _Int *pja_row = pblkrows[iblk].GetJaArr ();
            _Int *pja2_row = pblkrows[iblk].GetJa2Arr ();
            int nzjaflt = 0;
            for (j = 0; j < nzjanew; j++) {
               jj2 = (int) pja2_row[j];
               if (jj2 != iblk)
                  nzjaflt++;
            }
            vector < CSortInt2 > ii2arr (nzjaflt + 1);
            CSortInt2 *pii2arr = &ii2arr[0];
            nzjaflt = 0;
            for (j = 0; j < nzjanew; j++) {
               jj = (int) pja_row[j];
               jj2 = (int) pja2_row[j];
               if (jj2 != iblk) {
                  pii2arr[nzjaflt].ixval = jj2;
                  pii2arr[nzjaflt].iyval = jj;
                  pii2arr[nzjaflt].itail = j;
                  nzjaflt++;
               }
            }
            sort (pii2arr, pii2arr + nzjaflt);
            int nlist_temp = 0;
            int ix_prev = -1;
            int iy_prev = -1;
            int ix_curr, iy_curr, ival_curr;
            for (j = 0; j < nzjaflt; j++) {
               ix_curr = pii2arr[j].ixval;
               iy_curr = pii2arr[j].iyval;
               ival_curr = pii2arr[j].itail;
               if (ix_curr != ix_prev || iy_curr != iy_prev) {
                  pii2arr[nlist_temp].ixval = ix_curr;
                  pii2arr[nlist_temp].iyval = iy_curr;
                  pii2arr[nlist_temp].itail = ival_curr;
                  nlist_temp++;
                  ix_prev = ix_curr;
                  iy_prev = iy_curr;
               }
            }
            plist_arr[iblk].resize (2 * nlist_temp + 1);
            plist_arr_prev[iblk].resize (2 * nlist_temp + 1);
            int *pplist_arr = &(plist_arr[iblk][0]);
            int *pplist_arr_prev = &(plist_arr_prev[iblk][0]);
            for (j = 0; j < nlist_temp; j++) {
               pplist_arr[j * 2] = pii2arr[j].iyval;
               pplist_arr[j * 2 + 1] = pii2arr[j].ixval;
               pplist_arr_prev[j * 2] = pii2arr[j].iyval;
               pplist_arr_prev[j * 2 + 1] = pii2arr[j].ixval;
            }
            pnlist_arr[iblk] = nlist_temp;
            pnlist_arr_prev[iblk] = nlist_temp;
         }
      }

// Create mask data

      int icyclecpu = -1;

      vector < int >imaskcpu (nproc);
      vector < int >listcpu (nproc);
      vector < int >indcpu (nproc);

      int *pimaskcpu = &imaskcpu[0];
      int *plistcpu = &listcpu[0];
      int *pindcpu = &indcpu[0];

      for (i = 0; i < nproc; i++) {
         pimaskcpu[i] = icyclecpu;
      }

      int icycletot = -1;

      vector < int >imasktot (_nblks);
      vector < int >listtot (_nblks);
      vector < int >indtot (_nblks);

      int *pimasktot = &imasktot[0];
      int *plisttot = &listtot[0];
      int *pindtot = &indtot[0];

      for (i = 0; i < _nblks; i++) {
         pimasktot[i] = icycletot;
      }

// Main extention cycle

      int icycle_ext, jcpu;

      for (icycle_ext = 0; icycle_ext < _ncycle - 1; icycle_ext++) {

// Create list of cpus and count sizes

         icyclecpu++;

         int nlistcpu = 0;

         for (iblk = 0; iblk < _nblks; iblk++) {
            if (_blk2cpu[iblk] == myid) {
               int *pplist_arr_prev = &(plist_arr_prev[iblk][0]);
               for (j = 0; j < pnlist_arr_prev[iblk]; j++) {
                  jj2 = pplist_arr_prev[j * 2 + 1];
                  jcpu = _blk2cpu[jj2];
                  if (pimaskcpu[jcpu] != icyclecpu) {
                     plistcpu[nlistcpu] = jcpu;
                     nlistcpu++;
                     pimaskcpu[jcpu] = icyclecpu;
                  }
               }
            }
         }

         sort (plistcpu, plistcpu + nlistcpu);

         for (i = 0; i < nlistcpu; i++) {
            jcpu = plistcpu[i];
            pindcpu[jcpu] = i;
         }

         vector < int >nz_send (nlistcpu + 1);

         int *pnz_send = &nz_send[0];

         for (i = 0; i < nlistcpu; i++)
            pnz_send[i] = 0;

         for (iblk = 0; iblk < _nblks; iblk++) {
            if (_blk2cpu[iblk] == myid) {
               int *pplist_arr_prev = &(plist_arr_prev[iblk][0]);
               for (j = 0; j < pnlist_arr_prev[iblk]; j++) {
                  jj2 = pplist_arr_prev[j * 2 + 1];
                  jcpu = _blk2cpu[jj2];
                  ind = pindcpu[jcpu];
                  pnz_send[ind]++;
               }
            }
         }

// Prepare send data

         vector < CBMatrix < _Int, _Flt > >hblk_send (nlistcpu + 1);

         CBMatrix < _Int, _Flt > *phblk_send = &hblk_send[0];

         for (i = 0; i < nlistcpu; i++) {
            phblk_send[i].SetNzblk (1);
            phblk_send[i].ResizeASub (1);
            CMatrix < _Int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
            CMatrix < _Int, _Flt > ablk_temp;
            ablk_temp.ResizeAndSetAllSp (0, 0, 3 * pnz_send[i], 0);
            pA_sub->ReplaceFree (ablk_temp);
         }

         for (i = 0; i < nlistcpu; i++)
            pnz_send[i] = 0;

         for (iblk = 0; iblk < _nblks; iblk++) {
            if (_blk2cpu[iblk] == myid) {
               int *pplist_arr_prev = &(plist_arr_prev[iblk][0]);
               for (j = 0; j < pnlist_arr_prev[iblk]; j++) {
                  jj = pplist_arr_prev[j * 2];
                  jj2 = pplist_arr_prev[j * 2 + 1];
                  jcpu = _blk2cpu[jj2];
                  ind = pindcpu[jcpu];
                  CMatrix < _Int, _Flt > *pA_sub = phblk_send[ind].GetASubArr ();
                  _Int *pja_asub = pA_sub->GetJaArr ();
                  k = pnz_send[ind];
                  pja_asub[3 * k] = iblk;
                  pja_asub[3 * k + 1] = jj;
                  pja_asub[3 * k + 2] = jj2;
                  pnz_send[ind]++;
               }
            }
         }

// Pack send data

         vector < int >CpuIDSend (nlistcpu);
         vector < vector < char > >ObjSend (nlistcpu);

         int *pCpuIDSend = NULL;
         vector < char >*pObjSend = NULL;

         if (nlistcpu > 0) {
            pCpuIDSend = &CpuIDSend[0];
            pObjSend = &ObjSend[0];
         }

         long long isize;
         char *pobj;

         for (i = 0; i < nlistcpu; i++) {
            pCpuIDSend[i] = plistcpu[i];
            isize = phblk_send[i].GetPackedSize ();
            pObjSend[i].resize ((size_t) isize);
            pobj = &(pObjSend[i][0]);
            phblk_send[i].FillPacked (isize, pobj);
            phblk_send[i].Clean ();
         }

// Exchange

         vector < int >CpuIDRecv;
         vector < vector < char > >ObjRecv;

         CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

         {
            vector < int >CpuIDSend_temp;
            vector < vector < char > >ObjSend_temp;
            CpuIDSend.swap (CpuIDSend_temp);
            ObjSend.swap (ObjSend_temp);
         }

// Unpack receive data

         int nrecv = (int) CpuIDRecv.size ();

         vector < char >*pObjRecv = NULL;

         if (nrecv > 0) {
            pObjRecv = &ObjRecv[0];
         }

         vector < CBMatrix < _Int, _Flt > >hblk_recv (nrecv + 1);

         CBMatrix < _Int, _Flt > *phblk_recv = &hblk_recv[0];

         for (i = 0; i < nrecv; i++) {
            isize = (long long) pObjRecv[i].size ();
            pobj = &(pObjRecv[i][0]);
            phblk_recv[i].UnPack (isize, pobj);
         }

// Free recv data

         {
            vector < vector < char > >ObjRecv_temp;
            ObjRecv.swap (ObjRecv_temp);
         }

// Prepare the answer for all received data

         for (i = 0; i < nrecv; i++) {
            CMatrix < _Int, _Flt > *pA_sub = phblk_recv[i].GetASubArr ();
            int nzjaloc = pA_sub->GetNzja ();
            _Int *pja_sub = pA_sub->GetJaArr ();
            int nlistloc = nzjaloc / 3;
            int nzja_new = 0;
            for (j = 0; j < nlistloc; j++) {
               jj = (int) pja_sub[j * 3 + 1];
               jj2 = (int) pja_sub[j * 3 + 2];
               _Int *pia_rows = pblkrows[jj2].GetIaArr ();
               nzja_new += (int) (pia_rows[jj + 1] - pia_rows[jj]);
            }
            CMatrix < _Int, _Flt > a_new;
            a_new.ResizeAndSetAllSp (nlistloc, 0, nzja_new, nzja_new);
            _Int *plist_new = a_new.GetListArr ();
            _Int *pia_new = a_new.GetIaArr ();
            _Int *pja_new = a_new.GetJaArr ();
            _Int *pja2_new = a_new.GetJa2Arr ();
            nzja_new = 0;
            pia_new[0] = 0;
            for (j = 0; j < nlistloc; j++) {
               plist_new[j] = pja_sub[j * 3];
               jj = (int) pja_sub[j * 3 + 1];
               jj2 = (int) pja_sub[j * 3 + 2];
               _Int *pia_rows = pblkrows[jj2].GetIaArr ();
               _Int *pja_rows = pblkrows[jj2].GetJaArr ();
               _Int *pja2_rows = pblkrows[jj2].GetJa2Arr ();
               for (k = (int) pia_rows[jj]; k < pia_rows[jj + 1]; k++) {
                  pja_new[nzja_new] = pja_rows[k];
                  pja2_new[nzja_new] = pja2_rows[k];
                  nzja_new++;
               }
               pia_new[j + 1] = nzja_new;
            }
            pA_sub->ReplaceFree (a_new);
         }

// Pack send data

         ObjRecv.resize (nrecv);

         pObjRecv = NULL;

         if (nrecv > 0) {
            pObjRecv = &ObjRecv[0];
         }

         for (i = 0; i < nrecv; i++) {
            isize = phblk_recv[i].GetPackedSize ();
            pObjRecv[i].resize ((size_t) isize);
            pobj = &(pObjRecv[i][0]);
            phblk_recv[i].FillPacked (isize, pobj);
            phblk_recv[i].Clean ();
         }

// Exchange data back

         CMPIDataExchange::DataExchange (_comm, CpuIDRecv, ObjRecv, CpuIDSend, ObjSend);

// Free send data

         {
            vector < int >CpuIDSend_temp;
            vector < vector < char > >ObjSend_temp;
            CpuIDRecv.swap (CpuIDSend_temp);
            ObjRecv.swap (ObjSend_temp);
         }

// Unpack receive data

         nrecv = (int) CpuIDSend.size ();

         pObjSend = NULL;
         if (nrecv > 0) {
            pObjSend = &ObjSend[0];
         }

         hblk_send.resize (nrecv + 1);

         phblk_send = &hblk_send[0];

         for (i = 0; i < nrecv; i++) {
            isize = (long long) pObjSend[i].size ();
            pobj = &(pObjSend[i][0]);
            phblk_send[i].UnPack (isize, pobj);
         }

// Free recv data

         {
            vector < int >CpuIDRecv_temp;
            vector < vector < char > >ObjRecv_temp;
            CpuIDSend.swap (CpuIDRecv_temp);
            ObjSend.swap (ObjRecv_temp);
         }

// Combine received data into the new lists

         icycletot++;

         int nlisttot = 0;

         for (i = 0; i < nrecv; i++) {
            CMatrix < _Int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
            int nlist_sub = pA_sub->GetNlist ();
            _Int *plist_sub = pA_sub->GetListArr ();
            for (j = 0; j < nlist_sub; j++) {
               jj2 = (int) plist_sub[j];
               if (pimasktot[jj2] != icycletot) {
                  plisttot[nlisttot] = jj2;
                  nlisttot++;
                  pimasktot[jj2] = icycletot;
               }
            }
         }

         sort (plisttot, plisttot + nlisttot);

         for (i = 0; i < nlisttot; i++) {
            jj2 = plisttot[i];
            pindtot[jj2] = i;
         }

         vector < int >nz_list_new (nlisttot + 1);
         int *pnz_list_new = &nz_list_new[0];

         for (i = 0; i < nlisttot; i++)
            pnz_list_new[i] = 0;

         for (i = 0; i < nrecv; i++) {
            CMatrix < _Int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
            int nlist_sub = pA_sub->GetNlist ();
            _Int *plist_sub = pA_sub->GetListArr ();
            _Int *pia_sub = pA_sub->GetIaArr ();
            for (j = 0; j < nlist_sub; j++) {
               jj2 = (int) plist_sub[j];
               ind = (int) pindtot[jj2];
               pnz_list_new[ind] += (int) (pia_sub[j + 1] - pia_sub[j]);
            }
         }

         vector < vector < int > >list_new (nlisttot + 1);
         vector < int >*plist_new = &list_new[0];

         for (i = 0; i < nlisttot; i++) {
            plist_new[i].resize (2 * pnz_list_new[i] + 1);
         }

         for (i = 0; i < nlisttot; i++)
            pnz_list_new[i] = 0;

         int kk2;

         for (i = 0; i < nrecv; i++) {
            CMatrix < _Int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
            int nlist_sub = pA_sub->GetNlist ();
            _Int *plist_sub = pA_sub->GetListArr ();
            _Int *pia_sub = pA_sub->GetIaArr ();
            _Int *pja_sub = pA_sub->GetJaArr ();
            _Int *pja2_sub = pA_sub->GetJa2Arr ();
            for (j = 0; j < nlist_sub; j++) {
               jj2 = (int) plist_sub[j];
               ind = (int) pindtot[jj2];
               k = (int) pnz_list_new[ind];
               int *pplist_new = &(plist_new[ind][0]);
               for (kj = (int) pia_sub[j]; kj < pia_sub[j + 1]; kj++) {
                  kk = (int) pja_sub[kj];
                  kk2 = (int) pja2_sub[kj];
                  pplist_new[k * 2] = kk;
                  pplist_new[k * 2 + 1] = kk2;
                  k++;
               }
               pnz_list_new[ind] = k;
            }
         }

// Sort and filter

         for (i = 0; i < nlisttot; i++) {

// Sort and filter coincident and own block numbers

            iblk = plisttot[i];
            int *pplist_new = &(plist_new[i][0]);
            vector < CSortInt2 > ii2arr (pnz_list_new[i] + 1);
            CSortInt2 *pii2arr = &ii2arr[0];
            for (j = 0; j < pnz_list_new[i]; j++) {
               pii2arr[j].ixval = pplist_new[j * 2 + 1];
               pii2arr[j].iyval = pplist_new[j * 2];
               pii2arr[j].itail = j;
            }
            sort (pii2arr, pii2arr + pnz_list_new[i]);
            int nznew = 0;
            int ix_prev = -1;
            int iy_prev = -1;
            int ix_curr, iy_curr;
            for (j = 0; j < pnz_list_new[i]; j++) {
               ix_curr = pii2arr[j].ixval;
               iy_curr = pii2arr[j].iyval;
               if (ix_curr != iblk && (ix_curr != ix_prev || iy_curr != iy_prev)) {
                  pii2arr[nznew].ixval = ix_curr;
                  pii2arr[nznew].iyval = iy_curr;
                  pii2arr[nznew].itail = nznew;
                  nznew++;
                  ix_prev = ix_curr;
                  iy_prev = iy_curr;
               }
            }

// Filter by previous data and extend previous sorted list data

            int *pplist_arr = &(plist_arr[iblk][0]);

            vector < int >list_add (2 * (pnlist_arr[iblk] + nznew) + 1);
            vector < int >list_flt (2 * nznew + 1);

            int *plist_add = &list_add[0];
            int *plist_flt = &list_flt[0];

            int nlistadd = 0;
            int nlistflt = 0;

            int jj_new, jj2_new;

            int ip = 0;
            int ip_new = 0;

            while (ip < pnlist_arr[iblk] || ip_new < nznew) {
               if (ip < pnlist_arr[iblk] && ip_new < nznew) {
                  jj = pplist_arr[2 * ip];
                  jj2 = pplist_arr[2 * ip + 1];
                  jj_new = pii2arr[ip_new].iyval;
                  jj2_new = pii2arr[ip_new].ixval;
                  if (jj == jj_new && jj2 == jj2_new) {
                     plist_add[2 * nlistadd] = jj;
                     plist_add[2 * nlistadd + 1] = jj2;
                     nlistadd++;
                     ip++;
                     ip_new++;
                  } else if (jj2 < jj2_new || (jj2 == jj2_new && jj < jj_new)) {
                     plist_add[2 * nlistadd] = jj;
                     plist_add[2 * nlistadd + 1] = jj2;
                     nlistadd++;
                     ip++;
                  } else {
                     plist_add[2 * nlistadd] = jj_new;
                     plist_add[2 * nlistadd + 1] = jj2_new;
                     nlistadd++;
                     plist_flt[2 * nlistflt] = jj_new;
                     plist_flt[2 * nlistflt + 1] = jj2_new;
                     nlistflt++;
                     ip_new++;
                  }
               } else if (ip < pnlist_arr[iblk]) {
                  plist_add[2 * nlistadd] = pplist_arr[2 * ip];
                  plist_add[2 * nlistadd + 1] = pplist_arr[2 * ip + 1];
                  nlistadd++;
                  ip++;
               } else {
                  plist_add[2 * nlistadd] = pii2arr[ip_new].iyval;
                  plist_add[2 * nlistadd + 1] = pii2arr[ip_new].ixval;
                  nlistadd++;
                  plist_flt[2 * nlistflt] = pii2arr[ip_new].iyval;
                  plist_flt[2 * nlistflt + 1] = pii2arr[ip_new].ixval;
                  nlistflt++;
                  ip_new++;
               }
            }

// Replace

            pnlist_arr[iblk] = nlistadd;
            pnlist_arr_prev[iblk] = nlistflt;

            plist_arr[iblk].swap (list_add);
            plist_arr_prev[iblk].swap (list_flt);

         }

      }

// Prepare final data

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            int *pplist_arr = &(plist_arr[iblk][0]);
            _nlist_ext_arr[iblk] = pnlist_arr[iblk];
            _list_ext_arr[iblk].resize (2 * pnlist_arr[iblk] + 1);
            int *pplist_ext = &(_list_ext_arr[iblk][0]);
            for (j = 0; j < 2 * (pnlist_arr[iblk]); j++)
               pplist_ext[j] = pplist_arr[j];
         }
      }

   }

// Compute the extended lists
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ExtendedLists (void *_comm, int _ncycle, int _nhblks, int *_hblk2cpu,
                             int *_hblk2blk, int *_blk2hblk, int _nblks, long long *_blks,
                             CBMatrix < _Int, _Flt > *_hmatr_arr, int *_nlist_ext_arr,
                             vector < int >*_list_ext_arr)
   {

      int myid = CMPIDataExchange::GetMyid (_comm);
      int nproc = CMPIDataExchange::GetNproc (_comm);

// Compute the maximal block size and init threads data

      int nimax = 0;

      int i;
      int niloc;

      for (i = 0; i < _nblks; i++) {
         niloc = (int) (_blks[i + 1] - _blks[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      vector < int >icycle_thr (n_thr + 1);
      vector < CVectorData < int > >imaskblk_thr (n_thr + 1);

      int *picycle_thr = &icycle_thr[0];
      CVectorData < int >*pimaskblk_thr = &imaskblk_thr[0];

      vector < int >nlistarr_thr (n_thr + 1);
      vector < vector < int > >listarr_thr (n_thr + 1);

      int *pnlistarr_thr = &nlistarr_thr[0];
      vector < int >*plistarr_thr = &listarr_thr[0];

      for (i = 0; i < n_thr; i++)
         picycle_thr[i] = -1;

// Compute output data for simple cases

      for (i = 0; i < _nhblks; i++)
         _nlist_ext_arr[i] = 0;

      int ihblk;

      if (_ncycle == 0) {
         return;
      } else if (_ncycle == 1) {
         for (ihblk = 0; ihblk < _nhblks; ihblk++) {
            if (_hblk2cpu[ihblk] == myid) {
               CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[ihblk].GetASubArr ();
               CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
               int nlist_hmatr = pHMatr_sub->GetNlist ();
               int *pia_hmatr = pHMatr_sub->GetIaArr ();
               int *pja_hmatr = pHMatr_sub->GetJaArr ();
               int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
               for (i = 0; i < n_thr; i++)
                  pnlistarr_thr[i] = 0;
               for (i = 0; i < n_thr; i++)
                  plistarr_thr[i].resize (0);
#ifdef USE_THREADS
#pragma omp parallel for
#endif
               for (int ipar = 0; ipar < nlist_hmatr; ipar++) {

                  int my_thr = 0;
#ifdef USE_THREADS
                  my_thr = omp_get_thread_num ();
#endif

                  int j, jj, jj2, jblkgl, k, kk;

                  if (picycle_thr[my_thr] == -1) {
                     pimaskblk_thr[my_thr].resize (2 * nimax + 1);
                     int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
                     for (j = 0; j < nimax; j++)
                        pimaskblk[j] = -1;
                  }
                  int icycleblk = picycle_thr[my_thr];
                  int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
                  for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
                     jj = pja_hmatr[j];
                     jj2 = pja2_hmatr[j];
                     jblkgl = _hblk2blk[jj2] + jj;
                     if (jj2 != ihblk) {
                        icycleblk++;
                        int nzja_sub = pA_sub[j].GetNzja ();
                        _Int *pja_sub = pA_sub[j].GetJaArr ();
                        for (k = 0; k < nzja_sub; k++) {
                           kk = (int) pja_sub[k];
                           if (pimaskblk[kk] != icycleblk) {
                              plistarr_thr[my_thr].push_back (kk);
                              plistarr_thr[my_thr].push_back (jblkgl);
                              pnlistarr_thr[my_thr]++;
                              pimaskblk[kk] = icycleblk;
                           }
                        }
                     }
                  }
                  picycle_thr[my_thr] = icycleblk;
               }

               {
                  int i, j, nlistnew, i1, i2;
                  nlistnew = 0;
                  for (i = 0; i < n_thr; i++)
                     nlistnew += pnlistarr_thr[i];
                  vector < CSortInt2 > ii2arr (nlistnew + 1);
                  CSortInt2 *pii2arr = &ii2arr[0];
                  nlistnew = 0;
                  for (i = 0; i < n_thr; i++) {
                     if (pnlistarr_thr[i] > 0) {
                        int *pplistarr = &plistarr_thr[i][0];
                        for (j = 0; j < pnlistarr_thr[i]; j++) {
                           pii2arr[nlistnew].ixval = pplistarr[j * 2 + 1];
                           pii2arr[nlistnew].iyval = pplistarr[j * 2];
                           pii2arr[nlistnew].itail = nlistnew;
                           nlistnew++;
                        }
                     }
                  }
                  sort (pii2arr, pii2arr + nlistnew);
                  int nlistflt = 0;
                  int i1prev = -1;
                  int i2prev = -1;
                  for (j = 0; j < nlistnew; j++) {
                     i1 = pii2arr[j].ixval;
                     i2 = pii2arr[j].iyval;
                     if (i1 != i1prev || i2 != i2prev) {
                        pii2arr[nlistflt].ixval = i1;
                        pii2arr[nlistflt].iyval = i2;
                        nlistflt++;
                        i1prev = i1;
                        i2prev = i2;
                     }
                  }
                  _nlist_ext_arr[ihblk] = nlistflt;
                  _list_ext_arr[ihblk].resize (nlistflt * 2 + 1);
                  int *p_list_ext_arr = &(_list_ext_arr[ihblk][0]);
                  for (j = 0; j < nlistflt; j++) {
                     p_list_ext_arr[j * 2] = pii2arr[j].iyval;
                     p_list_ext_arr[j * 2 + 1] = pii2arr[j].ixval;
                  }
               }
            }
         }
         return;
      }
// Compute data as two index rows block structures

      vector < CMatrix < _Int, _Flt > >blkrows (_nblks);
      CMatrix < _Int, _Flt > *pblkrows = &blkrows[0];

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[ihblk].GetASubArr ();
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();

            {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
               for (int ipar = 0; ipar < nlist_hmatr; ipar++) {

                  int j, jj, jj2, jblkgl, k, kk, nlistnew;
                  int nzjanew, ind, kj, iblkgl;

                  nzjanew = 0;
                  for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
                     nzjanew += pA_sub[j].GetNzja ();
                  }
                  iblkgl = _hblk2blk[ihblk] + ipar;
                  nlistnew = (int) (_blks[iblkgl + 1] - _blks[iblkgl]);
                  CMatrix < _Int, _Flt > anew;
                  anew.ResizeAndSetAllSp (nlistnew, nlistnew, nzjanew, nzjanew);
                  _Int *plist_new = anew.GetListArr ();
                  _Int *plist2_new = anew.GetList2Arr ();
                  _Int *pia_new = anew.GetIaArr ();
                  _Int *pja_new = anew.GetJaArr ();
                  _Int *pja2_new = anew.GetJa2Arr ();
                  for (j = 0; j < nlistnew; j++)
                     plist_new[j] = (_Int) j;
                  for (j = 0; j < nlistnew; j++)
                     plist2_new[j] = (_Int) iblkgl;
                  for (j = 0; j <= nlistnew; j++)
                     pia_new[j] = 0;
                  for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
                     int nlistloc = pA_sub[j].GetNlist ();
                     _Int *plistloc = pA_sub[j].GetListArr ();
                     _Int *pialoc = pA_sub[j].GetIaArr ();
                     for (k = 0; k < nlistloc; k++) {
                        kk = (int) plistloc[k];
                        pia_new[kk + 1] += (pialoc[k + 1] - pialoc[k]);
                     }
                  }
                  for (j = 0; j < nlistnew; j++)
                     pia_new[j + 1] = pia_new[j] + pia_new[j + 1];
                  vector < int >iptr (nlistnew + 1);
                  int *piptr = &iptr[0];
                  for (j = 0; j < nlistnew; j++)
                     piptr[j] = (int) pia_new[j];
                  for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
                     jj = (int) pja_hmatr[j];
                     jj2 = (int) pja2_hmatr[j];
                     jblkgl = _hblk2blk[jj2] + jj;
                     int nlistloc = pA_sub[j].GetNlist ();
                     _Int *plistloc = pA_sub[j].GetListArr ();
                     _Int *pialoc = pA_sub[j].GetIaArr ();
                     _Int *pjaloc = pA_sub[j].GetJaArr ();
                     for (k = 0; k < nlistloc; k++) {
                        kk = (int) plistloc[k];
                        ind = (int) piptr[kk];
                        for (kj = (int) pialoc[k]; kj < pialoc[k + 1]; kj++) {
                           pja_new[ind] = pjaloc[kj];
                           pja2_new[ind] = jblkgl;
                           ind++;
                        }
                        piptr[kk] = ind;
                     }
                  }
                  pblkrows[iblkgl].ReplaceFree (anew);
               }
            }
         }
      }

// Prepare initial lists data

      vector < int >nlist_arr (_nblks + 1);
      vector < vector < int > >list_arr (_nblks + 1);
      vector < int >nlist_arr_prev (_nblks + 1);
      vector < vector < int > >list_arr_prev (_nblks + 1);

      int *pnlist_arr_prev = &nlist_arr_prev[0];
      int *pnlist_arr = &nlist_arr[0];
      vector < int >*plist_arr = &list_arr[0];
      vector < int >*plist_arr_prev = &list_arr_prev[0];

      {
         int iblk;
         for (iblk = 0; iblk < _nblks; iblk++)
            pnlist_arr_prev[iblk] = 0;
         for (iblk = 0; iblk < _nblks; iblk++)
            pnlist_arr[iblk] = 0;
      }

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = _hblk2blk[ihblk]; ipar < _hblk2blk[ihblk + 1]; ipar++) {

               int j, jj, jj2;
               int nzjanew;

               nzjanew = pblkrows[ipar].GetNzja ();
               _Int *pja_row = pblkrows[ipar].GetJaArr ();
               _Int *pja2_row = pblkrows[ipar].GetJa2Arr ();
               int nzjaflt = 0;
               for (j = 0; j < nzjanew; j++) {
                  jj2 = (int) pja2_row[j];
                  if (jj2 != ipar)
                     nzjaflt++;
               }
               vector < CSortInt2 > ii2arr (nzjaflt + 1);
               CSortInt2 *pii2arr = &ii2arr[0];
               nzjaflt = 0;
               for (j = 0; j < nzjanew; j++) {
                  jj = (int) pja_row[j];
                  jj2 = (int) pja2_row[j];
                  if (jj2 != ipar) {
                     pii2arr[nzjaflt].ixval = jj2;
                     pii2arr[nzjaflt].iyval = jj;
                     pii2arr[nzjaflt].itail = j;
                     nzjaflt++;
                  }
               }
               sort (pii2arr, pii2arr + nzjaflt);
               int nlist_temp = 0;
               int ix_prev = -1;
               int iy_prev = -1;
               int ix_curr, iy_curr, ival_curr;
               for (j = 0; j < nzjaflt; j++) {
                  ix_curr = pii2arr[j].ixval;
                  iy_curr = pii2arr[j].iyval;
                  ival_curr = pii2arr[j].itail;
                  if (ix_curr != ix_prev || iy_curr != iy_prev) {
                     pii2arr[nlist_temp].ixval = ix_curr;
                     pii2arr[nlist_temp].iyval = iy_curr;
                     pii2arr[nlist_temp].itail = ival_curr;
                     nlist_temp++;
                     ix_prev = ix_curr;
                     iy_prev = iy_curr;
                  }
               }
               plist_arr[ipar].resize (2 * nlist_temp + 1);
               plist_arr_prev[ipar].resize (2 * nlist_temp + 1);
               int *pplist_arr = &(plist_arr[ipar][0]);
               int *pplist_arr_prev = &(plist_arr_prev[ipar][0]);
               for (j = 0; j < nlist_temp; j++) {
                  pplist_arr[j * 2] = pii2arr[j].iyval;
                  pplist_arr[j * 2 + 1] = pii2arr[j].ixval;
                  pplist_arr_prev[j * 2] = pii2arr[j].iyval;
                  pplist_arr_prev[j * 2 + 1] = pii2arr[j].ixval;
               }
               pnlist_arr[ipar] = nlist_temp;
               pnlist_arr_prev[ipar] = nlist_temp;
            }
         }
      }

// Create mask data

      int icyclecpu = -1;

      vector < int >imaskcpu (nproc);
      vector < int >listcpu (nproc);
      vector < int >indcpu (nproc);

      int *pimaskcpu = &imaskcpu[0];
      int *plistcpu = &listcpu[0];
      int *pindcpu = &indcpu[0];

      for (i = 0; i < nproc; i++) {
         pimaskcpu[i] = icyclecpu;
      }

      int icycletot = -1;

      vector < int >imasktot (_nblks);
      vector < int >listtot (_nblks);
      vector < int >indtot (_nblks);

      int *pimasktot = &imasktot[0];
      int *plisttot = &listtot[0];
      int *pindtot = &indtot[0];

      for (i = 0; i < _nblks; i++) {
         pimasktot[i] = icycletot;
      }

// Main extention cycle

      int icycle_ext, iblk;

      for (icycle_ext = 0; icycle_ext < _ncycle - 1; icycle_ext++) {

// Create list of cpus and count sizes

         icyclecpu++;

         int nlistcpu = 0;

         int j;

         for (ihblk = 0; ihblk < _nhblks; ihblk++) {
            if (_hblk2cpu[ihblk] == myid) {
               for (iblk = _hblk2blk[ihblk]; iblk < _hblk2blk[ihblk + 1]; iblk++) {
                  int *pplist_arr_prev = &(plist_arr_prev[iblk][0]);
                  for (j = 0; j < pnlist_arr_prev[iblk]; j++) {
                     int jj2 = pplist_arr_prev[j * 2 + 1];
                     int jhblk = _blk2hblk[jj2];
                     int jcpu = _hblk2cpu[jhblk];
                     if (pimaskcpu[jcpu] != icyclecpu) {
                        plistcpu[nlistcpu] = jcpu;
                        nlistcpu++;
                        pimaskcpu[jcpu] = icyclecpu;
                     }
                  }
               }
            }
         }

         sort (plistcpu, plistcpu + nlistcpu);

         for (i = 0; i < nlistcpu; i++) {
            int jcpu = plistcpu[i];
            pindcpu[jcpu] = i;
         }

         vector < int >nz_send (nlistcpu + 1);

         int *pnz_send = &nz_send[0];

         for (i = 0; i < nlistcpu; i++)
            pnz_send[i] = 0;

         for (ihblk = 0; ihblk < _nhblks; ihblk++) {
            if (_hblk2cpu[ihblk] == myid) {
               for (iblk = _hblk2blk[ihblk]; iblk < _hblk2blk[ihblk + 1]; iblk++) {
                  int *pplist_arr_prev = &(plist_arr_prev[iblk][0]);
                  for (j = 0; j < pnlist_arr_prev[iblk]; j++) {
                     int jj2 = pplist_arr_prev[j * 2 + 1];
                     int jhblk = _blk2hblk[jj2];
                     int jcpu = _hblk2cpu[jhblk];
                     int ind = pindcpu[jcpu];
                     pnz_send[ind]++;
                  }
               }
            }
         }

// Prepare send data

         vector < CBMatrix < _Int, _Flt > >hblk_send (nlistcpu + 1);

         CBMatrix < _Int, _Flt > *phblk_send = &hblk_send[0];

         for (i = 0; i < nlistcpu; i++) {
            phblk_send[i].SetNzblk (1);
            phblk_send[i].ResizeASub (1);
            CMatrix < _Int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
            CMatrix < _Int, _Flt > ablk_temp;
            ablk_temp.ResizeAndSetAllSp (0, 0, 3 * pnz_send[i], 0);
            pA_sub->ReplaceFree (ablk_temp);
         }

         for (i = 0; i < nlistcpu; i++)
            pnz_send[i] = 0;

         for (ihblk = 0; ihblk < _nhblks; ihblk++) {
            if (_hblk2cpu[ihblk] == myid) {
               for (iblk = _hblk2blk[ihblk]; iblk < _hblk2blk[ihblk + 1]; iblk++) {
                  int *pplist_arr_prev = &(plist_arr_prev[iblk][0]);
                  for (j = 0; j < pnlist_arr_prev[iblk]; j++) {
                     int jj = pplist_arr_prev[j * 2];
                     int jj2 = pplist_arr_prev[j * 2 + 1];
                     int jhblk = _blk2hblk[jj2];
                     int jcpu = _hblk2cpu[jhblk];
                     int ind = pindcpu[jcpu];
                     CMatrix < _Int, _Flt > *pA_sub = phblk_send[ind].GetASubArr ();
                     _Int *pja_asub = pA_sub->GetJaArr ();
                     int k = pnz_send[ind];
                     pja_asub[3 * k] = iblk;
                     pja_asub[3 * k + 1] = jj;
                     pja_asub[3 * k + 2] = jj2;
                     pnz_send[ind]++;
                  }
               }
            }
         }

// Pack send data

         vector < int >CpuIDSend (nlistcpu);
         vector < vector < char > >ObjSend (nlistcpu);

         int *pCpuIDSend = NULL;
         vector < char >*pObjSend = NULL;

         if (nlistcpu > 0) {
            pCpuIDSend = &CpuIDSend[0];
            pObjSend = &ObjSend[0];
         }

         long long isize;
         char *pobj;

         for (i = 0; i < nlistcpu; i++) {
            pCpuIDSend[i] = plistcpu[i];
            isize = phblk_send[i].GetPackedSize ();
            pObjSend[i].resize ((size_t) isize);
            pobj = &(pObjSend[i][0]);
            phblk_send[i].FillPacked (isize, pobj);
            phblk_send[i].Clean ();
         }

// Exchange

         vector < int >CpuIDRecv;
         vector < vector < char > >ObjRecv;

         CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

         {
            vector < int >CpuIDSend_temp;
            vector < vector < char > >ObjSend_temp;
            CpuIDSend.swap (CpuIDSend_temp);
            ObjSend.swap (ObjSend_temp);
         }

// Unpack receive data

         int nrecv = (int) CpuIDRecv.size ();

         vector < char >*pObjRecv = NULL;

         if (nrecv > 0) {
            pObjRecv = &ObjRecv[0];
         }

         vector < CBMatrix < _Int, _Flt > >hblk_recv (nrecv + 1);

         CBMatrix < _Int, _Flt > *phblk_recv = &hblk_recv[0];

         for (i = 0; i < nrecv; i++) {
            isize = (long long) pObjRecv[i].size ();
            pobj = &(pObjRecv[i][0]);
            phblk_recv[i].UnPack (isize, pobj);
         }

// Free recv data

         {
            vector < vector < char > >ObjRecv_temp;
            ObjRecv.swap (ObjRecv_temp);
         }

// Prepare the answer for all received data

         {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nrecv; ipar++) {

               int j, k;
               CMatrix < _Int, _Flt > *pA_sub = phblk_recv[ipar].GetASubArr ();
               int nzjaloc = pA_sub->GetNzja ();
               _Int *pja_sub = pA_sub->GetJaArr ();
               int nlistloc = nzjaloc / 3;
               int nzja_new = 0;
               for (j = 0; j < nlistloc; j++) {
                  int jj = (int) pja_sub[j * 3 + 1];
                  int jj2 = (int) pja_sub[j * 3 + 2];
                  _Int *pia_rows = pblkrows[jj2].GetIaArr ();
                  nzja_new += (int) (pia_rows[jj + 1] - pia_rows[jj]);
               }
               CMatrix < _Int, _Flt > a_new;
               a_new.ResizeAndSetAllSp (nlistloc, 0, nzja_new, nzja_new);
               _Int *plist_new = a_new.GetListArr ();
               _Int *pia_new = a_new.GetIaArr ();
               _Int *pja_new = a_new.GetJaArr ();
               _Int *pja2_new = a_new.GetJa2Arr ();
               nzja_new = 0;
               pia_new[0] = 0;
               for (j = 0; j < nlistloc; j++) {
                  plist_new[j] = pja_sub[j * 3];
                  int jj = (int) pja_sub[j * 3 + 1];
                  int jj2 = (int) pja_sub[j * 3 + 2];
                  _Int *pia_rows = pblkrows[jj2].GetIaArr ();
                  _Int *pja_rows = pblkrows[jj2].GetJaArr ();
                  _Int *pja2_rows = pblkrows[jj2].GetJa2Arr ();
                  for (k = (int) pia_rows[jj]; k < pia_rows[jj + 1]; k++) {
                     pja_new[nzja_new] = pja_rows[k];
                     pja2_new[nzja_new] = pja2_rows[k];
                     nzja_new++;
                  }
                  pia_new[j + 1] = nzja_new;
               }
               pA_sub->ReplaceFree (a_new);
            }
         }

// Pack send data

         ObjRecv.resize (nrecv);

         pObjRecv = NULL;

         if (nrecv > 0) {
            pObjRecv = &ObjRecv[0];
         }

         for (i = 0; i < nrecv; i++) {
            isize = phblk_recv[i].GetPackedSize ();
            pObjRecv[i].resize ((size_t) isize);
            pobj = &(pObjRecv[i][0]);
            phblk_recv[i].FillPacked_thr (isize, pobj);
            phblk_recv[i].Clean ();
         }

// Exchange data back

         CMPIDataExchange::DataExchange (_comm, CpuIDRecv, ObjRecv, CpuIDSend, ObjSend);

// Free send data

         {
            vector < int >CpuIDSend_temp;
            vector < vector < char > >ObjSend_temp;
            CpuIDRecv.swap (CpuIDSend_temp);
            ObjRecv.swap (ObjSend_temp);
         }

// Unpack received data

         nrecv = (int) CpuIDSend.size ();

         pObjSend = NULL;
         if (nrecv > 0) {
            pObjSend = &ObjSend[0];
         }

         hblk_send.resize (nrecv + 1);

         phblk_send = &hblk_send[0];

         for (i = 0; i < nrecv; i++) {
            isize = (long long) pObjSend[i].size ();
            pobj = &(pObjSend[i][0]);
            phblk_send[i].UnPack_thr (isize, pobj);
         }

// Free recv data

         {
            vector < int >CpuIDRecv_temp;
            vector < vector < char > >ObjRecv_temp;
            CpuIDSend.swap (CpuIDRecv_temp);
            ObjSend.swap (ObjRecv_temp);
         }

// Combine received data into the new lists

         icycletot++;

         int nlisttot = 0;

         for (i = 0; i < nrecv; i++) {
            CMatrix < _Int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
            int nlist_sub = pA_sub->GetNlist ();
            _Int *plist_sub = pA_sub->GetListArr ();
            for (j = 0; j < nlist_sub; j++) {
               int jj2 = (int) plist_sub[j];
               if (pimasktot[jj2] != icycletot) {
                  plisttot[nlisttot] = jj2;
                  nlisttot++;
                  pimasktot[jj2] = icycletot;
               }
            }
         }

         sort (plisttot, plisttot + nlisttot);

         for (i = 0; i < nlisttot; i++) {
            int jj2 = plisttot[i];
            pindtot[jj2] = i;
         }

         vector < int >nz_list_new (nlisttot + 1);
         int *pnz_list_new = &nz_list_new[0];

         for (i = 0; i < nlisttot; i++)
            pnz_list_new[i] = 0;

         for (i = 0; i < nrecv; i++) {
            CMatrix < _Int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
            int nlist_sub = pA_sub->GetNlist ();
            _Int *plist_sub = pA_sub->GetListArr ();
            _Int *pia_sub = pA_sub->GetIaArr ();
            for (j = 0; j < nlist_sub; j++) {
               int jj2 = (int) plist_sub[j];
               int ind = (int) pindtot[jj2];
               pnz_list_new[ind] += (int) (pia_sub[j + 1] - pia_sub[j]);
            }
         }

         vector < vector < int > >list_new (nlisttot + 1);
         vector < int >*plist_new = &list_new[0];

         for (i = 0; i < nlisttot; i++) {
            plist_new[i].resize (2 * pnz_list_new[i] + 1);
         }

         for (i = 0; i < nlisttot; i++)
            pnz_list_new[i] = 0;

         for (i = 0; i < nrecv; i++) {
            CMatrix < _Int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
            int nlist_sub = pA_sub->GetNlist ();
            _Int *plist_sub = pA_sub->GetListArr ();
            _Int *pia_sub = pA_sub->GetIaArr ();
            _Int *pja_sub = pA_sub->GetJaArr ();
            _Int *pja2_sub = pA_sub->GetJa2Arr ();
            int kj;
            for (j = 0; j < nlist_sub; j++) {
               int jj2 = (int) plist_sub[j];
               int ind = (int) pindtot[jj2];
               int k = (int) pnz_list_new[ind];
               int *pplist_new = &(plist_new[ind][0]);
               for (kj = (int) pia_sub[j]; kj < pia_sub[j + 1]; kj++) {
                  int kk = (int) pja_sub[kj];
                  int kk2 = (int) pja2_sub[kj];
                  pplist_new[k * 2] = kk;
                  pplist_new[k * 2 + 1] = kk2;
                  k++;
               }
               pnz_list_new[ind] = k;
            }
         }

// Sort and filter

         {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nlisttot; ipar++) {

               int j, iblk;

// Sort and filter coincident and own block numbers

               iblk = plisttot[ipar];
               int *pplist_new = NULL;
               if (pnz_list_new[ipar] > 0)
                  pplist_new = &(plist_new[ipar][0]);
               vector < CSortInt2 > ii2arr (pnz_list_new[ipar] + 1);
               CSortInt2 *pii2arr = &ii2arr[0];
               for (j = 0; j < pnz_list_new[ipar]; j++) {
                  pii2arr[j].ixval = pplist_new[j * 2 + 1];
                  pii2arr[j].iyval = pplist_new[j * 2];
                  pii2arr[j].itail = j;
               }
               sort (pii2arr, pii2arr + pnz_list_new[ipar]);
               int nznew = 0;
               int ix_prev = -1;
               int iy_prev = -1;
               int ix_curr, iy_curr;
               for (j = 0; j < pnz_list_new[ipar]; j++) {
                  ix_curr = pii2arr[j].ixval;
                  iy_curr = pii2arr[j].iyval;
                  if (ix_curr != iblk && (ix_curr != ix_prev || iy_curr != iy_prev)) {
                     pii2arr[nznew].ixval = ix_curr;
                     pii2arr[nznew].iyval = iy_curr;
                     pii2arr[nznew].itail = nznew;
                     nznew++;
                     ix_prev = ix_curr;
                     iy_prev = iy_curr;
                  }
               }

// Filter by previous data and extend previous sorted list data

               int *pplist_arr = NULL;
               if (pnlist_arr[iblk] > 0)
                  pplist_arr = &(plist_arr[iblk][0]);

               vector < int >list_add (2 * (pnlist_arr[iblk] + nznew) + 1);
               vector < int >list_flt (2 * nznew + 1);

               int *plist_add = &list_add[0];
               int *plist_flt = &list_flt[0];

               int nlistadd = 0;
               int nlistflt = 0;

               int ip = 0;
               int ip_new = 0;

               while (ip < pnlist_arr[iblk] || ip_new < nznew) {
                  if (ip < pnlist_arr[iblk] && ip_new < nznew) {
                     int jj = pplist_arr[2 * ip];
                     int jj2 = pplist_arr[2 * ip + 1];
                     int jj_new = pii2arr[ip_new].iyval;
                     int jj2_new = pii2arr[ip_new].ixval;
                     if (jj == jj_new && jj2 == jj2_new) {
                        plist_add[2 * nlistadd] = jj;
                        plist_add[2 * nlistadd + 1] = jj2;
                        nlistadd++;
                        ip++;
                        ip_new++;
                     } else if (jj2 < jj2_new || (jj2 == jj2_new && jj < jj_new)) {
                        plist_add[2 * nlistadd] = jj;
                        plist_add[2 * nlistadd + 1] = jj2;
                        nlistadd++;
                        ip++;
                     } else {
                        plist_add[2 * nlistadd] = jj_new;
                        plist_add[2 * nlistadd + 1] = jj2_new;
                        nlistadd++;
                        plist_flt[2 * nlistflt] = jj_new;
                        plist_flt[2 * nlistflt + 1] = jj2_new;
                        nlistflt++;
                        ip_new++;
                     }
                  } else if (ip < pnlist_arr[iblk]) {
                     plist_add[2 * nlistadd] = pplist_arr[2 * ip];
                     plist_add[2 * nlistadd + 1] = pplist_arr[2 * ip + 1];
                     nlistadd++;
                     ip++;
                  } else {
                     plist_add[2 * nlistadd] = pii2arr[ip_new].iyval;
                     plist_add[2 * nlistadd + 1] = pii2arr[ip_new].ixval;
                     nlistadd++;
                     plist_flt[2 * nlistflt] = pii2arr[ip_new].iyval;
                     plist_flt[2 * nlistflt + 1] = pii2arr[ip_new].ixval;
                     nlistflt++;
                     ip_new++;
                  }
               }

// Replace

               pnlist_arr[iblk] = nlistadd;
               pnlist_arr_prev[iblk] = nlistflt;

               plist_arr[iblk].swap (list_add);
               plist_arr_prev[iblk].swap (list_flt);

            }

         }

      }

// Prepare final data

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            int nz_tot = 0;
            for (iblk = _hblk2blk[ihblk]; iblk < _hblk2blk[ihblk + 1]; iblk++) {
               nz_tot += pnlist_arr[iblk];
            }
            vector < CSortInt2 > ii2arr (nz_tot + 1);
            CSortInt2 *pii2arr = &ii2arr[0];
            nz_tot = 0;
            int j;
            for (iblk = _hblk2blk[ihblk]; iblk < _hblk2blk[ihblk + 1]; iblk++) {
               int *pplist_arr = NULL;
               if (pnlist_arr[iblk] > 0)
                  pplist_arr = &(plist_arr[iblk][0]);
               for (j = 0; j < pnlist_arr[iblk]; j++) {
                  pii2arr[nz_tot].ixval = pplist_arr[j * 2 + 1];
                  pii2arr[nz_tot].iyval = pplist_arr[j * 2];
                  pii2arr[nz_tot].itail = j;
                  nz_tot++;
               }
            }
            sort (pii2arr, pii2arr + nz_tot);
            int nznew = 0;
            int ix_prev = -1;
            int iy_prev = -1;
            int ix_curr, iy_curr;
            for (j = 0; j < nz_tot; j++) {
               ix_curr = pii2arr[j].ixval;
               iy_curr = pii2arr[j].iyval;
               if (ix_curr != iblk && (ix_curr != ix_prev || iy_curr != iy_prev)) {
                  pii2arr[nznew].ixval = ix_curr;
                  pii2arr[nznew].iyval = iy_curr;
                  pii2arr[nznew].itail = nznew;
                  nznew++;
                  ix_prev = ix_curr;
                  iy_prev = iy_curr;
               }
            }
            _nlist_ext_arr[ihblk] = nznew;
            _list_ext_arr[ihblk].resize (2 * nznew + 1);
            int *pplist_ext = &(_list_ext_arr[ihblk][0]);
            for (j = 0; j < nznew; j++) {
               pplist_ext[j * 2] = pii2arr[j].iyval;
               pplist_ext[j * 2 + 1] = pii2arr[j].ixval;
            }
         }
      }

   }

// Get the extended submatrices
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::GetExtendedSubmatrices (void *_comm, int _nblks, long long *_blks,
                                      int *_blk2cpu, CBMatrix < _Int, _Flt > *_hmatr_arr,
                                      int *_nlist_ext_arr, vector < int >*_list_ext_arr,
                                      CMatrix < _Int, _Flt > *_matr_ext_arr)
   {

      int myid = CMPIDataExchange::GetMyid (_comm);
      int nproc = CMPIDataExchange::GetNproc (_comm);

// Compute the maximal block size

      int nimax = 0;

      int i;
      int niloc;

      for (i = 0; i < _nblks; i++) {
         niloc = (int) (_blks[i + 1] - _blks[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

      vector < int >imaskblk (nimax + 1);
      vector < int >listblk (nimax + 1);
      vector < int >iablk (nimax + 1);

      int *pimaskblk = &imaskblk[0];
      int *piablk = &iablk[0];

      int icycleblk = -1;

      for (i = 0; i < nimax; i++)
         pimaskblk[i] = icycleblk;

// Compute data as two index rows block structures

      vector < CMatrix < _Int, _Flt > >blkrows (_nblks);
      CMatrix < _Int, _Flt > *pblkrows = &blkrows[0];

      int nzjanew, ind, kj;
      int iblk, j, jj, k, kk, nlistnew;

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[iblk].GetASubArr ();
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[iblk].GetHMatrStr ();
            int nzja_hmatr = pHMatr_sub->GetNzja ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            nzjanew = 0;
            for (j = 0; j < nzja_hmatr; j++) {
               nzjanew += pA_sub[j].GetNzja ();
            }
            nlistnew = (int) (_blks[iblk + 1] - _blks[iblk]);
            CMatrix < _Int, _Flt > anew;
            anew.ResizeAndSetAll (nlistnew, nlistnew, nzjanew, nzjanew, nzjanew);
            _Int *plist_new = anew.GetListArr ();
            _Int *plist2_new = anew.GetList2Arr ();
            _Int *pia_new = anew.GetIaArr ();
            _Int *pja_new = anew.GetJaArr ();
            _Int *pja2_new = anew.GetJa2Arr ();
            _Flt *pa_new = anew.GetAArr ();
            for (j = 0; j < nlistnew; j++)
               plist_new[j] = (_Int) j;
            for (j = 0; j < nlistnew; j++)
               plist2_new[j] = (_Int) iblk;
            for (j = 0; j <= nlistnew; j++)
               pia_new[j] = 0;
            for (j = 0; j < nzja_hmatr; j++) {
               int nlistloc = pA_sub[j].GetNlist ();
               _Int *plistloc = pA_sub[j].GetListArr ();
               _Int *pialoc = pA_sub[j].GetIaArr ();
               for (k = 0; k < nlistloc; k++) {
                  kk = (int) plistloc[k];
                  pia_new[kk + 1] += (pialoc[k + 1] - pialoc[k]);
               }
            }
            for (j = 0; j < nlistnew; j++)
               pia_new[j + 1] = pia_new[j] + pia_new[j + 1];
            for (j = 0; j < nlistnew; j++)
               piablk[j] = (int) pia_new[j];
            for (j = 0; j < nzja_hmatr; j++) {
               jj = pja_hmatr[j];
               int nlistloc = pA_sub[j].GetNlist ();
               _Int *plistloc = pA_sub[j].GetListArr ();
               _Int *pialoc = pA_sub[j].GetIaArr ();
               _Int *pjaloc = pA_sub[j].GetJaArr ();
               _Flt *paloc = pA_sub[j].GetAArr ();
               for (k = 0; k < nlistloc; k++) {
                  kk = (int) plistloc[k];
                  ind = (int) piablk[kk];
                  for (kj = (int) pialoc[k]; kj < pialoc[k + 1]; kj++) {
                     pja_new[ind] = pjaloc[kj];
                     pja2_new[ind] = jj;
                     pa_new[ind] = paloc[kj];
                     ind++;
                  }
                  piablk[kk] = ind;
               }
            }
            pblkrows[iblk].ReplaceFree (anew);
         }
      }

// Create mask data

      int icyclecpu = -1;

      vector < int >imaskcpu (nproc);
      vector < int >listcpu (nproc);
      vector < int >indcpu (nproc);

      int *pimaskcpu = &imaskcpu[0];
      int *plistcpu = &listcpu[0];
      int *pindcpu = &indcpu[0];

      for (i = 0; i < nproc; i++) {
         pimaskcpu[i] = icyclecpu;
      }

      int icycletot = -1;

      vector < int >imasktot (_nblks);
      vector < int >listtot (_nblks);
      vector < int >indtot (_nblks);
      vector < int >indtot2 (_nblks);

      int *pimasktot = &imasktot[0];
      int *plisttot = &listtot[0];
      int *pindtot = &indtot[0];
      int *pindtot2 = &indtot2[0];

      for (i = 0; i < _nblks; i++) {
         pimasktot[i] = icycletot;
      }

// Create list of cpus and count sizes

      icyclecpu++;

      int nlistcpu = 0;

      int jj2, jcpu;

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            int *pplist_ext_arr = &(_list_ext_arr[iblk][0]);
            for (j = 0; j < _nlist_ext_arr[iblk]; j++) {
               jj2 = (int) pplist_ext_arr[j * 2 + 1];
               jcpu = _blk2cpu[jj2];
               if (pimaskcpu[jcpu] != icyclecpu) {
                  plistcpu[nlistcpu] = jcpu;
                  nlistcpu++;
                  pimaskcpu[jcpu] = icyclecpu;
               }
            }
         }
      }

      sort (plistcpu, plistcpu + nlistcpu);

      for (i = 0; i < nlistcpu; i++) {
         jcpu = plistcpu[i];
         pindcpu[jcpu] = i;
      }

      vector < int >nz_send (nlistcpu + 1);

      int *pnz_send = &nz_send[0];

      for (i = 0; i < nlistcpu; i++)
         pnz_send[i] = 0;

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            int *pplist_ext_arr = &(_list_ext_arr[iblk][0]);
            for (j = 0; j < _nlist_ext_arr[iblk]; j++) {
               jj2 = pplist_ext_arr[j * 2 + 1];
               jcpu = _blk2cpu[jj2];
               ind = pindcpu[jcpu];
               pnz_send[ind]++;
            }
         }
      }

// Prepare send data

      vector < CBMatrix < _Int, _Flt > >hblk_send (nlistcpu + 1);

      CBMatrix < _Int, _Flt > *phblk_send = &hblk_send[0];

      for (i = 0; i < nlistcpu; i++) {
         phblk_send[i].SetNzblk (1);
         phblk_send[i].ResizeASub (1);
         CMatrix < _Int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
         CMatrix < _Int, _Flt > ablk_temp;
         ablk_temp.ResizeAndSetAllSp (0, 0, 3 * pnz_send[i], 0);
         pA_sub->ReplaceFree (ablk_temp);
      }

      for (i = 0; i < nlistcpu; i++)
         pnz_send[i] = 0;

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            int *pplist_ext_arr = &(_list_ext_arr[iblk][0]);
            for (j = 0; j < _nlist_ext_arr[iblk]; j++) {
               jj = (int) pplist_ext_arr[j * 2];
               jj2 = (int) pplist_ext_arr[j * 2 + 1];
               jcpu = _blk2cpu[jj2];
               ind = pindcpu[jcpu];
               CMatrix < _Int, _Flt > *pA_sub = phblk_send[ind].GetASubArr ();
               _Int *pja_asub = pA_sub->GetJaArr ();
               k = pnz_send[ind];
               pja_asub[3 * k] = iblk;
               pja_asub[3 * k + 1] = jj;
               pja_asub[3 * k + 2] = jj2;
               pnz_send[ind]++;
            }
         }
      }

// Pack send data

      vector < int >CpuIDSend (nlistcpu);
      vector < vector < char > >ObjSend (nlistcpu);

      int *pCpuIDSend = NULL;
      vector < char >*pObjSend = NULL;

      if (nlistcpu > 0) {
         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];
      }

      long long isize;
      char *pobj;

      for (i = 0; i < nlistcpu; i++) {
         pCpuIDSend[i] = plistcpu[i];
         isize = phblk_send[i].GetPackedSize ();
         pObjSend[i].resize ((size_t) isize);
         pobj = &(pObjSend[i][0]);
         phblk_send[i].FillPacked (isize, pobj);
         phblk_send[i].Clean ();
      }

// Exchange

      vector < int >CpuIDRecv;
      vector < vector < char > >ObjRecv;

      CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      int nrecv = (int) CpuIDRecv.size ();

      vector < char >*pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      vector < CBMatrix < _Int, _Flt > >hblk_recv (nrecv + 1);

      CBMatrix < _Int, _Flt > *phblk_recv = &hblk_recv[0];

      for (i = 0; i < nrecv; i++) {
         isize = (long long) pObjRecv[i].size ();
         pobj = &(pObjRecv[i][0]);
         phblk_recv[i].UnPack (isize, pobj);
      }

// Free recv data

      {
         vector < vector < char > >ObjRecv_temp;
         ObjRecv.swap (ObjRecv_temp);
      }

// Prepare the answer for all received data

      for (i = 0; i < nrecv; i++) {
         CMatrix < _Int, _Flt > *pA_sub = phblk_recv[i].GetASubArr ();
         int nzjaloc = pA_sub->GetNzja ();
         _Int *pja_sub = pA_sub->GetJaArr ();
         int nlistloc = nzjaloc / 3;
         int nzja_new = 0;
         for (j = 0; j < nlistloc; j++) {
            jj = (int) pja_sub[j * 3 + 1];
            jj2 = (int) pja_sub[j * 3 + 2];
            _Int *pia_rows = pblkrows[jj2].GetIaArr ();
            nzja_new += (int) (pia_rows[jj + 1] - pia_rows[jj]);
         }
         CMatrix < _Int, _Flt > a_new;
         a_new.ResizeAndSetAll (nlistloc, nlistloc * 2, nzja_new, nzja_new, nzja_new);
         _Int *plist_new = a_new.GetListArr ();
         _Int *plist2_new = a_new.GetList2Arr ();
         _Int *pia_new = a_new.GetIaArr ();
         _Int *pja_new = a_new.GetJaArr ();
         _Int *pja2_new = a_new.GetJa2Arr ();
         _Flt *pa_new = a_new.GetAArr ();
         nzja_new = 0;
         pia_new[0] = 0;
         for (j = 0; j < nlistloc; j++) {
            plist_new[j] = pja_sub[j * 3];
            jj = (int) pja_sub[j * 3 + 1];
            jj2 = (int) pja_sub[j * 3 + 2];
            plist2_new[j * 2] = jj;
            plist2_new[j * 2 + 1] = jj2;
            _Int *pia_rows = pblkrows[jj2].GetIaArr ();
            _Int *pja_rows = pblkrows[jj2].GetJaArr ();
            _Int *pja2_rows = pblkrows[jj2].GetJa2Arr ();
            _Flt *pa_rows = pblkrows[jj2].GetAArr ();
            for (k = (int) pia_rows[jj]; k < pia_rows[jj + 1]; k++) {
               pja_new[nzja_new] = pja_rows[k];
               pja2_new[nzja_new] = pja2_rows[k];
               pa_new[nzja_new] = pa_rows[k];
               nzja_new++;
            }
            pia_new[j + 1] = nzja_new;
         }
         pA_sub->ReplaceFree (a_new);
      }

// Pack send data

      ObjRecv.resize (nrecv);

      pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      for (i = 0; i < nrecv; i++) {
         isize = phblk_recv[i].GetPackedSize ();
         pObjRecv[i].resize ((size_t) isize);
         pobj = &(pObjRecv[i][0]);
         phblk_recv[i].FillPacked (isize, pobj);
         phblk_recv[i].Clean ();
      }

// Exchange data back

      CMPIDataExchange::DataExchange (_comm, CpuIDRecv, ObjRecv, CpuIDSend, ObjSend);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDRecv.swap (CpuIDSend_temp);
         ObjRecv.swap (ObjSend_temp);
      }

// Unpack receive data

      nrecv = (int) CpuIDSend.size ();

      pObjSend = NULL;

      if (nrecv > 0) {
         pObjSend = &ObjSend[0];
      }

      hblk_send.resize (nrecv + 1);

      phblk_send = &hblk_send[0];

      for (i = 0; i < nrecv; i++) {
         isize = (long long) pObjSend[i].size ();
         pobj = &(pObjSend[i][0]);
         phblk_send[i].UnPack (isize, pobj);
      }

// Free recv data

      {
         vector < int >CpuIDRecv_temp;
         vector < vector < char > >ObjRecv_temp;
         CpuIDSend.swap (CpuIDRecv_temp);
         ObjSend.swap (ObjRecv_temp);
      }

// Combine received data into the new lists and add local data

      icycletot++;

      int nlisttot = 0;

      for (i = 0; i < nrecv; i++) {
         CMatrix < _Int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
         int nlist_sub = pA_sub->GetNlist ();
         _Int *plist_sub = pA_sub->GetListArr ();
         for (j = 0; j < nlist_sub; j++) {
            jj2 = (int) plist_sub[j];
            if (pimasktot[jj2] != icycletot) {
               plisttot[nlisttot] = jj2;
               nlisttot++;
               pimasktot[jj2] = icycletot;
            }
         }
      }

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            if (pimasktot[iblk] != icycletot) {
               plisttot[nlisttot] = iblk;
               nlisttot++;
               pimasktot[iblk] = icycletot;
            }
         }
      }

      sort (plisttot, plisttot + nlisttot);

      for (i = 0; i < nlisttot; i++) {
         jj2 = (int) plisttot[i];
         pindtot[jj2] = i;
      }

      vector < int >nlist_new (_nblks);
      vector < int >nz_list_new (_nblks);

      int *pnlist_new = &nlist_new[0];
      int *pnz_list_new = &nz_list_new[0];

      for (i = 0; i < _nblks; i++)
         pnlist_new[i] = 0;
      for (i = 0; i < _nblks; i++)
         pnz_list_new[i] = 0;

      for (i = 0; i < nrecv; i++) {
         CMatrix < _Int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
         int nlist_sub = pA_sub->GetNlist ();
         _Int *plist_sub = pA_sub->GetListArr ();
         _Int *pia_sub = pA_sub->GetIaArr ();
         for (j = 0; j < nlist_sub; j++) {
            jj2 = (int) plist_sub[j];
            pnlist_new[jj2]++;
            pnz_list_new[jj2] += (int) (pia_sub[j + 1] - pia_sub[j]);
         }
      }

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            int nlistloc = pblkrows[iblk].GetNlist ();
            int nzjaloc = pblkrows[iblk].GetNzja ();
            pnlist_new[iblk] += nlistloc;
            pnz_list_new[iblk] += nzjaloc;
         }
      }

      vector < CMatrix < _Int, _Flt > >matr_arr_new (_nblks);
      CMatrix < _Int, _Flt > *pmatr_arr_new = &matr_arr_new[0];

      for (i = 0; i < nlisttot; i++) {
         iblk = plisttot[i];
         pmatr_arr_new[iblk].ResizeAndSetAll (pnlist_new[iblk], pnlist_new[iblk],
                                              pnz_list_new[iblk], pnz_list_new[iblk],
                                              pnz_list_new[iblk]);
         _Int *pia_new = pmatr_arr_new[iblk].GetIaArr ();
         pia_new[0] = 0;
         pnlist_new[iblk] = 0;
         pnz_list_new[iblk] = 0;
      }

// Fill received data

      int kk2;

      for (i = 0; i < nrecv; i++) {
         CMatrix < _Int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
         int nlist_sub = pA_sub->GetNlist ();
         _Int *plist_sub = pA_sub->GetListArr ();
         _Int *plist2_sub = pA_sub->GetList2Arr ();
         _Int *pia_sub = pA_sub->GetIaArr ();
         _Int *pja_sub = pA_sub->GetJaArr ();
         _Int *pja2_sub = pA_sub->GetJa2Arr ();
         _Flt *pa_sub = pA_sub->GetAArr ();
         for (j = 0; j < nlist_sub; j++) {
            jj2 = (int) plist_sub[j];
            _Int *plist_new = pmatr_arr_new[jj2].GetListArr ();
            _Int *plist2_new = pmatr_arr_new[jj2].GetList2Arr ();
            _Int *pia_new = pmatr_arr_new[jj2].GetIaArr ();
            _Int *pja_new = pmatr_arr_new[jj2].GetJaArr ();
            _Int *pja2_new = pmatr_arr_new[jj2].GetJa2Arr ();
            _Flt *pa_new = pmatr_arr_new[jj2].GetAArr ();
            k = (int) pnlist_new[jj2];
            plist_new[k] = plist2_sub[j * 2];
            plist2_new[k] = plist2_sub[j * 2 + 1];
            pia_new[k + 1] = pia_new[k] + (pia_sub[j + 1] - pia_sub[j]);
            pnlist_new[jj2]++;
            k = (int) pnz_list_new[jj2];
            for (kj = (int) pia_sub[j]; kj < pia_sub[j + 1]; kj++) {
               kk = (int) pja_sub[kj];
               kk2 = (int) pja2_sub[kj];
               pja_new[k] = kk;
               pja2_new[k] = kk2;
               pa_new[k] = pa_sub[kj];
               k++;
            }
            pnz_list_new[jj2] = k;
         }
      }

// Add own data

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {
            int nlist_sub = pblkrows[iblk].GetNlist ();
            _Int *plist_sub = pblkrows[iblk].GetListArr ();
            _Int *plist2_sub = pblkrows[iblk].GetList2Arr ();
            _Int *pia_sub = pblkrows[iblk].GetIaArr ();
            _Int *pja_sub = pblkrows[iblk].GetJaArr ();
            _Int *pja2_sub = pblkrows[iblk].GetJa2Arr ();
            _Flt *pa_sub = pblkrows[iblk].GetAArr ();
            _Int *plist_new = pmatr_arr_new[iblk].GetListArr ();
            _Int *plist2_new = pmatr_arr_new[iblk].GetList2Arr ();
            _Int *pia_new = pmatr_arr_new[iblk].GetIaArr ();
            _Int *pja_new = pmatr_arr_new[iblk].GetJaArr ();
            _Int *pja2_new = pmatr_arr_new[iblk].GetJa2Arr ();
            _Flt *pa_new = pmatr_arr_new[iblk].GetAArr ();
            for (j = 0; j < nlist_sub; j++) {
               k = (int) pnlist_new[iblk];
               plist_new[k] = plist_sub[j];
               plist2_new[k] = plist2_sub[j];
               pia_new[k + 1] = pia_new[k] + (pia_sub[j + 1] - pia_sub[j]);
               pnlist_new[iblk]++;
               k = (int) pnz_list_new[iblk];
               for (kj = (int) pia_sub[j]; kj < pia_sub[j + 1]; kj++) {
                  kk = (int) pja_sub[kj];
                  kk2 = (int) pja2_sub[kj];
                  pja_new[k] = kk;
                  pja2_new[k] = kk2;
                  pa_new[k] = pa_sub[kj];
                  k++;
               }
               pnz_list_new[iblk] = k;
            }
         }
      }

// Perform filtering and renumbering of the extended data

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == myid) {

            int nlist_new = pmatr_arr_new[iblk].GetNlist ();
            int nzja_new = pmatr_arr_new[iblk].GetNzja ();
            _Int *plist_new = pmatr_arr_new[iblk].GetListArr ();
            _Int *plist2_new = pmatr_arr_new[iblk].GetList2Arr ();
            _Int *pia_new = pmatr_arr_new[iblk].GetIaArr ();
            _Int *pja_new = pmatr_arr_new[iblk].GetJaArr ();
            _Int *pja2_new = pmatr_arr_new[iblk].GetJa2Arr ();
            _Flt *pa_new = pmatr_arr_new[iblk].GetAArr ();
            icycletot++;
            nlisttot = 0;
            for (j = 0; j < nlist_new; j++) {
               jj2 = (int) plist2_new[j];
               if (pimasktot[jj2] != icycletot) {
                  plisttot[nlisttot] = jj2;
                  nlisttot++;
                  pimasktot[jj2] = icycletot;
               }
            }

            sort (plisttot, plisttot + nlisttot);

            int jblk;

            for (j = 0; j < nlisttot; j++) {
               jblk = (int) plisttot[j];
               pindtot2[jblk] = j;
            }

            vector < int >ia_list (nlisttot + 1);
            vector < int >ja_list (nlist_new + 1);
            vector < int >iptr (nlisttot + 1);

            int *pia_list = &ia_list[0];
            int *pja_list = &ja_list[0];
            int *piptr = &iptr[0];

            for (j = 0; j <= nlisttot; j++)
               pia_list[j] = 0;

            for (j = 0; j < nlist_new; j++) {
               jj2 = (int) plist2_new[j];
               ind = pindtot2[jj2];
               pia_list[ind + 1]++;
            }

            for (j = 0; j < nlisttot; j++)
               pia_list[j + 1] = pia_list[j] + pia_list[j + 1];
            for (j = 0; j < nlisttot; j++)
               piptr[j] = pia_list[j];

            for (j = 0; j < nlist_new; j++) {
               jj = (int) plist_new[j];
               jj2 = (int) plist2_new[j];
               ind = (int) pindtot2[jj2];
               k = (int) piptr[ind];
               pja_list[k] = jj;
               piptr[ind]++;
            }

            for (j = 0; j < nlisttot; j++) {
               sort (pja_list + pia_list[j], pja_list + pia_list[j + 1]);
            }

            vector < int >imask_elems (nzja_new + 1);
            vector < int >ia_elems (nlisttot + 1);
            vector < int >ind_elems (nzja_new + 1);

            int *pimask_elems = &imask_elems[0];
            int *pia_elems = &ia_elems[0];
            int *pind_elems = &ind_elems[0];

            for (j = 0; j < nzja_new; j++)
               pimask_elems[j] = -1;
            for (j = 0; j <= nlisttot; j++)
               pia_elems[j] = 0;

            for (j = 0; j < nzja_new; j++) {
               jj2 = (int) pja2_new[j];
               if (pimasktot[jj2] == icycletot) {
                  ind = pindtot2[jj2];
                  pia_elems[ind + 1]++;
               }
            }

            for (j = 0; j < nlisttot; j++)
               pia_elems[j + 1] = pia_elems[j] + pia_elems[j + 1];

            for (j = 0; j < nlisttot; j++)
               piptr[j] = pia_elems[j];

            for (j = 0; j < nzja_new; j++) {
               jj2 = (int) pja2_new[j];
               if (pimasktot[jj2] == icycletot) {
                  ind = (int) pindtot2[jj2];
                  k = (int) piptr[ind];
                  pind_elems[k] = j;
                  piptr[ind]++;
               }
            }

            for (j = 0; j < nlisttot; j++) {
               icycleblk++;
               for (k = pia_list[j]; k < pia_list[j + 1]; k++) {
                  kk = (int) pja_list[k];
                  pimaskblk[kk] = icycleblk;
                  piablk[kk] = k;
               }
               for (k = pia_elems[j]; k < pia_elems[j + 1]; k++) {
                  ind = (int) pind_elems[k];
                  jj = (int) pja_new[ind];
                  if (pimaskblk[jj] == icycleblk) {
                     pimask_elems[ind] = piablk[jj];
                  }
               }
            }

            int nzja_flt = 0;

            for (j = 0; j < nzja_new; j++) {
               if (pimask_elems[j] >= 0)
                  nzja_flt++;
            }

            CMatrix < _Int, _Flt > a_flt;

            a_flt.ResizeAndSetAll (nlist_new, 0, nzja_flt, 0, nzja_flt);

            _Int *plist_flt = a_flt.GetListArr ();
            _Int *pia_flt = a_flt.GetIaArr ();
            _Int *pja_flt = a_flt.GetJaArr ();
            _Flt *pa_flt = a_flt.GetAArr ();

            for (j = 0; j < nlist_new; j++)
               plist_flt[j] = (_Int) j;

            nzja_flt = 0;
            pia_flt[0] = 0;

            for (i = 0; i < nlist_new; i++) {
               for (j = (int) pia_new[i]; j < pia_new[i + 1]; j++) {
                  if (pimask_elems[j] >= 0) {
                     pja_flt[nzja_flt] = pimask_elems[j];
                     pa_flt[nzja_flt] = pa_new[j];
                     nzja_flt++;
                  }
               }
               pia_flt[i + 1] = nzja_flt;
            }

            int njmax = 0;

            int njloc = 0;

            for (j = 0; j < nlist_new; j++) {
               njloc = (int) (pia_flt[j + 1] - pia_flt[j]);
               if (njloc > njmax)
                  njmax = njloc;
            }

            vector < CSortInt > iiarr (njmax + 1);
            vector < _Flt > elems (njmax + 1);

            CSortInt *piiarr = &iiarr[0];
            _Flt *pelems = &elems[0];

            int ibeg, jloc;

            for (i = 0; i < nlist_new; i++) {
               ibeg = (int) pia_flt[i];
               njloc = (int) (pia_flt[i + 1] - pia_flt[i]);
               for (j = (int) pia_flt[i]; j < pia_flt[i + 1]; j++) {
                  jloc = j - ibeg;
                  piiarr[jloc].ival = (int) pja_flt[j];
                  piiarr[jloc].i2val = jloc;
                  pelems[jloc] = pa_flt[j];
               }
               sort (piiarr, piiarr + njloc);
               for (j = (int) pia_flt[i]; j < pia_flt[i + 1]; j++) {
                  jloc = j - ibeg;
                  pja_flt[j] = piiarr[jloc].ival;
                  pa_flt[j] = pelems[piiarr[jloc].i2val];
               }
            }

            _matr_ext_arr[iblk].ReplaceFree (a_flt);

         }
      }

   }

// Get the extended submatrices
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::GetExtendedSubmatrices (void *_comm, int _nhblks, int *_hblk2cpu,
                                      int *_hblk2blk, int *_blk2hblk, int _nblks,
                                      long long *_blks, CBMatrix < _Int,
                                      _Flt > *_hmatr_arr, int *_nblks_ext_arr,
                                      vector < int >*_blksnum_ext_arr,
                                      vector < long long >*_pblks_ext_arr,
                                      int *_nlist_ext_arr, vector < int >*_list_ext_arr,
                                      CBMatrix < _Int, _Flt > *_hmatr_ext_arr)
   {

      int myid = CMPIDataExchange::GetMyid (_comm);
      int nproc = CMPIDataExchange::GetNproc (_comm);

// Compute the maximal block size

      int nimax = 0;

      int i;
      int niloc;

      for (i = 0; i < _nblks; i++) {
         niloc = (int) (_blks[i + 1] - _blks[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

// Compute data as two index rows block structures

      vector < CMatrix < _Int, _Flt > >blkrows (_nblks);
      CMatrix < _Int, _Flt > *pblkrows = &blkrows[0];

      int ihblk;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[ihblk].GetASubArr ();
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nlist_hmatr; ipar++) {

               int nzjanew, ind, kj;
               int iblkgl, jblkgl, j, jj, jj2, k, kk, nlistnew;

               nzjanew = 0;
               for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
                  nzjanew += pA_sub[j].GetNzja ();
               }
               iblkgl = _hblk2blk[ihblk] + ipar;
               nlistnew = (int) (_blks[iblkgl + 1] - _blks[iblkgl]);
               CMatrix < _Int, _Flt > anew;
               anew.ResizeAndSetAll (nlistnew, nlistnew, nzjanew, nzjanew, nzjanew);
               _Int *plist_new = anew.GetListArr ();
               _Int *plist2_new = anew.GetList2Arr ();
               _Int *pia_new = anew.GetIaArr ();
               _Int *pja_new = anew.GetJaArr ();
               _Int *pja2_new = anew.GetJa2Arr ();
               _Flt *pa_new = anew.GetAArr ();
               for (j = 0; j < nlistnew; j++)
                  plist_new[j] = (_Int) j;
               for (j = 0; j < nlistnew; j++)
                  plist2_new[j] = (_Int) iblkgl;
               for (j = 0; j <= nlistnew; j++)
                  pia_new[j] = 0;
               for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
                  int nlistloc = pA_sub[j].GetNlist ();
                  _Int *plistloc = pA_sub[j].GetListArr ();
                  _Int *pialoc = pA_sub[j].GetIaArr ();
                  for (k = 0; k < nlistloc; k++) {
                     kk = (int) plistloc[k];
                     pia_new[kk + 1] += (pialoc[k + 1] - pialoc[k]);
                  }
               }
               for (j = 0; j < nlistnew; j++)
                  pia_new[j + 1] = pia_new[j] + pia_new[j + 1];
               vector < int >iptr (nlistnew + 1);
               int *piptr = &iptr[0];
               for (j = 0; j < nlistnew; j++)
                  piptr[j] = (int) pia_new[j];
               for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
                  jj = pja_hmatr[j];
                  jj2 = pja2_hmatr[j];
                  jblkgl = _hblk2blk[jj2] + jj;
                  int nlistloc = pA_sub[j].GetNlist ();
                  _Int *plistloc = pA_sub[j].GetListArr ();
                  _Int *pialoc = pA_sub[j].GetIaArr ();
                  _Int *pjaloc = pA_sub[j].GetJaArr ();
                  _Flt *paloc = pA_sub[j].GetAArr ();
                  for (k = 0; k < nlistloc; k++) {
                     kk = (int) plistloc[k];
                     ind = (int) piptr[kk];
                     for (kj = (int) pialoc[k]; kj < pialoc[k + 1]; kj++) {
                        pja_new[ind] = pjaloc[kj];
                        pja2_new[ind] = jblkgl;
                        pa_new[ind] = paloc[kj];
                        ind++;
                     }
                     piptr[kk] = ind;
                  }
               }
               pblkrows[iblkgl].ReplaceFree (anew);
            }
         }
      }

// Create mask data

      int icyclecpu = -1;

      vector < int >imaskcpu (nproc);
      vector < int >listcpu (nproc);
      vector < int >indcpu (nproc);

      int *pimaskcpu = &imaskcpu[0];
      int *plistcpu = &listcpu[0];
      int *pindcpu = &indcpu[0];

      for (i = 0; i < nproc; i++) {
         pimaskcpu[i] = icyclecpu;
      }

// Create list of cpus

      icyclecpu++;

      int nlistcpu = 0;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            int nblks_temp = _hblk2blk[ihblk + 1] - _hblk2blk[ihblk];
            int *ppblksnum_ext_arr = &(_blksnum_ext_arr[ihblk][0]);
            int j;
            for (j = 0; j < _nblks_ext_arr[ihblk] - nblks_temp; j++) {
               int jj2 = (int) ppblksnum_ext_arr[j];
               int jhblk = _blk2hblk[jj2];
               int jcpu = _hblk2cpu[jhblk];
               if (pimaskcpu[jcpu] != icyclecpu) {
                  plistcpu[nlistcpu] = jcpu;
                  nlistcpu++;
                  pimaskcpu[jcpu] = icyclecpu;
               }
            }
         }
      }

      sort (plistcpu, plistcpu + nlistcpu);

      for (i = 0; i < nlistcpu; i++) {
         int jcpu = plistcpu[i];
         pindcpu[jcpu] = i;
      }

// For own hblocks form sets of blocks for exchange

      vector < vector < CMatrix < _Int, _Flt > > >blocks_send (_nhblks + 1);

      vector < CMatrix < _Int, _Flt > >*pblocks_send = &blocks_send[0];

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            int nblks_temp = _hblk2blk[ihblk + 1] - _hblk2blk[ihblk];
            pblocks_send[ihblk].resize (_nblks_ext_arr[ihblk] - nblks_temp + 1);
            CMatrix < _Int, _Flt > *ppblocks_send = &pblocks_send[ihblk][0];
            long long *ppblks_ext_arr = &(_pblks_ext_arr[ihblk][0]);
            int *pplist_ext_arr = &(_list_ext_arr[ihblk][0]);
            int i;
            for (i = 0; i < _nblks_ext_arr[ihblk] - nblks_temp; i++) {
               int nz_temp = (int) (ppblks_ext_arr[i + 1] - ppblks_ext_arr[i]);
               ppblocks_send[i].ResizeAndSetAllSp (0, 0, nz_temp, 0);
               _Int *pja_temp = ppblocks_send[i].GetJaArr ();
               long long ibeg = ppblks_ext_arr[i];
               int j;
               for (j = (int) ppblks_ext_arr[i]; j < ppblks_ext_arr[i + 1]; j++) {
                  pja_temp[j - ibeg] = pplist_ext_arr[j * 2];
               }
            }
         }
      }

// Reconfigure sets of blocks into small set of hblocks

      vector < int >nz_send (nlistcpu + 1);

      int *pnz_send = &nz_send[0];

      for (i = 0; i < nlistcpu; i++)
         pnz_send[i] = 0;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            int nblks_temp = _hblk2blk[ihblk + 1] - _hblk2blk[ihblk];
            int *ppblksnum_ext_arr = &(_blksnum_ext_arr[ihblk][0]);
            for (i = 0; i < _nblks_ext_arr[ihblk] - nblks_temp; i++) {
               int jj2 = ppblksnum_ext_arr[i];
               int jhblk = _blk2hblk[jj2];
               int jcpu = _hblk2cpu[jhblk];
               int ind = pindcpu[jcpu];
               pnz_send[ind]++;
            }
         }
      }

// Prepare send data

      vector < CBMatrix < _Int, _Flt > >hblk_send (nlistcpu + 1);

      CBMatrix < _Int, _Flt > *phblk_send = &hblk_send[0];

      for (i = 0; i < nlistcpu; i++) {
         int nz_temp = pnz_send[i];
         phblk_send[i].SetNzblk (nz_temp);
         phblk_send[i].ResizeASub (nz_temp);
         CMatrix < int, float >*p_hmatr = phblk_send[i].GetHMatrStr ();
         p_hmatr->ResizeAndSetAllSp (0, 3 * nz_temp, 0, 0);
      }

      for (i = 0; i < nlistcpu; i++)
         pnz_send[i] = 0;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            int *ppblksnum_ext_arr = &(_blksnum_ext_arr[ihblk][0]);
            int nblks_temp = _hblk2blk[ihblk + 1] - _hblk2blk[ihblk];
            CMatrix < _Int, _Flt > *ppblocks_send = &pblocks_send[ihblk][0];
            for (i = 0; i < _nblks_ext_arr[ihblk] - nblks_temp; i++) {
               int jj2 = ppblksnum_ext_arr[i];
               int jhblk = _blk2hblk[jj2];
               int jcpu = _hblk2cpu[jhblk];
               int ind = pindcpu[jcpu];
               CMatrix < int, float >*p_hmatr = phblk_send[ind].GetHMatrStr ();
               int *plist2_hmatr = p_hmatr->GetList2Arr ();
               CMatrix < _Int, _Flt > *pA_sub = phblk_send[ind].GetASubArr ();
               int k = pnz_send[ind];
               plist2_hmatr[3 * k] = ihblk;
               plist2_hmatr[3 * k + 1] = i;
               plist2_hmatr[3 * k + 2] = jj2;
               pA_sub[k].ReplaceFree (ppblocks_send[i]);
               pnz_send[ind]++;
            }
         }
      }

// Pack send data

      vector < int >CpuIDSend (nlistcpu);
      vector < vector < char > >ObjSend (nlistcpu);

      int *pCpuIDSend = NULL;
      vector < char >*pObjSend = NULL;

      if (nlistcpu > 0) {
         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];
      }

      long long isize;
      char *pobj;

      for (i = 0; i < nlistcpu; i++) {
         pCpuIDSend[i] = plistcpu[i];
         isize = phblk_send[i].GetPackedSize ();
         pObjSend[i].resize ((size_t) isize);
         pobj = &(pObjSend[i][0]);
         phblk_send[i].FillPacked_thr (isize, pobj);
         phblk_send[i].Clean ();
      }

// Exchange

      vector < int >CpuIDRecv;
      vector < vector < char > >ObjRecv;

      CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      int nrecv = (int) CpuIDRecv.size ();

      vector < char >*pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      vector < CBMatrix < _Int, _Flt > >hblk_recv (nrecv + 1);

      CBMatrix < _Int, _Flt > *phblk_recv = &hblk_recv[0];

      for (i = 0; i < nrecv; i++) {
         isize = (long long) pObjRecv[i].size ();
         pobj = &(pObjRecv[i][0]);
         phblk_recv[i].UnPack_thr (isize, pobj);
      }

// Free recv data

      {
         vector < vector < char > >ObjRecv_temp;
         ObjRecv.swap (ObjRecv_temp);
      }

// Prepare the answer for all received data

      int irecv;

      for (irecv = 0; irecv < nrecv; irecv++) {
         int nzblk = phblk_recv[irecv].GetNzblk ();
         CMatrix < int, float >*phmatr = phblk_recv[irecv].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub = phblk_recv[irecv].GetASubArr ();
         int *plist2_hmatr = phmatr->GetList2Arr ();
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nzblk; ipar++) {
            int jj2 = plist2_hmatr[3 * ipar + 2];
            _Int *pia_rows = pblkrows[jj2].GetIaArr ();
            _Int *pja_rows = pblkrows[jj2].GetJaArr ();
            _Int *pja2_rows = pblkrows[jj2].GetJa2Arr ();
            _Flt *pa_rows = pblkrows[jj2].GetAArr ();
            int nzjaloc = pA_sub[ipar].GetNzja ();
            _Int *pja_sub = pA_sub[ipar].GetJaArr ();
            int nlistloc = nzjaloc;
            int nzja_new = 0;
            int j;
            for (j = 0; j < nlistloc; j++) {
               int jj = (int) pja_sub[j];
               nzja_new += (int) (pia_rows[jj + 1] - pia_rows[jj]);
            }
            CMatrix < _Int, _Flt > a_new;
            a_new.ResizeAndSetAll (nlistloc, nlistloc, nzja_new, nzja_new, nzja_new);
            _Int *plist_new = a_new.GetListArr ();
            _Int *plist2_new = a_new.GetList2Arr ();
            _Int *pia_new = a_new.GetIaArr ();
            _Int *pja_new = a_new.GetJaArr ();
            _Int *pja2_new = a_new.GetJa2Arr ();
            _Flt *pa_new = a_new.GetAArr ();
            nzja_new = 0;
            pia_new[0] = 0;
            for (j = 0; j < nlistloc; j++) {
               plist_new[j] = pja_sub[j];
               plist2_new[j] = jj2;
               int jj = (int) pja_sub[j];
               int k;
               for (k = (int) pia_rows[jj]; k < pia_rows[jj + 1]; k++) {
                  pja_new[nzja_new] = pja_rows[k];
                  pja2_new[nzja_new] = pja2_rows[k];
                  pa_new[nzja_new] = pa_rows[k];
                  nzja_new++;
               }
               pia_new[j + 1] = nzja_new;
            }
            pA_sub[ipar].ReplaceFree (a_new);
         }
      }

// Pack send data

      ObjRecv.resize (nrecv);

      pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      for (i = 0; i < nrecv; i++) {
         isize = phblk_recv[i].GetPackedSize ();
         pObjRecv[i].resize ((size_t) isize);
         pobj = &(pObjRecv[i][0]);
         phblk_recv[i].FillPacked_thr (isize, pobj);
         phblk_recv[i].Clean ();
      }

// Exchange data back

      CMPIDataExchange::DataExchange (_comm, CpuIDRecv, ObjRecv, CpuIDSend, ObjSend);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDRecv.swap (CpuIDSend_temp);
         ObjRecv.swap (ObjSend_temp);
      }

// Unpack receive data

      nrecv = (int) CpuIDSend.size ();

      pObjSend = NULL;

      if (nrecv > 0) {
         pObjSend = &ObjSend[0];
      }

      hblk_send.resize (nrecv + 1);

      phblk_send = &hblk_send[0];

      for (i = 0; i < nrecv; i++) {
         isize = (long long) pObjSend[i].size ();
         pobj = &(pObjSend[i][0]);
         phblk_send[i].UnPack_thr (isize, pobj);
      }

// Free recv data

      {
         vector < int >CpuIDRecv_temp;
         vector < vector < char > >ObjRecv_temp;
         CpuIDSend.swap (CpuIDRecv_temp);
         ObjSend.swap (ObjRecv_temp);
      }

// Move received data back to the block arrays

      for (i = 0; i < nrecv; i++) {
         int nzblk_temp = phblk_send[i].GetNzblk ();
         CMatrix < int, float >*phmatr = phblk_send[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
         int *plist2_hmatr = phmatr->GetList2Arr ();
         int j;
         for (j = 0; j < nzblk_temp; j++) {
            ihblk = plist2_hmatr[3 * j];
            int iblk_ext = plist2_hmatr[3 * j + 1];
            CMatrix < _Int, _Flt > *ppblocks_send = &pblocks_send[ihblk][0];
            ppblocks_send[iblk_ext].ReplaceFree (pA_sub[j]);
         }
      }

// Prepare mask data

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      vector < int >icycle_thr (n_thr + 1);
      vector < CVectorData < int > >imaskblk_thr (n_thr + 1);

      int *picycle_thr = &icycle_thr[0];
      CVectorData < int >*pimaskblk_thr = &imaskblk_thr[0];

      for (i = 0; i < n_thr; i++)
         picycle_thr[i] = -1;

// Combine submatrices into one filtered hblock matrix

      vector < vector < CBMatrix < _Int, _Flt > > >hmatr_arr (_nhblks + 1);
      vector < CBMatrix < _Int, _Flt > >*phmatr_arr = &hmatr_arr[0];

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            phmatr_arr[ihblk].resize (_nblks_ext_arr[ihblk] + 1);
         }
      }

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            int *ppblksnum_ext_arr = &(_blksnum_ext_arr[ihblk][0]);
            int nblks_temp = _hblk2blk[ihblk + 1] - _hblk2blk[ihblk];
            CMatrix < _Int, _Flt > *ppblocks_send = &pblocks_send[ihblk][0];
            CBMatrix < _Int, _Flt > *pphmatr_arr = &phmatr_arr[ihblk][0];
#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < _nblks_ext_arr[ihblk]; ipar++) {
               CMatrix < _Int, _Flt > *pblock_curr = NULL;
               if (ipar < _nblks_ext_arr[ihblk] - nblks_temp) {
                  pblock_curr = ppblocks_send + ipar;
               } else {
                  int jj2 =
                     ipar - (_nblks_ext_arr[ihblk] - nblks_temp) + _hblk2blk[ihblk];
                  pblock_curr = pblkrows + jj2;
               }
               int my_thr = 0;
#ifdef USE_THREADS
               my_thr = omp_get_thread_num ();
#endif
               int i, j;
               if (picycle_thr[my_thr] == -1) {
                  pimaskblk_thr[my_thr].resize (5 * _nblks + 4 * nimax + 2);
                  int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
                  int *pimask = pimaskblk + _nblks;
                  for (j = 0; j < _nblks; j++)
                     pimaskblk[j] = -1;
                  for (j = 0; j < nimax; j++)
                     pimask[j] = -1;
               }

               int icycleblk = picycle_thr[my_thr];
               int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
               int *pimask = pimaskblk + _nblks;
               int *plistblk = pimask + nimax;
               int *pindblk = plistblk + _nblks;
               int *pindblk2 = pindblk + _nblks;
               int *pnzblk = pindblk2 + _nblks;
               int *plist = pnzblk + _nblks;
               int *pind = plist + nimax;

               icycleblk++;

// Create list of active blocks and count number of elems

               for (j = 0; j < _nblks_ext_arr[ihblk]; j++) {
                  int jj2 = ppblksnum_ext_arr[j];
                  pimaskblk[jj2] = icycleblk;
                  pindblk[jj2] = j;
               }

               int nlist_curr = pblock_curr->GetNlist ();
               int nzja_curr = pblock_curr->GetNzja ();
               _Int *plist_curr = pblock_curr->GetListArr ();
               _Int *pia_curr = pblock_curr->GetIaArr ();
               _Int *pja_curr = pblock_curr->GetJaArr ();
               _Int *pja2_curr = pblock_curr->GetJa2Arr ();
               _Flt *pa_curr = pblock_curr->GetAArr ();

               int nzblk_curr = 0;

               icycleblk++;

               for (j = 0; j < nzja_curr; j++) {
                  int jj2 = (int) pja2_curr[j];
                  if (pimaskblk[jj2] == icycleblk - 1) {
                     pimaskblk[jj2]++;
                     plistblk[nzblk_curr] = jj2;
                     nzblk_curr++;
                  }
               }

               sort (plistblk, plistblk + nzblk_curr);

               for (j = 0; j < nzblk_curr; j++) {
                  int jj2 = plistblk[j];
                  pindblk2[jj2] = j;
                  pnzblk[j] = 0;
               }

               for (j = 0; j < nzja_curr; j++) {
                  int jj2 = (int) pja2_curr[j];
                  if (pimaskblk[jj2] >= icycleblk - 1) {
                     int ind = pindblk2[jj2];
                     pnzblk[ind]++;
                  }
               }

// Allocate initial work memory to store non-filtered matrix data

               pphmatr_arr[ipar].SetNzblk (nzblk_curr);
               pphmatr_arr[ipar].ResizeASub (nzblk_curr);

               CMatrix < int, float >*phmatr = pphmatr_arr[ipar].GetHMatrStr ();
               CMatrix < _Int, _Flt > *pA_sub = pphmatr_arr[ipar].GetASubArr ();

               phmatr->ResizeAndSetAllSp (0, nzblk_curr, 0, 0);

               int *plist_hmatr = phmatr->GetList2Arr ();

               for (j = 0; j < nzblk_curr; j++) {
                  int jj2 = plistblk[j];
                  plist_hmatr[j] = pindblk[jj2];
               }

               vector < vector < int > >rows (nzblk_curr + 1);
               vector < vector < int > >cols (nzblk_curr + 1);
               vector < vector < _Flt > >elems (nzblk_curr + 1);

               vector < int >*prows = &rows[0];
               vector < int >*pcols = &cols[0];
               vector < _Flt > *pelems = &elems[0];

               for (i = 0; i < nzblk_curr; i++) {
                  prows[i].resize (pnzblk[i] + 1);
                  pcols[i].resize (pnzblk[i] + 1);
                  pelems[i].resize (pnzblk[i] + 1);
               }

               for (j = 0; j < nzblk_curr; j++)
                  pnzblk[j] = 0;

               int *pprows;
               int *ppcols;
               _Flt *ppelems;

               for (i = 0; i < nlist_curr; i++) {
                  for (j = (int) pia_curr[i]; j < pia_curr[i + 1]; j++) {
                     int jj2 = (int) pja2_curr[j];
                     if (pimaskblk[jj2] >= icycleblk - 1) {
                        int ind = pindblk2[jj2];
                        pprows = &prows[ind][0];
                        ppcols = &pcols[ind][0];
                        ppelems = &pelems[ind][0];
                        int k = pnzblk[ind];
                        pprows[k] = (int) plist_curr[i];
                        ppcols[k] = (int) pja_curr[j];
                        ppelems[k] = pa_curr[j];
                        pnzblk[ind]++;
                     }
                  }
               }

// Store blocks as sparse data

               for (i = 0; i < nzblk_curr; i++) {

                  pprows = &prows[i][0];
                  ppcols = &pcols[i][0];
                  ppelems = &pelems[i][0];

// Compute the list of columns

                  icycleblk++;

                  int nlistloc = 0;

                  for (j = 0; j < pnzblk[i]; j++) {
                     int jj = pprows[j];
                     if (pimask[jj] != icycleblk) {
                        plist[nlistloc] = jj;
                        nlistloc++;
                        pimask[jj] = icycleblk;
                     }
                  }

                  sort (plist, plist + nlistloc);

                  for (j = 0; j < nlistloc; j++) {
                     int jj = plist[j];
                     pind[jj] = j;
                  }

                  CMatrix < _Int, _Flt > ablk;

                  ablk.ResizeAndSetAll (nlistloc, 0, pnzblk[i], 0, pnzblk[i]);

                  _Int *plistloc = ablk.GetListArr ();
                  _Int *pialoc = ablk.GetIaArr ();
                  _Int *pjaloc = ablk.GetJaArr ();
                  _Flt *paloc = ablk.GetAArr ();

                  for (j = 0; j < nlistloc; j++)
                     plistloc[j] = (_Int) plist[j];

                  for (j = 0; j <= nlistloc; j++)
                     pialoc[j] = 0;

                  for (j = 0; j < pnzblk[i]; j++) {
                     int jj = pprows[j];
                     int ind = pind[jj];
                     pialoc[ind + 1]++;
                  }

                  for (j = 0; j < nlistloc; j++)
                     pialoc[j + 1] = pialoc[j] + pialoc[j + 1];

                  vector < int >iptr (nlistloc + 1);
                  int *piptr = &iptr[0];

                  for (j = 0; j < nlistloc; j++)
                     piptr[j] = (int) pialoc[j];

                  for (j = 0; j < pnzblk[i]; j++) {
                     int jj = pprows[j];
                     int ind = pind[jj];
                     int k = piptr[ind];
                     pjaloc[k] = (_Int) ppcols[j];
                     paloc[k] = ppelems[j];
                     piptr[ind]++;
                  }

                  int nimax_temp = 0;

                  int niloc;

                  for (j = 0; j < nlistloc; j++) {
                     niloc = (int) (pialoc[j + 1] - pialoc[j]);
                     if (niloc > nimax_temp)
                        nimax_temp = niloc;
                  }

                  vector < CSortInt > iiarr (nimax_temp + 1);

                  CSortInt *piiarr = &iiarr[0];

                  int k;

                  for (j = 0; j < nlistloc; j++) {
                     niloc = (int) (pialoc[j + 1] - pialoc[j]);
                     int ibeg = (int) pialoc[j];
                     for (k = (int) pialoc[j]; k < pialoc[j + 1]; k++) {
                        piiarr[k - ibeg].ival = (int) pjaloc[k];
                        piiarr[k - ibeg].i2val = (int) (k - ibeg);
                     }
                     sort (piiarr, piiarr + niloc);
                     for (k = (int) pialoc[j]; k < pialoc[j + 1]; k++) {
                        pjaloc[k] = (_Int) (piiarr[k - ibeg].ival);
                        ppelems[k - ibeg] = paloc[k];
                     }
                     for (k = (int) pialoc[j]; k < pialoc[j + 1]; k++) {
                        int ind = piiarr[k - ibeg].i2val;
                        paloc[k] = ppelems[ind];
                     }
                  }

                  pA_sub[i].ReplaceFree (ablk);

               }

               picycle_thr[my_thr] = icycleblk;

            }
         }
      }

// Combine computed data into one hblock

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {

            CBMatrix < _Int, _Flt > *pphmatr_arr = &phmatr_arr[ihblk][0];

            int nzblk_tot = 0;

            int iblk_ext;

            for (iblk_ext = 0; iblk_ext < _nblks_ext_arr[ihblk]; iblk_ext++) {
               nzblk_tot += pphmatr_arr[iblk_ext].GetNzblk ();
            }

            _hmatr_ext_arr[ihblk].SetNzblk (nzblk_tot);
            _hmatr_ext_arr[ihblk].ResizeASub (nzblk_tot);

            CMatrix < int, float >*phmatr = _hmatr_ext_arr[ihblk].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_ext_arr[ihblk].GetASubArr ();

            phmatr->ResizeAndSetAllSp (_nblks_ext_arr[ihblk], _nblks_ext_arr[ihblk],
                                       nzblk_tot, nzblk_tot);

            int *plist_hmatr = phmatr->GetListArr ();
            int *plist2_hmatr = phmatr->GetList2Arr ();
            int *pia_hmatr = phmatr->GetIaArr ();
            int *pja_hmatr = phmatr->GetJaArr ();
            int *pja2_hmatr = phmatr->GetJa2Arr ();

            for (i = 0; i < _nblks_ext_arr[ihblk]; i++)
               plist_hmatr[i] = i;
            for (i = 0; i < _nblks_ext_arr[ihblk]; i++)
               plist2_hmatr[i] = 0;

            pia_hmatr[0] = 0;

            nzblk_tot = 0;

            for (iblk_ext = 0; iblk_ext < _nblks_ext_arr[ihblk]; iblk_ext++) {
               int nzblk_temp = pphmatr_arr[iblk_ext].GetNzblk ();
               CMatrix < int, float >*phmatr_temp = pphmatr_arr[iblk_ext].GetHMatrStr ();
               CMatrix < _Int, _Flt > *pA_sub_temp = pphmatr_arr[iblk_ext].GetASubArr ();
               int *plist_hmatr_temp = phmatr_temp->GetList2Arr ();
               int j;
               for (j = 0; j < nzblk_temp; j++) {
                  int jj2 = plist_hmatr_temp[j];
                  pja_hmatr[nzblk_tot] = jj2;
                  pja2_hmatr[nzblk_tot] = 0;
                  pA_sub[nzblk_tot].ReplaceFree (pA_sub_temp[j]);
                  nzblk_tot++;
               }
               pia_hmatr[iblk_ext + 1] = nzblk_tot;
            }

         }
      }

// Perform column filtering and renumbering of the extended data

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {

            int nblks_ext = _nblks_ext_arr[ihblk];
            CMatrix < int, float >*phmatr = _hmatr_ext_arr[ihblk].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_ext_arr[ihblk].GetASubArr ();

// Compute transposed sparse matrix

            CMatrix < int, float >hmatrT;

            {

               CVectorData < int >imask_temp (nblks_ext * 5 + 2);
               int *pimask_temp = imask_temp.Ptr ();

               for (i = 0; i < nblks_ext; i++)
                  pimask_temp[i] = -1;

               int icycle = -1;

               phmatr->TransposedSparsityListSp (icycle, pimask_temp,
                                                 pimask_temp + nblks_ext,
                                                 pimask_temp + 2 * nblks_ext,
                                                 pimask_temp + 3 * nblks_ext,
                                                 pimask_temp + 4 * nblks_ext, hmatrT);

            }

// Indices Tran2Norm

            int nzja_hmatr = phmatr->GetNzja ();
            int *pia_hmatr = phmatr->GetIaArr ();

            int *pia_hmatrT = hmatrT.GetIaArr ();
            int *pja_hmatrT = hmatrT.GetJaArr ();

            vector < int >indht2h (nzja_hmatr + 1);
            int *pindht2h = &indht2h[0];

            vector < int >iptr (nblks_ext + 1);
            int *piptr = &iptr[0];

            for (i = 0; i < nblks_ext; i++)
               piptr[i] = pia_hmatr[i];

            for (i = 0; i < nblks_ext; i++) {
               int j;
               for (j = pia_hmatrT[i]; j < pia_hmatrT[i + 1]; j++) {
                  int jj = pja_hmatrT[j];
                  int k = piptr[jj];
                  pindht2h[j] = k;
                  piptr[jj]++;
               }
            }

            int nblks_temp = _hblk2blk[ihblk + 1] - _hblk2blk[ihblk];

            long long *ppblks_ext_arr = &(_pblks_ext_arr[ihblk][0]);
            int *pplist_ext_arr = &(_list_ext_arr[ihblk][0]);

#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nblks_ext - nblks_temp; ipar++) {

               int my_thr = 0;
#ifdef USE_THREADS
               my_thr = omp_get_thread_num ();
#endif
               int i, j;
               if (picycle_thr[my_thr] == -1) {
                  pimaskblk_thr[my_thr].resize (5 * _nblks + 4 * nimax + 2);
                  int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
                  int *pimask = pimaskblk + _nblks;
                  for (j = 0; j < _nblks; j++)
                     pimaskblk[j] = -1;
                  for (j = 0; j < nimax; j++)
                     pimask[j] = -1;
               }

               int icycleblk = picycle_thr[my_thr];
               int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
               int *pimask = pimaskblk + _nblks;
               int *plistblk = pimask + nimax;
               int *pindblk = plistblk + _nblks;
               int *pindblk2 = pindblk + _nblks;
               int *pnzblk = pindblk2 + _nblks;
               int *plist = pnzblk + _nblks;
               int *pind = plist + nimax;

// Register current list of columns

               icycleblk++;

               int ibeg = (int) ppblks_ext_arr[ipar];

               for (j = (int) ppblks_ext_arr[ipar]; j < ppblks_ext_arr[ipar + 1]; j++) {
                  int jj = pplist_ext_arr[j * 2];
                  pimask[jj] = icycleblk;
                  pind[jj] = j - ibeg;
               }

// Renumber rows lists in the block row

               for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
                  int nlist_temp = pA_sub[j].GetNlist ();
                  _Int *plist_temp = pA_sub[j].GetListArr ();
                  int k;
                  for (k = 0; k < nlist_temp; k++) {
                     int kk = (int) plist_temp[k];
                     plist_temp[k] = (_Int) pind[kk];
                  }
               }

// Filter columns elems

               for (i = pia_hmatrT[ipar]; i < pia_hmatrT[ipar + 1]; i++) {
                  int ind = pindht2h[i];
                  int nlist_temp = pA_sub[ind].GetNlist ();
                  _Int *pia_temp = pA_sub[ind].GetIaArr ();
                  _Int *pja_temp = pA_sub[ind].GetJaArr ();
                  _Flt *pa_temp = pA_sub[ind].GetAArr ();
                  vector < _Int > ia_new (nlist_temp + 1);
                  _Int *pia_new = &ia_new[0];
                  int nzja_new = 0;
                  pia_new[0] = 0;
                  int k;
                  for (j = 0; j < nlist_temp; j++) {
                     for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                        int kk = (int) pja_temp[k];
                        if (pimask[kk] == icycleblk) {
                           pja_temp[nzja_new] = (_Int) pind[kk];
                           pa_temp[nzja_new] = pa_temp[k];
                           nzja_new++;
                        }
                     }
                     pia_new[j + 1] = nzja_new;
                  }
                  for (k = 0; k <= nlist_temp; k++)
                     pia_temp[k] = (_Int) pia_new[k];
                  pA_sub[ind].SetNzja (nzja_new);
                  pA_sub[ind].SetNza (nzja_new);
               }
               picycle_thr[my_thr] = icycleblk;
            }
         }
      }

   }

// Get the extended submatrices
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::GetExtendedSubmatrices_BxB (void *_comm, int _blksize, int _nhblks,
                                          int *_hblk2cpu, int *_hblk2blk, int *_blk2hblk,
                                          int _nblks, long long *_blks, CBMatrix < _Int,
                                          _Flt > *_hmatr_arr, int *_nblks_ext_arr,
                                          vector < int >*_blksnum_ext_arr,
                                          vector < long long >*_pblks_ext_arr,
                                          int *_nlist_ext_arr,
                                          vector < int >*_list_ext_arr, CBMatrix < _Int,
                                          _Flt > *_hmatr_ext_arr)
   {

      int myid = CMPIDataExchange::GetMyid (_comm);
      int nproc = CMPIDataExchange::GetNproc (_comm);

// Compute the maximal block size

      int b_2 = _blksize * _blksize;

      int nimax = 0;

      int i;
      int niloc;

      for (i = 0; i < _nblks; i++) {
         niloc = (int) (_blks[i + 1] - _blks[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

// Compute data as two index rows block structures

      vector < CMatrix < _Int, _Flt > >blkrows (_nblks);
      CMatrix < _Int, _Flt > *pblkrows = &blkrows[0];

      int ihblk;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr[ihblk].GetASubArr ();
            CMatrix < int, float >*pHMatr_sub = _hmatr_arr[ihblk].GetHMatrStr ();
            int nlist_hmatr = pHMatr_sub->GetNlist ();
            int *pia_hmatr = pHMatr_sub->GetIaArr ();
            int *pja_hmatr = pHMatr_sub->GetJaArr ();
            int *pja2_hmatr = pHMatr_sub->GetJa2Arr ();
#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nlist_hmatr; ipar++) {

               int nzjanew, ind, kj;
               int iblkgl, jblkgl, j, jj, jj2, k, kk, nlistnew;

               nzjanew = 0;
               for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
                  nzjanew += pA_sub[j].GetNzja ();
               }
               iblkgl = _hblk2blk[ihblk] + ipar;
               nlistnew = (int) (_blks[iblkgl + 1] - _blks[iblkgl]);
               CMatrix < _Int, _Flt > anew;
               anew.ResizeAndSetAll (nlistnew, nlistnew, nzjanew, nzjanew, nzjanew * b_2);
               _Int *plist_new = anew.GetListArr ();
               _Int *plist2_new = anew.GetList2Arr ();
               _Int *pia_new = anew.GetIaArr ();
               _Int *pja_new = anew.GetJaArr ();
               _Int *pja2_new = anew.GetJa2Arr ();
               _Flt *pa_new = anew.GetAArr ();
               for (j = 0; j < nlistnew; j++)
                  plist_new[j] = (_Int) j;
               for (j = 0; j < nlistnew; j++)
                  plist2_new[j] = (_Int) iblkgl;
               for (j = 0; j <= nlistnew; j++)
                  pia_new[j] = 0;
               for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
                  int nlistloc = pA_sub[j].GetNlist ();
                  _Int *plistloc = pA_sub[j].GetListArr ();
                  _Int *pialoc = pA_sub[j].GetIaArr ();
                  for (k = 0; k < nlistloc; k++) {
                     kk = (int) plistloc[k];
                     pia_new[kk + 1] += (pialoc[k + 1] - pialoc[k]);
                  }
               }
               for (j = 0; j < nlistnew; j++)
                  pia_new[j + 1] = pia_new[j] + pia_new[j + 1];
               vector < int >iptr (nlistnew + 1);
               int *piptr = &iptr[0];
               for (j = 0; j < nlistnew; j++)
                  piptr[j] = (int) pia_new[j];
               for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
                  jj = pja_hmatr[j];
                  jj2 = pja2_hmatr[j];
                  jblkgl = _hblk2blk[jj2] + jj;
                  int nlistloc = pA_sub[j].GetNlist ();
                  _Int *plistloc = pA_sub[j].GetListArr ();
                  _Int *pialoc = pA_sub[j].GetIaArr ();
                  _Int *pjaloc = pA_sub[j].GetJaArr ();
                  _Flt *paloc = pA_sub[j].GetAArr ();
                  for (k = 0; k < nlistloc; k++) {
                     kk = (int) plistloc[k];
                     ind = (int) piptr[kk];
                     for (kj = (int) pialoc[k]; kj < pialoc[k + 1]; kj++) {
                        pja_new[ind] = pjaloc[kj];
                        pja2_new[ind] = jblkgl;
                        CVector < _Flt >::CopyVector (b_2, paloc + kj * b_2,
                                                      pa_new + ind * b_2);
                        ind++;
                     }
                     piptr[kk] = ind;
                  }
               }
               pblkrows[iblkgl].ReplaceFree (anew);
            }
         }
      }

// Create mask data

      int icyclecpu = -1;

      vector < int >imaskcpu (nproc);
      vector < int >listcpu (nproc);
      vector < int >indcpu (nproc);

      int *pimaskcpu = &imaskcpu[0];
      int *plistcpu = &listcpu[0];
      int *pindcpu = &indcpu[0];

      for (i = 0; i < nproc; i++) {
         pimaskcpu[i] = icyclecpu;
      }

// Create list of cpus

      icyclecpu++;

      int nlistcpu = 0;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            int nblks_temp = _hblk2blk[ihblk + 1] - _hblk2blk[ihblk];
            int *ppblksnum_ext_arr = &(_blksnum_ext_arr[ihblk][0]);
            int j;
            for (j = 0; j < _nblks_ext_arr[ihblk] - nblks_temp; j++) {
               int jj2 = (int) ppblksnum_ext_arr[j];
               int jhblk = _blk2hblk[jj2];
               int jcpu = _hblk2cpu[jhblk];
               if (pimaskcpu[jcpu] != icyclecpu) {
                  plistcpu[nlistcpu] = jcpu;
                  nlistcpu++;
                  pimaskcpu[jcpu] = icyclecpu;
               }
            }
         }
      }

      sort (plistcpu, plistcpu + nlistcpu);

      for (i = 0; i < nlistcpu; i++) {
         int jcpu = plistcpu[i];
         pindcpu[jcpu] = i;
      }

// For own hblocks form sets of blocks for exchange

      vector < vector < CMatrix < _Int, _Flt > > >blocks_send (_nhblks + 1);

      vector < CMatrix < _Int, _Flt > >*pblocks_send = &blocks_send[0];

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            int nblks_temp = _hblk2blk[ihblk + 1] - _hblk2blk[ihblk];
            pblocks_send[ihblk].resize (_nblks_ext_arr[ihblk] - nblks_temp + 1);
            CMatrix < _Int, _Flt > *ppblocks_send = &pblocks_send[ihblk][0];
            long long *ppblks_ext_arr = &(_pblks_ext_arr[ihblk][0]);
            int *pplist_ext_arr = &(_list_ext_arr[ihblk][0]);
            int i;
            for (i = 0; i < _nblks_ext_arr[ihblk] - nblks_temp; i++) {
               int nz_temp = (int) (ppblks_ext_arr[i + 1] - ppblks_ext_arr[i]);
               ppblocks_send[i].ResizeAndSetAllSp (0, 0, nz_temp, 0);
               _Int *pja_temp = ppblocks_send[i].GetJaArr ();
               long long ibeg = ppblks_ext_arr[i];
               int j;
               for (j = (int) ppblks_ext_arr[i]; j < ppblks_ext_arr[i + 1]; j++) {
                  pja_temp[j - ibeg] = pplist_ext_arr[j * 2];
               }
            }
         }
      }

// Reconfigure sets of blocks into small set of hblocks

      vector < int >nz_send (nlistcpu + 1);

      int *pnz_send = &nz_send[0];

      for (i = 0; i < nlistcpu; i++)
         pnz_send[i] = 0;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            int nblks_temp = _hblk2blk[ihblk + 1] - _hblk2blk[ihblk];
            int *ppblksnum_ext_arr = &(_blksnum_ext_arr[ihblk][0]);
            for (i = 0; i < _nblks_ext_arr[ihblk] - nblks_temp; i++) {
               int jj2 = ppblksnum_ext_arr[i];
               int jhblk = _blk2hblk[jj2];
               int jcpu = _hblk2cpu[jhblk];
               int ind = pindcpu[jcpu];
               pnz_send[ind]++;
            }
         }
      }

// Prepare send data

      vector < CBMatrix < _Int, _Flt > >hblk_send (nlistcpu + 1);

      CBMatrix < _Int, _Flt > *phblk_send = &hblk_send[0];

      for (i = 0; i < nlistcpu; i++) {
         int nz_temp = pnz_send[i];
         phblk_send[i].SetNzblk (nz_temp);
         phblk_send[i].ResizeASub (nz_temp);
         CMatrix < int, float >*p_hmatr = phblk_send[i].GetHMatrStr ();
         p_hmatr->ResizeAndSetAllSp (0, 3 * nz_temp, 0, 0);
      }

      for (i = 0; i < nlistcpu; i++)
         pnz_send[i] = 0;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            int *ppblksnum_ext_arr = &(_blksnum_ext_arr[ihblk][0]);
            int nblks_temp = _hblk2blk[ihblk + 1] - _hblk2blk[ihblk];
            CMatrix < _Int, _Flt > *ppblocks_send = &pblocks_send[ihblk][0];
            for (i = 0; i < _nblks_ext_arr[ihblk] - nblks_temp; i++) {
               int jj2 = ppblksnum_ext_arr[i];
               int jhblk = _blk2hblk[jj2];
               int jcpu = _hblk2cpu[jhblk];
               int ind = pindcpu[jcpu];
               CMatrix < int, float >*p_hmatr = phblk_send[ind].GetHMatrStr ();
               int *plist2_hmatr = p_hmatr->GetList2Arr ();
               CMatrix < _Int, _Flt > *pA_sub = phblk_send[ind].GetASubArr ();
               int k = pnz_send[ind];
               plist2_hmatr[3 * k] = ihblk;
               plist2_hmatr[3 * k + 1] = i;
               plist2_hmatr[3 * k + 2] = jj2;
               pA_sub[k].ReplaceFree (ppblocks_send[i]);
               pnz_send[ind]++;
            }
         }
      }

// Pack send data

      vector < int >CpuIDSend (nlistcpu);
      vector < vector < char > >ObjSend (nlistcpu);

      int *pCpuIDSend = NULL;
      vector < char >*pObjSend = NULL;

      if (nlistcpu > 0) {
         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];
      }

      long long isize;
      char *pobj;

      for (i = 0; i < nlistcpu; i++) {
         pCpuIDSend[i] = plistcpu[i];
         isize = phblk_send[i].GetPackedSize ();
         pObjSend[i].resize ((size_t) isize);
         pobj = &(pObjSend[i][0]);
         phblk_send[i].FillPacked_thr (isize, pobj);
         phblk_send[i].Clean ();
      }

// Exchange

      vector < int >CpuIDRecv;
      vector < vector < char > >ObjRecv;

      CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      int nrecv = (int) CpuIDRecv.size ();

      vector < char >*pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      vector < CBMatrix < _Int, _Flt > >hblk_recv (nrecv + 1);

      CBMatrix < _Int, _Flt > *phblk_recv = &hblk_recv[0];

      for (i = 0; i < nrecv; i++) {
         isize = (long long) pObjRecv[i].size ();
         pobj = &(pObjRecv[i][0]);
         phblk_recv[i].UnPack_thr (isize, pobj);
      }

// Free recv data

      {
         vector < vector < char > >ObjRecv_temp;
         ObjRecv.swap (ObjRecv_temp);
      }

// Prepare the answer for all received data

      int irecv;

      for (irecv = 0; irecv < nrecv; irecv++) {
         int nzblk = phblk_recv[irecv].GetNzblk ();
         CMatrix < int, float >*phmatr = phblk_recv[irecv].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub = phblk_recv[irecv].GetASubArr ();
         int *plist2_hmatr = phmatr->GetList2Arr ();
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nzblk; ipar++) {
            int jj2 = plist2_hmatr[3 * ipar + 2];
            _Int *pia_rows = pblkrows[jj2].GetIaArr ();
            _Int *pja_rows = pblkrows[jj2].GetJaArr ();
            _Int *pja2_rows = pblkrows[jj2].GetJa2Arr ();
            _Flt *pa_rows = pblkrows[jj2].GetAArr ();
            int nzjaloc = pA_sub[ipar].GetNzja ();
            _Int *pja_sub = pA_sub[ipar].GetJaArr ();
            int nlistloc = nzjaloc;
            int nzja_new = 0;
            int j;
            for (j = 0; j < nlistloc; j++) {
               int jj = (int) pja_sub[j];
               nzja_new += (int) (pia_rows[jj + 1] - pia_rows[jj]);
            }
            CMatrix < _Int, _Flt > a_new;
            a_new.ResizeAndSetAll (nlistloc, nlistloc, nzja_new, nzja_new,
                                   nzja_new * b_2);
            _Int *plist_new = a_new.GetListArr ();
            _Int *plist2_new = a_new.GetList2Arr ();
            _Int *pia_new = a_new.GetIaArr ();
            _Int *pja_new = a_new.GetJaArr ();
            _Int *pja2_new = a_new.GetJa2Arr ();
            _Flt *pa_new = a_new.GetAArr ();
            nzja_new = 0;
            pia_new[0] = 0;
            for (j = 0; j < nlistloc; j++) {
               plist_new[j] = pja_sub[j];
               plist2_new[j] = jj2;
               int jj = (int) pja_sub[j];
               int k;
               for (k = (int) pia_rows[jj]; k < pia_rows[jj + 1]; k++) {
                  pja_new[nzja_new] = pja_rows[k];
                  pja2_new[nzja_new] = pja2_rows[k];
                  CVector < _Flt >::CopyVector (b_2, pa_rows + k * b_2,
                                                pa_new + nzja_new * b_2);
                  nzja_new++;
               }
               pia_new[j + 1] = nzja_new;
            }
            pA_sub[ipar].ReplaceFree (a_new);
         }
      }

// Pack send data

      ObjRecv.resize (nrecv);

      pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      for (i = 0; i < nrecv; i++) {
         isize = phblk_recv[i].GetPackedSize ();
         pObjRecv[i].resize ((size_t) isize);
         pobj = &(pObjRecv[i][0]);
         phblk_recv[i].FillPacked_thr (isize, pobj);
         phblk_recv[i].Clean ();
      }

// Exchange data back

      CMPIDataExchange::DataExchange (_comm, CpuIDRecv, ObjRecv, CpuIDSend, ObjSend);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDRecv.swap (CpuIDSend_temp);
         ObjRecv.swap (ObjSend_temp);
      }

// Unpack receive data

      nrecv = (int) CpuIDSend.size ();

      pObjSend = NULL;

      if (nrecv > 0) {
         pObjSend = &ObjSend[0];
      }

      hblk_send.resize (nrecv + 1);

      phblk_send = &hblk_send[0];

      for (i = 0; i < nrecv; i++) {
         isize = (long long) pObjSend[i].size ();
         pobj = &(pObjSend[i][0]);
         phblk_send[i].UnPack_thr (isize, pobj);
      }

// Free recv data

      {
         vector < int >CpuIDRecv_temp;
         vector < vector < char > >ObjRecv_temp;
         CpuIDSend.swap (CpuIDRecv_temp);
         ObjSend.swap (ObjRecv_temp);
      }

// Move received data back to the block arrays

      for (i = 0; i < nrecv; i++) {
         int nzblk_temp = phblk_send[i].GetNzblk ();
         CMatrix < int, float >*phmatr = phblk_send[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
         int *plist2_hmatr = phmatr->GetList2Arr ();
         int j;
         for (j = 0; j < nzblk_temp; j++) {
            ihblk = plist2_hmatr[3 * j];
            int iblk_ext = plist2_hmatr[3 * j + 1];
            CMatrix < _Int, _Flt > *ppblocks_send = &pblocks_send[ihblk][0];
            ppblocks_send[iblk_ext].ReplaceFree (pA_sub[j]);
         }
      }

// Prepare mask data

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      vector < int >icycle_thr (n_thr + 1);
      vector < CVectorData < int > >imaskblk_thr (n_thr + 1);

      int *picycle_thr = &icycle_thr[0];
      CVectorData < int >*pimaskblk_thr = &imaskblk_thr[0];

      for (i = 0; i < n_thr; i++)
         picycle_thr[i] = -1;

// Combine submatrices into one filtered hblock matrix

      vector < vector < CBMatrix < _Int, _Flt > > >hmatr_arr (_nhblks + 1);
      vector < CBMatrix < _Int, _Flt > >*phmatr_arr = &hmatr_arr[0];

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            phmatr_arr[ihblk].resize (_nblks_ext_arr[ihblk] + 1);
         }
      }

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {
            int *ppblksnum_ext_arr = &(_blksnum_ext_arr[ihblk][0]);
            int nblks_temp = _hblk2blk[ihblk + 1] - _hblk2blk[ihblk];
            CMatrix < _Int, _Flt > *ppblocks_send = &pblocks_send[ihblk][0];
            CBMatrix < _Int, _Flt > *pphmatr_arr = &phmatr_arr[ihblk][0];
#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < _nblks_ext_arr[ihblk]; ipar++) {
               CMatrix < _Int, _Flt > *pblock_curr = NULL;
               if (ipar < _nblks_ext_arr[ihblk] - nblks_temp) {
                  pblock_curr = ppblocks_send + ipar;
               } else {
                  int jj2 =
                     ipar - (_nblks_ext_arr[ihblk] - nblks_temp) + _hblk2blk[ihblk];
                  pblock_curr = pblkrows + jj2;
               }
               int my_thr = 0;
#ifdef USE_THREADS
               my_thr = omp_get_thread_num ();
#endif
               int i, j;
               if (picycle_thr[my_thr] == -1) {
                  pimaskblk_thr[my_thr].resize (5 * _nblks + 4 * nimax + 2);
                  int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
                  int *pimask = pimaskblk + _nblks;
                  for (j = 0; j < _nblks; j++)
                     pimaskblk[j] = -1;
                  for (j = 0; j < nimax; j++)
                     pimask[j] = -1;
               }

               int icycleblk = picycle_thr[my_thr];
               int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
               int *pimask = pimaskblk + _nblks;
               int *plistblk = pimask + nimax;
               int *pindblk = plistblk + _nblks;
               int *pindblk2 = pindblk + _nblks;
               int *pnzblk = pindblk2 + _nblks;
               int *plist = pnzblk + _nblks;
               int *pind = plist + nimax;

               icycleblk++;

// Create list of active blocks and count number of elems

               for (j = 0; j < _nblks_ext_arr[ihblk]; j++) {
                  int jj2 = ppblksnum_ext_arr[j];
                  pimaskblk[jj2] = icycleblk;
                  pindblk[jj2] = j;
               }

               int nlist_curr = pblock_curr->GetNlist ();
               int nzja_curr = pblock_curr->GetNzja ();
               _Int *plist_curr = pblock_curr->GetListArr ();
               _Int *pia_curr = pblock_curr->GetIaArr ();
               _Int *pja_curr = pblock_curr->GetJaArr ();
               _Int *pja2_curr = pblock_curr->GetJa2Arr ();
               _Flt *pa_curr = pblock_curr->GetAArr ();

               int nzblk_curr = 0;

               icycleblk++;

               for (j = 0; j < nzja_curr; j++) {
                  int jj2 = (int) pja2_curr[j];
                  if (pimaskblk[jj2] == icycleblk - 1) {
                     pimaskblk[jj2]++;
                     plistblk[nzblk_curr] = jj2;
                     nzblk_curr++;
                  }
               }

               sort (plistblk, plistblk + nzblk_curr);

               for (j = 0; j < nzblk_curr; j++) {
                  int jj2 = plistblk[j];
                  pindblk2[jj2] = j;
                  pnzblk[j] = 0;
               }

               for (j = 0; j < nzja_curr; j++) {
                  int jj2 = (int) pja2_curr[j];
                  if (pimaskblk[jj2] >= icycleblk - 1) {
                     int ind = pindblk2[jj2];
                     pnzblk[ind]++;
                  }
               }

// Allocate initial work memory to store non-filtered matrix data

               pphmatr_arr[ipar].SetNzblk (nzblk_curr);
               pphmatr_arr[ipar].ResizeASub (nzblk_curr);

               CMatrix < int, float >*phmatr = pphmatr_arr[ipar].GetHMatrStr ();
               CMatrix < _Int, _Flt > *pA_sub = pphmatr_arr[ipar].GetASubArr ();

               phmatr->ResizeAndSetAllSp (0, nzblk_curr, 0, 0);

               int *plist_hmatr = phmatr->GetList2Arr ();

               for (j = 0; j < nzblk_curr; j++) {
                  int jj2 = plistblk[j];
                  plist_hmatr[j] = pindblk[jj2];
               }

               vector < vector < int > >rows (nzblk_curr + 1);
               vector < vector < int > >cols (nzblk_curr + 1);
               vector < vector < _Flt > >elems (nzblk_curr + 1);

               vector < int >*prows = &rows[0];
               vector < int >*pcols = &cols[0];
               vector < _Flt > *pelems = &elems[0];

               for (i = 0; i < nzblk_curr; i++) {
                  prows[i].resize (pnzblk[i] + 1);
                  pcols[i].resize (pnzblk[i] + 1);
                  pelems[i].resize (b_2 * pnzblk[i] + 1);
               }

               for (j = 0; j < nzblk_curr; j++)
                  pnzblk[j] = 0;

               int *pprows;
               int *ppcols;
               _Flt *ppelems;

               for (i = 0; i < nlist_curr; i++) {
                  for (j = (int) pia_curr[i]; j < pia_curr[i + 1]; j++) {
                     int jj2 = (int) pja2_curr[j];
                     if (pimaskblk[jj2] >= icycleblk - 1) {
                        int ind = pindblk2[jj2];
                        pprows = &prows[ind][0];
                        ppcols = &pcols[ind][0];
                        ppelems = &pelems[ind][0];
                        int k = pnzblk[ind];
                        pprows[k] = (int) plist_curr[i];
                        ppcols[k] = (int) pja_curr[j];
                        CVector < _Flt >::CopyVector (b_2, pa_curr + j * b_2,
                                                      ppelems + k * b_2);
                        pnzblk[ind]++;
                     }
                  }
               }

// Store blocks as sparse data

               for (i = 0; i < nzblk_curr; i++) {

                  pprows = &prows[i][0];
                  ppcols = &pcols[i][0];
                  ppelems = &pelems[i][0];

// Compute the list of columns

                  icycleblk++;

                  int nlistloc = 0;

                  for (j = 0; j < pnzblk[i]; j++) {
                     int jj = pprows[j];
                     if (pimask[jj] != icycleblk) {
                        plist[nlistloc] = jj;
                        nlistloc++;
                        pimask[jj] = icycleblk;
                     }
                  }

                  sort (plist, plist + nlistloc);

                  for (j = 0; j < nlistloc; j++) {
                     int jj = plist[j];
                     pind[jj] = j;
                  }

                  CMatrix < _Int, _Flt > ablk;

                  ablk.ResizeAndSetAll (nlistloc, 0, pnzblk[i], 0, pnzblk[i] * b_2);

                  _Int *plistloc = ablk.GetListArr ();
                  _Int *pialoc = ablk.GetIaArr ();
                  _Int *pjaloc = ablk.GetJaArr ();
                  _Flt *paloc = ablk.GetAArr ();

                  for (j = 0; j < nlistloc; j++)
                     plistloc[j] = (_Int) plist[j];

                  for (j = 0; j <= nlistloc; j++)
                     pialoc[j] = 0;

                  for (j = 0; j < pnzblk[i]; j++) {
                     int jj = pprows[j];
                     int ind = pind[jj];
                     pialoc[ind + 1]++;
                  }

                  for (j = 0; j < nlistloc; j++)
                     pialoc[j + 1] = pialoc[j] + pialoc[j + 1];

                  vector < int >iptr (nlistloc + 1);
                  int *piptr = &iptr[0];

                  for (j = 0; j < nlistloc; j++)
                     piptr[j] = (int) pialoc[j];

                  for (j = 0; j < pnzblk[i]; j++) {
                     int jj = pprows[j];
                     int ind = pind[jj];
                     int k = piptr[ind];
                     pjaloc[k] = (_Int) ppcols[j];
                     CVector < _Flt >::CopyVector (b_2, ppelems + j * b_2,
                                                   paloc + k * b_2);
                     piptr[ind]++;
                  }

                  int nimax_temp = 0;

                  int niloc;

                  for (j = 0; j < nlistloc; j++) {
                     niloc = (int) (pialoc[j + 1] - pialoc[j]);
                     if (niloc > nimax_temp)
                        nimax_temp = niloc;
                  }

                  vector < CSortInt > iiarr (nimax_temp + 1);

                  CSortInt *piiarr = &iiarr[0];

                  int k;

                  for (j = 0; j < nlistloc; j++) {
                     niloc = (int) (pialoc[j + 1] - pialoc[j]);
                     int ibeg = (int) pialoc[j];
                     for (k = (int) pialoc[j]; k < pialoc[j + 1]; k++) {
                        piiarr[k - ibeg].ival = (int) pjaloc[k];
                        piiarr[k - ibeg].i2val = (int) (k - ibeg);
                     }
                     sort (piiarr, piiarr + niloc);
                     for (k = (int) pialoc[j]; k < pialoc[j + 1]; k++) {
                        pjaloc[k] = (_Int) (piiarr[k - ibeg].ival);
                        CVector < _Flt >::CopyVector (b_2, paloc + k * b_2,
                                                      ppelems + (k - ibeg) * b_2);
                     }
                     for (k = (int) pialoc[j]; k < pialoc[j + 1]; k++) {
                        int ind = piiarr[k - ibeg].i2val;
                        CVector < _Flt >::CopyVector (b_2, ppelems + ind * b_2,
                                                      paloc + k * b_2);
                     }
                  }

                  pA_sub[i].ReplaceFree (ablk);

               }

               picycle_thr[my_thr] = icycleblk;

            }
         }
      }

// Combine computed data into one hblock

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {

            CBMatrix < _Int, _Flt > *pphmatr_arr = &phmatr_arr[ihblk][0];

            int nzblk_tot = 0;

            int iblk_ext;

            for (iblk_ext = 0; iblk_ext < _nblks_ext_arr[ihblk]; iblk_ext++) {
               nzblk_tot += pphmatr_arr[iblk_ext].GetNzblk ();
            }

            _hmatr_ext_arr[ihblk].SetNzblk (nzblk_tot);
            _hmatr_ext_arr[ihblk].ResizeASub (nzblk_tot);

            CMatrix < int, float >*phmatr = _hmatr_ext_arr[ihblk].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_ext_arr[ihblk].GetASubArr ();

            phmatr->ResizeAndSetAllSp (_nblks_ext_arr[ihblk], _nblks_ext_arr[ihblk],
                                       nzblk_tot, nzblk_tot);

            int *plist_hmatr = phmatr->GetListArr ();
            int *plist2_hmatr = phmatr->GetList2Arr ();
            int *pia_hmatr = phmatr->GetIaArr ();
            int *pja_hmatr = phmatr->GetJaArr ();
            int *pja2_hmatr = phmatr->GetJa2Arr ();

            for (i = 0; i < _nblks_ext_arr[ihblk]; i++)
               plist_hmatr[i] = i;
            for (i = 0; i < _nblks_ext_arr[ihblk]; i++)
               plist2_hmatr[i] = 0;

            pia_hmatr[0] = 0;

            nzblk_tot = 0;

            for (iblk_ext = 0; iblk_ext < _nblks_ext_arr[ihblk]; iblk_ext++) {
               int nzblk_temp = pphmatr_arr[iblk_ext].GetNzblk ();
               CMatrix < int, float >*phmatr_temp = pphmatr_arr[iblk_ext].GetHMatrStr ();
               CMatrix < _Int, _Flt > *pA_sub_temp = pphmatr_arr[iblk_ext].GetASubArr ();
               int *plist_hmatr_temp = phmatr_temp->GetList2Arr ();
               int j;
               for (j = 0; j < nzblk_temp; j++) {
                  int jj2 = plist_hmatr_temp[j];
                  pja_hmatr[nzblk_tot] = jj2;
                  pja2_hmatr[nzblk_tot] = 0;
                  pA_sub[nzblk_tot].ReplaceFree (pA_sub_temp[j]);
                  nzblk_tot++;
               }
               pia_hmatr[iblk_ext + 1] = nzblk_tot;
            }

         }
      }

// Perform column filtering and renumbering of the extended data

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {

            int nblks_ext = _nblks_ext_arr[ihblk];
            CMatrix < int, float >*phmatr = _hmatr_ext_arr[ihblk].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_ext_arr[ihblk].GetASubArr ();

// Compute transposed sparse matrix

            CMatrix < int, float >hmatrT;

            {

               CVectorData < int >imask_temp (nblks_ext * 5 + 2);
               int *pimask_temp = imask_temp.Ptr ();

               for (i = 0; i < nblks_ext; i++)
                  pimask_temp[i] = -1;

               int icycle = -1;

               phmatr->TransposedSparsityListSp (icycle, pimask_temp,
                                                 pimask_temp + nblks_ext,
                                                 pimask_temp + 2 * nblks_ext,
                                                 pimask_temp + 3 * nblks_ext,
                                                 pimask_temp + 4 * nblks_ext, hmatrT);

            }

// Indices Tran2Norm

            int nzja_hmatr = phmatr->GetNzja ();
            int *pia_hmatr = phmatr->GetIaArr ();

            int *pia_hmatrT = hmatrT.GetIaArr ();
            int *pja_hmatrT = hmatrT.GetJaArr ();

            vector < int >indht2h (nzja_hmatr + 1);
            int *pindht2h = &indht2h[0];

            vector < int >iptr (nblks_ext + 1);
            int *piptr = &iptr[0];

            for (i = 0; i < nblks_ext; i++)
               piptr[i] = pia_hmatr[i];

            for (i = 0; i < nblks_ext; i++) {
               int j;
               for (j = pia_hmatrT[i]; j < pia_hmatrT[i + 1]; j++) {
                  int jj = pja_hmatrT[j];
                  int k = piptr[jj];
                  pindht2h[j] = k;
                  piptr[jj]++;
               }
            }

            int nblks_temp = _hblk2blk[ihblk + 1] - _hblk2blk[ihblk];

            long long *ppblks_ext_arr = &(_pblks_ext_arr[ihblk][0]);
            int *pplist_ext_arr = &(_list_ext_arr[ihblk][0]);

#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nblks_ext - nblks_temp; ipar++) {

               int my_thr = 0;
#ifdef USE_THREADS
               my_thr = omp_get_thread_num ();
#endif
               int i, j;
               if (picycle_thr[my_thr] == -1) {
                  pimaskblk_thr[my_thr].resize (5 * _nblks + 4 * nimax + 2);
                  int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
                  int *pimask = pimaskblk + _nblks;
                  for (j = 0; j < _nblks; j++)
                     pimaskblk[j] = -1;
                  for (j = 0; j < nimax; j++)
                     pimask[j] = -1;
               }

               int icycleblk = picycle_thr[my_thr];
               int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
               int *pimask = pimaskblk + _nblks;
               int *plistblk = pimask + nimax;
               int *pindblk = plistblk + _nblks;
               int *pindblk2 = pindblk + _nblks;
               int *pnzblk = pindblk2 + _nblks;
               int *plist = pnzblk + _nblks;
               int *pind = plist + nimax;

// Register current list of columns

               icycleblk++;

               int ibeg = (int) ppblks_ext_arr[ipar];

               for (j = (int) ppblks_ext_arr[ipar]; j < ppblks_ext_arr[ipar + 1]; j++) {
                  int jj = pplist_ext_arr[j * 2];
                  pimask[jj] = icycleblk;
                  pind[jj] = j - ibeg;
               }

// Renumber rows lists in the block row

               for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
                  int nlist_temp = pA_sub[j].GetNlist ();
                  _Int *plist_temp = pA_sub[j].GetListArr ();
                  int k;
                  for (k = 0; k < nlist_temp; k++) {
                     int kk = (int) plist_temp[k];
                     plist_temp[k] = (_Int) pind[kk];
                  }
               }

// Filter columns elems

               for (i = pia_hmatrT[ipar]; i < pia_hmatrT[ipar + 1]; i++) {
                  int ind = pindht2h[i];
                  int nlist_temp = pA_sub[ind].GetNlist ();
                  _Int *pia_temp = pA_sub[ind].GetIaArr ();
                  _Int *pja_temp = pA_sub[ind].GetJaArr ();
                  _Flt *pa_temp = pA_sub[ind].GetAArr ();
                  vector < _Int > ia_new (nlist_temp + 1);
                  _Int *pia_new = &ia_new[0];
                  int nzja_new = 0;
                  pia_new[0] = 0;
                  int k;
                  for (j = 0; j < nlist_temp; j++) {
                     for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                        int kk = (int) pja_temp[k];
                        if (pimask[kk] == icycleblk) {
                           pja_temp[nzja_new] = (_Int) pind[kk];
                           if (nzja_new != k) {
                              CVector < _Flt >::CopyVector (b_2, pa_temp + k * b_2,
                                                            pa_temp + nzja_new * b_2);
                           }
                           nzja_new++;
                        }
                     }
                     pia_new[j + 1] = nzja_new;
                  }
                  for (k = 0; k <= nlist_temp; k++)
                     pia_temp[k] = (_Int) pia_new[k];
                  pA_sub[ind].SetNzja (nzja_new);
                  pA_sub[ind].SetNza (nzja_new * b_2);
               }
               picycle_thr[my_thr] = icycleblk;
            }
         }
      }

   }

// Compute partitioning and binary tree according to sparsity and weights matrix
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::DecompWeightsTree (CMatrix < _Int, _Flt > &_amatr_strW, int _npwr2_ext,
                                 CTree & _tree, int *_list2nd)
   {

      int nloc = _amatr_strW.GetNlist ();

      _Int *plisttot_w = _amatr_strW.GetList2Arr ();
      _Int *piatot_sp = _amatr_strW.GetIaArr ();
      _Int *pjatot_sp = _amatr_strW.GetJaArr ();
      _Int *pjatot_w = _amatr_strW.GetJa2Arr ();

// Find closest extended power 2 value

      int nloc_pwr2 = 1;

      while (nloc_pwr2 < nloc * _npwr2_ext)
         nloc_pwr2 *= 2;

// Create initial binary tree

      CTree treeloc (nloc_pwr2, 2);

      _tree = treeloc;

// Create initial partitioning

      int nnodes_loc = _tree.GetNnodes ();
      int root_loc = _tree.GetRootId ();
      int nlev_loc = _tree.GetNlev ();

      vector < int >ia_order_1 (nnodes_loc + 1);
      vector < int >ia_order_2 (nnodes_loc + 1);
      vector < int >list_nd_1 (nnodes_loc + 1);
      vector < int >list_nd_2 (nnodes_loc + 1);
      vector < int >order (nloc + 1);
      vector < int >imask (nloc + 1);
      vector < int >listloc (nloc + 1);
      vector < int >list2loc (nloc + 1);
      vector < CSortInt > iiarr (nloc + 1);
      vector < int >partition (nloc + 1);

      int *pia_order_1 = &ia_order_1[0];
      int *pia_order_2 = &ia_order_2[0];
      int *plist_nd_1 = &list_nd_1[0];
      int *plist_nd_2 = &list_nd_2[0];
      int *porder = &order[0];
      int *pimask = &imask[0];
      int *plistloc = &listloc[0];
      int *plist2loc = &list2loc[0];
      CSortInt *piiarr = &iiarr[0];
      int *ppartition = &partition[0];

      int icycle = -1;

      int i;

      for (i = 0; i < nloc; i++)
         pimask[i] = -1;
      for (i = 0; i < nloc; i++)
         porder[i] = i;

      int *pia_order_curr = pia_order_1;
      int *pia_order_next = pia_order_2;
      int *plist_nd_curr = plist_nd_1;
      int *plist_nd_next = plist_nd_2;

      int nlist_nd_curr = 1;
      plist_nd_curr[0] = root_loc;
      pia_order_curr[0] = 0;
      pia_order_curr[1] = nloc;

// Cycle over the tree levels

      int *pnchilds = _tree.GetNchilds ();
      vector < int >*pchilds_list = _tree.GetChildsList ();

      int nlist_nd_next, nchilds_curr, ilist, inode_curr, ichild1, ichild2, niloc, ibeg,
         j, jj, k, kk;
      int iloc, nzloc, ishift, njloc, ni1loc, ni2loc, ni1loc_save;
      int *pchilds_curr;

      int ilevloc = 1;

      while (ilevloc < nlev_loc) {

         ilevloc++;

// Cycle over the nodes on current level

         nlist_nd_next = 0;
         pia_order_next[0] = 0;

         for (ilist = 0; ilist < nlist_nd_curr; ilist++) {

            inode_curr = plist_nd_curr[ilist];

            nchilds_curr = pnchilds[inode_curr];
            pchilds_curr = &pchilds_list[inode_curr][0];

            if (nchilds_curr != 2)
               throw " CBMatrix<_Int,_Flt>::DecompWeightsTree: incorrect binary tree ";

            ichild1 = pchilds_curr[0];
            ichild2 = pchilds_curr[1];

            niloc = pia_order_curr[ilist + 1] - pia_order_curr[ilist];

// Partition

            if (niloc == 0) {
            } else if (niloc == 1) {
               plist_nd_next[nlist_nd_next] = ichild1;
               pia_order_next[nlist_nd_next + 1] = pia_order_next[nlist_nd_next] + 1;
               nlist_nd_next++;
            } else if (niloc == 2) {
               plist_nd_next[nlist_nd_next] = ichild1;
               plist_nd_next[nlist_nd_next + 1] = ichild2;
               pia_order_next[nlist_nd_next + 1] = pia_order_next[nlist_nd_next] + 1;
               nlist_nd_next++;
               pia_order_next[nlist_nd_next + 1] = pia_order_next[nlist_nd_next] + 1;
               nlist_nd_next++;
            } else {

               plist_nd_next[nlist_nd_next] = ichild1;
               plist_nd_next[nlist_nd_next + 1] = ichild2;

// Compute the submatrices

               icycle++;

               ibeg = pia_order_curr[ilist];

               for (i = pia_order_curr[ilist]; i < pia_order_curr[ilist + 1]; i++) {
                  iloc = i - ibeg;
                  j = porder[i];
                  plistloc[j] = iloc;
                  pimask[j] = icycle;
               }

               nzloc = 0;

               for (i = pia_order_curr[ilist]; i < pia_order_curr[ilist + 1]; i++) {
                  jj = porder[i];
                  for (k = (int) piatot_sp[jj]; k < piatot_sp[jj + 1]; k++) {
                     kk = (int) pjatot_sp[k];
                     if (pimask[kk] == icycle)
                        nzloc++;
                  }
               }

               CMatrix < _Int, _Flt > aloc;

               aloc.ResizeAndSetAllSp (niloc, niloc, nzloc, nzloc);

               _Int *plistloc_w = aloc.GetList2Arr ();
               _Int *pialoc = aloc.GetIaArr ();
               _Int *pjaloc = aloc.GetJaArr ();
               _Int *pjaloc_w = aloc.GetJa2Arr ();

               nzloc = 0;
               pialoc[0] = 0;

               for (i = pia_order_curr[ilist]; i < pia_order_curr[ilist + 1]; i++) {
                  iloc = i - ibeg;
                  jj = porder[i];
                  plistloc_w[iloc] = plisttot_w[jj];
                  for (k = (int) piatot_sp[jj]; k < piatot_sp[jj + 1]; k++) {
                     kk = (int) pjatot_sp[k];
                     if (pimask[kk] == icycle) {
                        pjaloc[nzloc] = (_Int) plistloc[kk];
                        pjaloc_w[nzloc] = pjatot_w[k];
                        nzloc++;
                     }
                  }
                  pialoc[iloc + 1] = (_Int) nzloc;
               }

               for (i = 0; i < niloc; i++) {
                  ishift = (int) pialoc[i];
                  njloc = (int) (pialoc[i + 1] - pialoc[i]);
                  for (j = (int) pialoc[i]; j < pialoc[i + 1]; j++) {
                     piiarr[j - ishift].ival = (int) pjaloc[j];
                     piiarr[j - ishift].i2val = (int) pjaloc_w[j];
                  }
                  sort (piiarr, piiarr + njloc);
                  for (j = (int) pialoc[i]; j < pialoc[i + 1]; j++) {
                     pjaloc[j] = (_Int) piiarr[j - ishift].ival;
                     pjaloc_w[j] = (_Int) piiarr[j - ishift].i2val;
                  }
               }

// Partition submatrix into two parts

               CMatrix < _Int, _Flt >::DecompWeights (false, aloc, 2, ppartition);

// Store results

               ni1loc = 0;
               ni2loc = 0;

               for (i = 0; i < niloc; i++) {
                  if (ppartition[i] == 0)
                     ni1loc++;
                  if (ppartition[i] == 1)
                     ni2loc++;
               }

               if (ni1loc == niloc) {
                  ppartition[0] = 1;
                  ni1loc = niloc - 1;
                  ni2loc = 1;
               }

               if (ni2loc == niloc) {
                  ppartition[0] = 0;
                  ni2loc = niloc - 1;
                  ni1loc = 1;
               }

               pia_order_next[nlist_nd_next + 1] = pia_order_next[nlist_nd_next] + ni1loc;
               pia_order_next[nlist_nd_next + 2] =
                  pia_order_next[nlist_nd_next + 1] + ni2loc;

               ni1loc_save = ni1loc;

               ni1loc = 0;
               ni2loc = 0;

               for (i = 0; i < niloc; i++) {
                  jj = porder[ibeg + i];
                  if (ppartition[i] == 0) {
                     plist2loc[ni1loc] = jj;
                     ni1loc++;
                  }
                  if (ppartition[i] == 1) {
                     plist2loc[ni1loc_save + ni2loc] = jj;
                     ni2loc++;
                  }
               }

               for (i = 0; i < niloc; i++)
                  porder[ibeg + i] = plist2loc[i];

               nlist_nd_next += 2;

            }

         }

// Switch data

         if (pia_order_curr == pia_order_1) {
            pia_order_curr = pia_order_2;
            pia_order_next = pia_order_1;
            plist_nd_curr = plist_nd_2;
            plist_nd_next = plist_nd_1;
         } else {
            pia_order_curr = pia_order_1;
            pia_order_next = pia_order_2;
            plist_nd_curr = plist_nd_1;
            plist_nd_next = plist_nd_2;
         }

         nlist_nd_curr = nlist_nd_next;

      }

// Prepare return data

      for (i = 0; i < nloc; i++)
         _list2nd[i] = -1;

      for (i = 0; i < nlist_nd_curr; i++) {
         inode_curr = plist_nd_curr[i];
         for (j = pia_order_curr[i]; j < pia_order_curr[i + 1]; j++) {
            jj = porder[j];
            _list2nd[jj] = inode_curr;
         }
      }

// Perform tree filtering if necessary

      if (true) {

// Create extended list of elems for each node

         vector < int >nelems2nd (nnodes_loc + 1);
         int *pnelems2nd = &nelems2nd[0];

         for (i = 0; i < nnodes_loc; i++)
            pnelems2nd[i] = 0;

         for (i = 0; i < nloc; i++) {
            j = _list2nd[i];
            pnelems2nd[j]++;
         }

         int ichild;

         for (i = 0; i < nnodes_loc; i++) {

            nchilds_curr = pnchilds[i];
            pchilds_curr = &pchilds_list[i][0];

            for (j = 0; j < nchilds_curr; j++) {
               ichild = pchilds_curr[j];
               if (ichild != i)
                  pnelems2nd[i] += pnelems2nd[ichild];
            }

         }

         vector < vector < int > >elems_list (nnodes_loc + 1);
         vector < int >*pelems_list = &elems_list[0];

         for (i = 0; i < nnodes_loc; i++)
            pelems_list[i].resize (pnelems2nd[i] + 1);

         for (i = 0; i < nnodes_loc; i++)
            pnelems2nd[i] = 0;

         for (i = 0; i < nloc; i++) {
            j = _list2nd[i];
            int *ppelems_list = &pelems_list[j][0];
            ppelems_list[pnelems2nd[j]] = i;
            pnelems2nd[j]++;
         }

         for (i = 0; i < nnodes_loc; i++) {

            nchilds_curr = pnchilds[i];
            pchilds_curr = &pchilds_list[i][0];

            int *ppelems_list = &pelems_list[i][0];

            for (j = 0; j < nchilds_curr; j++) {
               ichild = pchilds_curr[j];
               int *ppelems_list_ch = &pelems_list[ichild][0];
               if (ichild != i) {
                  for (k = 0; k < pnelems2nd[ichild]; k++) {
                     ppelems_list[pnelems2nd[i]] = ppelems_list_ch[k];
                     pnelems2nd[i]++;
                  }
               }
            }

         }

// Sort and filter list of elems for all nodes

         int ielem;

         for (i = 0; i < nnodes_loc; i++) {

            int *ppelems_list = &pelems_list[i][0];

            if (pnelems2nd[i] > 0)
               sort (ppelems_list, ppelems_list + pnelems2nd[i]);

            int nelems_loc = 0;
            int ielem_curr = -1;

            for (j = 0; j < pnelems2nd[i]; j++) {
               ielem = ppelems_list[j];
               if (ielem != ielem_curr) {
                  ielem_curr = ielem;
                  ppelems_list[nelems_loc] = ielem_curr;
                  nelems_loc++;
               }
            }

            pnelems2nd[i] = nelems_loc;

         }

         for (i = 0; i < nnodes_loc; i++) {

            nchilds_curr = pnchilds[i];
            pchilds_curr = &pchilds_list[i][0];

            if (nchilds_curr > 1 && pnelems2nd[i] == 1) {
               for (j = 0; j < nchilds_curr; j++) {
                  ichild = pchilds_curr[j];
                  if (pnelems2nd[ichild] == 1) {
                     int *ppelems_list = &pelems_list[ichild][0];
                     int ind = ppelems_list[0];
                     _list2nd[ind] = i;
                  }
                  pnelems2nd[ichild] = 0;
               }
            }

         }

// Create filtered tree according to mask array

         vector < int >imasknd (nnodes_loc + 1);
         int *pimasknd = &imasknd[0];

         for (i = 0; i < nnodes_loc; i++) {
            if (pnelems2nd[i] > 0) {
               pimasknd[i] = 1;
            } else {
               pimasknd[i] = 0;
            }
         }

         treeloc.FilterTree (pimasknd, _tree);

         int nnodes_new = 0;

         for (i = 0; i < nnodes_loc; i++) {

            if (pnelems2nd[i] > 0) {
               pimasknd[i] = nnodes_new;
               nnodes_new++;
            }

         }

         int inode_new;

         for (i = nnodes_loc - 1; i >= 0; i--) {

            int *ppelems_list = &pelems_list[i][0];

            if (pnelems2nd[i] > 0) {

               inode_new = pimasknd[i];

               for (j = 0; j < pnelems2nd[i]; j++) {
                  k = ppelems_list[j];
                  _list2nd[k] = inode_new;
               }

            }

         }

      }
// Recompute subtree beg

      _tree.InitSubtreeBeg ();

   }

// Compute matrix decomposition (threads parallelization)
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::DecompWells (void *_comm, int _nneib_well, double _eps_dia_well,
                           double _thresh_max_well, int _ncycle_well, int _degree,
                           int _isize_max, int _isize_max2, int _nparts_bdecomp,
                           int _nparts, int _nparts_W, int _nhblks, int *_hblk2cpu,
                           int *_hblk2blk, long long *_blks,
                           vector < int >*_p_ia_wells_ext, vector < int >*_p_ja_wells_ext,
                           CBMatrix < _Int, _Flt > *_hmatr_arr, int &_n_wells_new,
                           int &_nhblks_new, vector < int >&_hblk2cpu_new,
                           vector < int >&_hblk2blk_new, vector < int >&_blk2type_new,
                           vector < long long >&_blks_new, long long *_order)
   {

#ifdef USE_THREADS
      //n_thr = omp_get_max_threads ();
#endif

// Find local wells for each hblock

      _n_wells_new = 0;

      if (_p_ia_wells_ext == NULL) {

         vector < int >ia_wells;
         vector < int >ja_3index_wells;

         CBMatrix < _Int, _Flt >::FindWells (_comm, _nneib_well, _eps_dia_well,
                                             _thresh_max_well, _nhblks, _hblk2cpu,
                                             _hblk2blk, _blks, _hmatr_arr, ia_wells,
                                             ja_3index_wells);

         int *pia_wells = &ia_wells[0];

         int n_wells = pia_wells[_nhblks];

         _n_wells_new = n_wells;

         int *pja_3index_wells = NULL;
         if (n_wells > 0)
            pja_3index_wells = &ja_3index_wells[0];

         CBMatrix < _Int, _Flt >::DecompWells_impl (_comm, _ncycle_well, _degree,
                                                    _isize_max, _isize_max2,
                                                    _nparts_bdecomp, _nparts, _nparts_W,
                                                    _nhblks, _hblk2cpu, _hblk2blk, _blks,
                                                    _hmatr_arr, pia_wells,
                                                    pja_3index_wells, _nhblks_new,
                                                    _hblk2cpu_new, _hblk2blk_new,
                                                    _blk2type_new, _blks_new, _order);

      } else {

         int *pia_wells = &(*_p_ia_wells_ext)[0];

         int n_wells = pia_wells[_nhblks];

         _n_wells_new = n_wells;

         int *pja_3index_wells = NULL;
         if (n_wells > 0)
            pja_3index_wells = &(*_p_ja_wells_ext)[0];

         CBMatrix < _Int, _Flt >::DecompWells_impl (_comm, _ncycle_well, _degree,
                                                    _isize_max, _isize_max2,
                                                    _nparts_bdecomp, _nparts, _nparts_W,
                                                    _nhblks, _hblk2cpu, _hblk2blk, _blks,
                                                    _hmatr_arr, pia_wells,
                                                    pja_3index_wells, _nhblks_new,
                                                    _hblk2cpu_new, _hblk2blk_new,
                                                    _blk2type_new, _blks_new, _order);

      }

   }

// Find wells
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::FindWells (void *_comm, int _nneib_well, double _eps_dia_well,
                         double _thresh_max_well, int _nhblks, int *_hblk2cpu,
                         int *_hblk2blk, long long *_blks, CBMatrix < _Int,
                         _Flt > *_hmatr_arr, vector < int >&_ia_wells_hblks,
                         vector < int >&_ja_3index_wells_hblks)
   {

      int myid = CMPIDataExchange::GetMyid (_comm);

#ifdef USE_THREADS
      //n_thr = omp_get_max_threads ();
#endif

// Find local wells for each hblock

      {

         vector < int >nwells_hblk (_nhblks + 1);
         vector < vector < int > >listwells_hblk (_nhblks + 1);

         int *pnwells_hblk = &nwells_hblk[0];
         vector < int >*plistwells_hblk = &listwells_hblk[0];

         int ihblk;

         for (ihblk = 0; ihblk < _nhblks; ihblk++)
            pnwells_hblk[ihblk] = 0;

         for (ihblk = 0; ihblk < _nhblks; ihblk++) {
            if (_hblk2cpu[ihblk] == myid) {

               int niblk = _hblk2blk[ihblk + 1] - _hblk2blk[ihblk];

               vector < int >nwells_blk (niblk + 1);
               vector < vector < int > >listwells_blk (niblk + 1);

               int *pnwells_blk = &nwells_blk[0];
               vector < int >*plistwells_blk = &listwells_blk[0];

               {
                  int i;
                  for (i = 0; i < niblk; i++)
                     pnwells_blk[i] = 0;
               }

               CMatrix < int, float >*pHMatrStr = _hmatr_arr[ihblk].GetHMatrStr ();
               CMatrix < _Int, _Flt > *pASub = _hmatr_arr[ihblk].GetASubArr ();

               int *pia_hmatr = pHMatrStr->GetIaArr ();
               int *pja_hmatr = pHMatrStr->GetJaArr ();
               int *pja2_hmatr = pHMatrStr->GetJa2Arr ();

               {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int iblkgl = _hblk2blk[ihblk] + ipar;
                     int niloc = (int) (_blks[iblkgl + 1] - _blks[iblkgl]);
                     CVectorData < int >nzrow (niloc);
                     int *pnzrow = nzrow.Ptr ();
                     int i, ik, jk, jjk, jblk, jhblk, ilist;
                     double daux;
                     for (i = 0; i < niloc; i++)
                        pnzrow[i] = 0;
                     for (i = pia_hmatr[ipar]; i < pia_hmatr[ipar + 1]; i++) {
                        int nlist_temp = pASub[i].GetNlist ();
                        _Int *plist_temp = pASub[i].GetListArr ();
                        _Int *pia_temp = pASub[i].GetIaArr ();
                        for (ik = 0; ik < nlist_temp; ik++) {
                           jjk = (int) plist_temp[ik];
                           pnzrow[jjk] += (int) (pia_temp[ik + 1] - pia_temp[ik]);
                        }
                     }
                     bool b_found_blk = false;
                     for (i = pia_hmatr[ipar]; i < pia_hmatr[ipar + 1]; i++) {
                        jblk = pja_hmatr[i];
                        jhblk = pja2_hmatr[i];
                        if (jblk == ipar && jhblk == ihblk) {
                           b_found_blk = true;
                           int nlist_temp = pASub[i].GetNlist ();
                           _Int *plist_temp = pASub[i].GetListArr ();
                           _Int *pia_temp = pASub[i].GetIaArr ();
                           _Int *pja_temp = pASub[i].GetJaArr ();
                           _Flt *pa_temp = pASub[i].GetAArr ();
                           if (nlist_temp != niloc) {
                              cout <<
                                 " CBMatrix<_Int,_Flt>::DecompWells: error in diagonal block!!! "
                                 << endl;
                              throw
                                 " CBMatrix<_Int,_Flt>::DecompWells: error in diagonal block!!! ";
                           }
                           bool b_check, b_found;
                           for (ik = 0; ik < nlist_temp; ik++) {
                              ilist = (int) plist_temp[ik];
                              b_check = false;
                              if (pnzrow[ilist] >= _nneib_well)
                                 b_check = true;
                              b_found = false;
                              for (jk = (int) pia_temp[ik]; jk < pia_temp[ik + 1]; jk++) {
                                 jjk = (int) pja_temp[jk];
                                 if (jjk == ilist) {
                                    daux = (double) pa_temp[jk];
                                    if (daux < 0.0e0)
                                       daux = -daux;
                                    if (daux < _eps_dia_well)
                                       b_check = true;
                                    b_found = true;
                                 }
                                 if (_thresh_max_well > 0) {
                                    daux = (double) pa_temp[jk];
                                    if (daux < 0.0e0)
                                       daux = -daux;
                                    if (daux > _thresh_max_well)
                                       b_check = true;
                                 }
                              }
                              if (!b_found)
                                 b_check = true;
                              if (b_check) {
                                 pnwells_blk[ipar]++;
                                 plistwells_blk[ipar].push_back (ilist);
                                 plistwells_blk[ipar].push_back (ipar);
                                 plistwells_blk[ipar].push_back (ihblk);
                              }
                           }
                        }
                     }
                     if (!b_found_blk) {
                        for (ik = 0; ik < niloc; ik++) {
                           pnwells_blk[ipar]++;
                           plistwells_blk[ipar].push_back (ik);
                           plistwells_blk[ipar].push_back (ipar);
                           plistwells_blk[ipar].push_back (ihblk);
                        }
                     }
                  }

               }

               int iblk, j, jj, jj2, jhblk;

               for (iblk = 0; iblk < niblk; iblk++) {
                  for (j = 0; j < pnwells_blk[iblk]; j++) {
                     jj = plistwells_blk[iblk][j * 3];
                     jj2 = plistwells_blk[iblk][j * 3 + 1];
                     jhblk = plistwells_blk[iblk][j * 3 + 2];
                     pnwells_hblk[ihblk]++;
                     plistwells_hblk[ihblk].push_back (jj);
                     plistwells_hblk[ihblk].push_back (jj2);
                     plistwells_hblk[ihblk].push_back (jhblk);
                  }
               }

            }
         }

         CMPIDataExchange::ExchangeArray (_comm, 'I', '+', _nhblks, pnwells_hblk);

         _ia_wells_hblks.resize (_nhblks + 1);
         int *p_ia_wells_hblks = &_ia_wells_hblks[0];

         int i;

         p_ia_wells_hblks[0] = 0;
         for (i = 0; i < _nhblks; i++)
            p_ia_wells_hblks[i + 1] = p_ia_wells_hblks[i] + pnwells_hblk[i];

         int nzja_wells = p_ia_wells_hblks[_nhblks];

         _ja_3index_wells_hblks.resize (nzja_wells * 3 + 1);
         int *pja_3index_wells = &_ja_3index_wells_hblks[0];

         for (i = 0; i < nzja_wells * 3; i++)
            pja_3index_wells[i] = 0;

         int ibeg, niloc;
         int *pplistwells_hblk = NULL;

         for (ihblk = 0; ihblk < _nhblks; ihblk++) {
            if (_hblk2cpu[ihblk] == myid) {
               ibeg = p_ia_wells_hblks[ihblk] * 3;
               niloc = p_ia_wells_hblks[ihblk + 1] - p_ia_wells_hblks[ihblk];
               pplistwells_hblk = NULL;
               if (niloc > 0)
                  pplistwells_hblk = &plistwells_hblk[ihblk][0];
               for (i = 0; i < 3 * niloc; i++)
                  pja_3index_wells[ibeg + i] = pplistwells_hblk[i];
            }
         }

         CMPIDataExchange::ExchangeArray (_comm, 'I', '+', nzja_wells * 3,
                                          pja_3index_wells);

      }

   }

// Implement matrix decomposition (threads parallelization)
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::DecompWells_impl (void *_comm, int _ncycle_well, int _degree,
                                int _isize_max, int _isize_max2, int _nparts_bdecomp,
                                int _nparts, int _nparts_W, int _nhblks, int *_hblk2cpu,
                                int *_hblk2blk, long long *_blks, CBMatrix < _Int,
                                _Flt > *_hmatr_arr, int *_ia_wells_hblks,
                                int *_ja_wells_3index_hblks, int &_nhblks_new,
                                vector < int >&_hblk2cpu_new,
                                vector < int >&_hblk2blk_new,
                                vector < int >&_blk2type_new,
                                vector < long long >&_blks_new, long long *_order)
   {

      int myid = CMPIDataExchange::GetMyid (_comm);
      int nproc = CMPIDataExchange::GetNproc (_comm);

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      int nblks_tot = _hblk2blk[_nhblks];

// For all wells compute their extended neigbours (there can be some conflicts that should be resolved)

      CVectorData < int >ia_wells_hblks_curr (_nhblks + 1);
      CVectorData < int >ja_3index_wells_hblks_curr;

      int *pia_wells_hblks_curr = ia_wells_hblks_curr.Ptr ();

      int n_wells_ini = _ia_wells_hblks[_nhblks];

      ja_3index_wells_hblks_curr.resize (3 * n_wells_ini);

      {

         int *pia_wells_hblks_curr = ia_wells_hblks_curr.Ptr ();
         int *pja_3index_wells_hblks_curr = ja_3index_wells_hblks_curr.Ptr ();

         int i;

         for (i = 0; i <= _nhblks; i++)
            pia_wells_hblks_curr[i] = _ia_wells_hblks[i];
         for (i = 0; i < 3 * n_wells_ini; i++)
            pja_3index_wells_hblks_curr[i] = _ja_wells_3index_hblks[i];

      }

      int icycle_ext;

// Main wells extension cycle

      CVectorData < int >ia_wells_hblks_next (_nhblks + 1);
      CVectorData < int >ja_3index_wells_hblks_next;

      vector < CVectorData < int > >imask_hblks (_nhblks + 1);
      CVectorData < int >*pimask_hblks = &imask_hblks[0];

      vector < CVectorData < int > >list_wneib_hblks (_nhblks + 1);
      CVectorData < int >*plist_wneib_hblks = &list_wneib_hblks[0];

      vector < CVectorData < int > >ja_3index_wneib_hblks (_nhblks + 1);
      CVectorData < int >*pja_3index_wneib_hblks = &ja_3index_wneib_hblks[0];

      int nhblks_max = _nhblks + 1;
      int nblks_max = nblks_tot + _nhblks + 1;

      CVectorData < int >hblk2blks_ord (nhblks_max + 1);
      CVectorData < int >hblk2cpu_ord (nhblks_max);
      CVectorData < long long >blks_ord (nblks_tot + _nhblks + 2);

      int *pia_wells_hblks_next = ia_wells_hblks_next.Ptr ();

      icycle_ext = 0;

      while (icycle_ext == 0 || icycle_ext < _ncycle_well) {

         int *pja_3index_wells_hblks_curr = ja_3index_wells_hblks_curr.Ptr ();

         int n_wells = pia_wells_hblks_curr[_nhblks];

         vector < int >ia_wneib_ini (n_wells + 1);

         int *pia_wneib_ini = &ia_wneib_ini[0];

         CVectorData < int >ja_wneib_3index;

         {

            {
               for (int i = 0; i < n_wells + 1; i++)
                  pia_wneib_ini[i] = 0;
            }

            int ihblk;

            for (ihblk = 0; ihblk < _nhblks; ihblk++) {
               if (_hblk2cpu[ihblk] == myid && _ncycle_well > 0) {

                  CMatrix < int, float >*pHMatrStr = _hmatr_arr[ihblk].GetHMatrStr ();
                  CMatrix < _Int, _Flt > *pASub = _hmatr_arr[ihblk].GetASubArr ();

                  int *pia_hmatr = pHMatrStr->GetIaArr ();
                  int *pja_hmatr = pHMatrStr->GetJaArr ();
                  int *pja2_hmatr = pHMatrStr->GetJa2Arr ();

                  {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                     for (int ipar = pia_wells_hblks_curr[ihblk];
                          ipar < pia_wells_hblks_curr[ihblk + 1]; ipar++) {
                        int jj = pja_3index_wells_hblks_curr[ipar * 3];
                        int jblk = pja_3index_wells_hblks_curr[ipar * 3 + 1];
                        int i, ik, jjk, kblk, khblk, k, kkk;
                        for (i = pia_hmatr[jblk]; i < pia_hmatr[jblk + 1]; i++) {
                           kblk = pja_hmatr[i];
                           khblk = pja2_hmatr[i];
                           int nlist_temp = pASub[i].GetNlist ();
                           _Int *plist_temp = pASub[i].GetListArr ();
                           _Int *pia_temp = pASub[i].GetIaArr ();
                           _Int *pja_temp = pASub[i].GetJaArr ();
                           for (ik = 0; ik < nlist_temp; ik++) {
                              jjk = (int) plist_temp[ik];
                              if (jjk == jj) {
                                 for (k = (int) pia_temp[ik]; k < pia_temp[ik + 1]; k++) {
                                    kkk = (int) pja_temp[k];
                                    if (kkk != jj || kblk != jblk || khblk != ihblk) {
                                       pia_wneib_ini[ipar + 1]++;
                                    }
                                 }
                              }
                           }
                        }
                     }

                  }

               }
            }

            CMPIDataExchange::ExchangeArray (_comm, 'I', '+', n_wells + 1, pia_wneib_ini);

            {
               for (int i = 0; i < n_wells; i++)
                  pia_wneib_ini[i + 1] += pia_wneib_ini[i];
            }

            int nzja_wneib_ini = pia_wneib_ini[n_wells];

            ja_wneib_3index.resize (nzja_wneib_ini * 3);
            int *pja_wneib_3index = ja_wneib_3index.Ptr ();

            CVectorInt < int >::SetByZeroes_thr (nzja_wneib_ini * 3, pja_wneib_3index);

            for (ihblk = 0; ihblk < _nhblks; ihblk++) {
               if (_hblk2cpu[ihblk] == myid && _ncycle_well > 0) {

                  CMatrix < int, float >*pHMatrStr = _hmatr_arr[ihblk].GetHMatrStr ();
                  CMatrix < _Int, _Flt > *pASub = _hmatr_arr[ihblk].GetASubArr ();

                  int *pia_hmatr = pHMatrStr->GetIaArr ();
                  int *pja_hmatr = pHMatrStr->GetJaArr ();
                  int *pja2_hmatr = pHMatrStr->GetJa2Arr ();

                  {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                     for (int ipar = pia_wells_hblks_curr[ihblk];
                          ipar < pia_wells_hblks_curr[ihblk + 1]; ipar++) {
                        int jj = pja_3index_wells_hblks_curr[ipar * 3];
                        int jblk = pja_3index_wells_hblks_curr[ipar * 3 + 1];
                        int ibs = pia_wneib_ini[ipar];
                        int i, ik, jjk, kblk, khblk, k, kkk;
                        for (i = pia_hmatr[jblk]; i < pia_hmatr[jblk + 1]; i++) {
                           kblk = pja_hmatr[i];
                           khblk = pja2_hmatr[i];
                           int nlist_temp = pASub[i].GetNlist ();
                           _Int *plist_temp = pASub[i].GetListArr ();
                           _Int *pia_temp = pASub[i].GetIaArr ();
                           _Int *pja_temp = pASub[i].GetJaArr ();
                           for (ik = 0; ik < nlist_temp; ik++) {
                              jjk = (int) plist_temp[ik];
                              if (jjk == jj) {
                                 for (k = (int) pia_temp[ik]; k < pia_temp[ik + 1]; k++) {
                                    kkk = (int) pja_temp[k];
                                    if (kkk != jj || kblk != jblk || khblk != ihblk) {
                                       pja_wneib_3index[ibs * 3] = kkk;
                                       pja_wneib_3index[ibs * 3 + 1] = kblk;
                                       pja_wneib_3index[ibs * 3 + 2] = khblk;
                                       ibs++;
                                    }
                                 }
                              }
                           }
                        }
                     }

                  }

               }
            }

            CMPIDataExchange::ExchangeArray (_comm, 'I', '+', nzja_wneib_ini * 3,
                                             pja_wneib_3index);

         }

// Resolve possible conflicts in well neigbours

         vector < int >ia_wneib_flt (n_wells + 1);

         int *phblk2blks_ord = hblk2blks_ord.Ptr ();
         int *phblk2cpu_ord = hblk2cpu_ord.Ptr ();
         long long *pblks_ord = blks_ord.Ptr ();

         {
            int i;
            for (i = 0; i < nhblks_max; i++)
               phblk2blks_ord[i] = _hblk2blk[i];
            phblk2blks_ord[nhblks_max] = nblks_max;
            for (i = 0; i < _nhblks; i++)
               phblk2cpu_ord[i] = _hblk2cpu[i];
            phblk2cpu_ord[nhblks_max - 1] = 0;
            for (i = 0; i < nblks_max + 1; i++)
               pblks_ord[i] = 0;
         }

         {

            int *pja_wneib_3index = ja_wneib_3index.Ptr ();

// Init masks

            int ihblk;

            for (ihblk = 0; ihblk < _nhblks; ihblk++) {
               if (_hblk2cpu[ihblk] == myid) {

                  int ibegblk = _hblk2blk[ihblk];
                  int iendblk = _hblk2blk[ihblk + 1] - 1;
                  int niblk = iendblk + 1 - ibegblk;
                  int ni_curr = (int) (_blks[iendblk + 1] - _blks[ibegblk]);

                  pimask_hblks[ihblk].resize (ni_curr);

                  int *ppimask_hblks = pimask_hblks[ihblk].Ptr ();

                  {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                     for (int ipar = 0; ipar < niblk; ipar++) {
                        int iblkgl = _hblk2blk[ihblk] + ipar;
                        int ni_loc = (int) (_blks[iblkgl + 1] - _blks[iblkgl]);
                        int ishift = (int) (_blks[iblkgl] - _blks[ibegblk]);
                        int j;
                        for (j = 0; j < ni_loc; j++)
                           ppimask_hblks[ishift + j] = -1;
                     }

                  }

               }

            }

// Register wells

            for (ihblk = 0; ihblk < _nhblks; ihblk++) {
               if (_hblk2cpu[ihblk] == myid) {
                  int *ppimask_hblks = pimask_hblks[ihblk].Ptr ();
                  int ibegblk = _hblk2blk[ihblk];
                  int i;
                  for (i = pia_wells_hblks_curr[ihblk];
                       i < pia_wells_hblks_curr[ihblk + 1]; i++) {
                     int jj = pja_3index_wells_hblks_curr[i * 3];
                     int jblk = pja_3index_wells_hblks_curr[i * 3 + 1];
                     int jblkgl = _hblk2blk[ihblk] + jblk;
                     int ishift = (int) (_blks[jblkgl] - _blks[ibegblk]);
                     ppimask_hblks[ishift + jj] = -2;
                  }
               }
            }

// Register neibours

            for (ihblk = 0; ihblk < _nhblks; ihblk++) {
               int i, j;
               for (i = pia_wells_hblks_curr[ihblk]; i < pia_wells_hblks_curr[ihblk + 1];
                    i++) {
                  for (j = pia_wneib_ini[i]; j < pia_wneib_ini[i + 1]; j++) {
                     int jj = pja_wneib_3index[j * 3];
                     int jblk = pja_wneib_3index[j * 3 + 1];
                     int jhblk = pja_wneib_3index[j * 3 + 2];
                     if (_hblk2cpu[jhblk] == myid) {
                        int jbegblk = _hblk2blk[jhblk];
                        int *ppimask_hblks = pimask_hblks[jhblk].Ptr ();
                        int jblkgl = _hblk2blk[jhblk] + jblk;
                        int ishift = (int) (_blks[jblkgl] - _blks[jbegblk]);
                        if (ppimask_hblks[ishift + jj] == -1) {
                           ppimask_hblks[ishift + jj] = i;
                        } else {
                           pja_wneib_3index[j * 3] = -1;
                           pja_wneib_3index[j * 3 + 1] = -1;
                           pja_wneib_3index[j * 3 + 2] = -1;
                        }
                     } else {
                        pja_wneib_3index[j * 3] = 0;
                        pja_wneib_3index[j * 3 + 1] = 0;
                        pja_wneib_3index[j * 3 + 2] = 0;
                     }
                  }
               }
            }

            int nzja_wneib_ini = pia_wneib_ini[n_wells];

            CMPIDataExchange::ExchangeArray (_comm, 'I', '+', nzja_wneib_ini * 3,
                                             pja_wneib_3index);

// Scan masks

            for (ihblk = 0; ihblk < _nhblks; ihblk++) {
               if (_hblk2cpu[ihblk] == myid) {

                  int ibegblk = _hblk2blk[ihblk];
                  int iendblk = _hblk2blk[ihblk + 1] - 1;
                  int niblk = iendblk + 1 - ibegblk;
                  int ni_curr = (int) (_blks[iendblk + 1] - _blks[ibegblk]);

                  int *ppimask_hblks = pimask_hblks[ihblk].Ptr ();

                  vector < vector < int > >list_wneib_blks (niblk + 1);
                  vector < int >*plist_wneib_blks = &list_wneib_blks[0];

                  vector < vector < int > >ja_3index_wneib_blks (niblk + 1);
                  vector < int >*pja_3index_wneib_blks = &ja_3index_wneib_blks[0];

                  {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                     for (int ipar = 0; ipar < niblk; ipar++) {
                        int iblkgl = _hblk2blk[ihblk] + ipar;
                        int ni_loc = (int) (_blks[iblkgl + 1] - _blks[iblkgl]);
                        int ishift = (int) (_blks[iblkgl] - _blks[ibegblk]);
                        int j;
                        int nzloc = 0;
                        for (j = 0; j < ni_loc; j++) {
                           if (ppimask_hblks[ishift + j] == -1)
                              nzloc++;
                           if (ppimask_hblks[ishift + j] >= 0) {
                              plist_wneib_blks[ipar].push_back (ishift + j);
                           }
                           if (ppimask_hblks[ishift + j] >= 0
                               || ppimask_hblks[ishift + j] == -2) {
                              pja_3index_wneib_blks[ipar].push_back (j);
                              pja_3index_wneib_blks[ipar].push_back (ipar);
                              pja_3index_wneib_blks[ipar].push_back (ihblk);
                           }
                        }
                        pblks_ord[iblkgl + 1] = nzloc;
                     }

                  }

                  {
                     int i;
                     int nz_wneib = 0;
                     for (i = 0; i < niblk; i++) {
                        nz_wneib += (int) plist_wneib_blks[i].size ();
                     }
                     plist_wneib_hblks[ihblk].resize (nz_wneib);
                     int *pplist_wneib_hblks = plist_wneib_hblks[ihblk].Ptr ();
                     nz_wneib = 0;
                     int j, nzloc;
                     for (i = 0; i < niblk; i++) {
                        nzloc = (int) plist_wneib_blks[i].size ();
                        if (nzloc > 0) {
                           int *pplist_wneib_blks = &plist_wneib_blks[i][0];
                           for (j = 0; j < nzloc; j++) {
                              pplist_wneib_hblks[nz_wneib] = pplist_wneib_blks[j];
                              nz_wneib++;
                           }
                        }
                     }
                     nz_wneib = 0;
                     for (i = 0; i < niblk; i++) {
                        nz_wneib += (int) pja_3index_wneib_blks[i].size ();
                     }
                     pja_3index_wneib_hblks[ihblk].resize (nz_wneib);
                     int *ppja_3index_wneib_hblks = pja_3index_wneib_hblks[ihblk].Ptr ();
                     nz_wneib = 0;
                     for (i = 0; i < niblk; i++) {
                        nzloc = (int) pja_3index_wneib_blks[i].size ();
                        if (nzloc > 0) {
                           int *ppja_3index_wneib_blks = &pja_3index_wneib_blks[i][0];
                           for (j = 0; j < nzloc; j++) {
                              ppja_3index_wneib_hblks[nz_wneib] =
                                 ppja_3index_wneib_blks[j];
                              nz_wneib++;
                           }
                        }
                     }

                  }

                  {
                     int i;
                     int nzloc = 0;
                     for (i = 0; i < niblk; i++) {
                        nzloc += (int) pblks_ord[ibegblk + i + 1];
                     }
                     int nwells_loc =
                        pia_wells_hblks_curr[ihblk + 1] - pia_wells_hblks_curr[ihblk];
                     pblks_ord[nblks_tot + ihblk + 1] = ni_curr - nwells_loc - nzloc;
                  }

               }

            }

            if (myid == 0)
               pblks_ord[nblks_tot + _nhblks + 1] = n_wells;

            CMPIDataExchange::ExchangeArray (_comm, 'L', '+', nblks_max + 1, pblks_ord);

            {
               int i;
               for (i = 0; i < nblks_max; i++)
                  pblks_ord[i + 1] += pblks_ord[i];
            }

         }

// Compute list of next wells

         if (icycle_ext < _ncycle_well - 1) {

            {

               int i;

               for (i = 0; i <= _nhblks; i++)
                  pia_wells_hblks_next[i] = 0;

               for (i = 0; i < _nhblks; i++) {
                  if (_hblk2cpu[i] == myid) {
                     int nwells_temp = pja_3index_wneib_hblks[i].GetLength () / 3;
                     pia_wells_hblks_next[i + 1] = nwells_temp;
                  }
               }

            }

            CMPIDataExchange::ExchangeArray (_comm, 'I', '+', _nhblks + 1,
                                             pia_wells_hblks_next);

            {
               int i;
               for (i = 0; i < _nhblks; i++)
                  pia_wells_hblks_next[i + 1] += pia_wells_hblks_next[i];
            }

            int nwells_next = pia_wells_hblks_next[_nhblks];

            ja_3index_wells_hblks_next.resize (nwells_next * 3);

            int *pja_3index_wells_hblks_next = ja_3index_wells_hblks_next.Ptr ();

            CVectorInt < int >::SetByZeroes_thr (nwells_next * 3,
                                                 pja_3index_wells_hblks_next);

            {
               int i;
               for (i = 0; i < _nhblks; i++) {
                  if (_hblk2cpu[i] == myid) {
                     int nwells_temp = pja_3index_wneib_hblks[i].GetLength () / 3;
                     int *ppja_3index_wneib_hblks = pja_3index_wneib_hblks[i].Ptr ();
                     int ibs = pia_wells_hblks_next[i];
                     CVectorInt < int >::CopyVectorInt_thr (nwells_temp * 3,
                                                            ppja_3index_wneib_hblks,
                                                            pja_3index_wells_hblks_next +
                                                            ibs * 3);
                  }
               }
            }

            CMPIDataExchange::ExchangeArray (_comm, 'I', '+', nwells_next * 3,
                                             pja_3index_wells_hblks_next);

            {
               int i;
               for (i = 0; i <= _nhblks; i++)
                  pia_wells_hblks_curr[i] = pia_wells_hblks_next[i];
            }

            ja_3index_wells_hblks_curr.swap (ja_3index_wells_hblks_next);

         }

         icycle_ext++;

      }

      int *pja_3index_wells_hblks_curr = ja_3index_wells_hblks_curr.Ptr ();

// Compute ordering array

      int *phblk2blks_ord = hblk2blks_ord.Ptr ();
      int *phblk2cpu_ord = hblk2cpu_ord.Ptr ();
      long long *pblks_ord = blks_ord.Ptr ();

      bool b_blk_wells = false;
      if (n_wells_ini > 0)
         b_blk_wells = true;

      CVectorData < long long >order_ini;
      CVectorData < long long >iorder2ind_ini;

      CVectorData < long long >ibs_ord (nhblks_max);
      CVectorData < long long >ibs_iord (nhblks_max);

      long long *pibs_ord = ibs_ord.Ptr ();
      long long *pibs_iord = ibs_iord.Ptr ();

      {
         int i;
         for (i = 0; i < nhblks_max; i++)
            pibs_ord[i] = -1;
         for (i = 0; i < nhblks_max; i++)
            pibs_iord[i] = -1;
      }

      {

         int nz_ord = 0;

         int ihblk;

         for (ihblk = 0; ihblk < _nhblks; ihblk++) {
            if (_hblk2cpu[ihblk] == myid) {
               int ibegblk = _hblk2blk[ihblk];
               int iendblk = _hblk2blk[ihblk + 1] - 1;
               int ni_curr = (int) (_blks[iendblk + 1] - _blks[ibegblk]);
               pibs_ord[ihblk] = nz_ord;
               nz_ord += ni_curr;
            }
         }

         order_ini.resize (nz_ord);
         long long *porder_ini = order_ini.Ptr ();

         CVectorInt < long long >::SetByZeroes_thr (nz_ord, porder_ini);

         nz_ord = 0;

         for (ihblk = 0; ihblk < nhblks_max; ihblk++) {
            if (phblk2cpu_ord[ihblk] == myid || (ihblk == nhblks_max - 1 && b_blk_wells)) {
               int ibegblk = phblk2blks_ord[ihblk];
               int iendblk = phblk2blks_ord[ihblk + 1] - 1;
               int ni_curr = (int) (pblks_ord[iendblk + 1] - pblks_ord[ibegblk]);
               pibs_iord[ihblk] = nz_ord;
               nz_ord += ni_curr;
            }
         }

         iorder2ind_ini.resize (2 * nz_ord);
         long long *piorder2ind_ini = iorder2ind_ini.Ptr ();

         CVectorInt < long long >::SetByZeroes_thr (nz_ord * 2, piorder2ind_ini);

      }

      long long *porder_ini = order_ini.Ptr ();
      long long *piorder2ind_ini = iorder2ind_ini.Ptr ();

      if (b_blk_wells) {
         int ihblk = nhblks_max - 1;
         if (ihblk >= 0) {
            long long ibs = pibs_iord[ihblk];
            int ibegblk = phblk2blks_ord[ihblk];
            int iendblk = phblk2blks_ord[ihblk + 1] - 1;
            int ni_curr = (int) (pblks_ord[iendblk + 1] - pblks_ord[ibegblk]);
            CVectorInt < long long >::SetByZeroes_thr (ni_curr * 2,
                                                       piorder2ind_ini + ibs * 2);
         }
      }

      {

         int nz_ord = 0;

         int ihblk;

         for (ihblk = 0; ihblk < _nhblks; ihblk++) {
            if (_hblk2cpu[ihblk] == myid) {

               int ibegblk = _hblk2blk[ihblk];
               int iendblk = _hblk2blk[ihblk + 1] - 1;
               int niblk = iendblk + 1 - ibegblk;
               int ni_curr = (int) (_blks[iendblk + 1] - _blks[ibegblk]);

               int *ppimask_hblks = pimask_hblks[ihblk].Ptr ();

               {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int iblkgl = _hblk2blk[ihblk] + ipar;
                     int ni_loc = (int) (_blks[iblkgl + 1] - _blks[iblkgl]);
                     int ishift = (int) (_blks[iblkgl] - _blks[ibegblk]);
                     int j;
                     long long ibs = pblks_ord[iblkgl];
                     long long ibeg_ord = pblks_ord[ibegblk];
                     long long ibs_o = pibs_ord[ihblk];
                     long long ibs_io = pibs_iord[ihblk];
                     long long ind, ind1;
                     for (j = 0; j < ni_loc; j++) {
                        if (ppimask_hblks[ishift + j] == -1) {
                           ind1 = ibs_o + ishift + j;
                           if (porder_ini[ind1] != 0) {
                              cout <<
                                 " CBMatrix <>::DecompWells_impl: error 1 in order !!!" <<
                                 endl;
                              throw " CBMatrix<>::DecompWells_impl: error 1 in order !!!";
                           }
                           porder_ini[ind1] = ibs;
                           ind = ibs_io + ibs - ibeg_ord;
                           if (piorder2ind_ini[ind * 2] != 0) {
                              cout <<
                                 " CBMatrix <>::DecompWells_impl: error 2 in order !!!" <<
                                 endl;
                              throw " CBMatrix<>::DecompWells_impl: error 2 in order !!!";
                           }
                           piorder2ind_ini[ind * 2] = ishift + j;
                           piorder2ind_ini[ind * 2 + 1] = ihblk;
                           ibs++;
                        }
                     }
                  }

               }

               {
                  long long ibs = pblks_ord[nblks_tot + ihblk];
                  long long ibs_o = pibs_ord[ihblk];
                  long long ibs_io = pibs_iord[nhblks_max - 1];
                  long long ibeg_ord = pblks_ord[nblks_tot];
                  int isize_wneib = plist_wneib_hblks[ihblk].GetLength ();
                  int *pplist_wneib_hblks = plist_wneib_hblks[ihblk].Ptr ();
                  int i, j;
                  long long ind, ind1;
                  for (i = 0; i < isize_wneib; i++) {
                     j = pplist_wneib_hblks[i];
                     ind1 = ibs_o + j;
                     if (porder_ini[ind1] != 0) {
                        cout << " CBMatrix <>::DecompWells_impl: error 3 in order !!!" <<
                           endl;
                        throw " CBMatrix<>::DecompWells_impl: error 3 in order !!!";
                     }
                     porder_ini[ind1] = ibs;
                     ind = ibs_io + ibs - ibeg_ord;
                     if (piorder2ind_ini[ind * 2] != 0) {
                        cout << " CBMatrix <>::DecompWells_impl: error 4 in order !!!" <<
                           endl;
                        throw " CBMatrix<>::DecompWells_impl: error 4 in order !!!";
                     }
                     piorder2ind_ini[ind * 2] = j;
                     piorder2ind_ini[ind * 2 + 1] = ihblk;
                     ibs++;
                  }
               }

               {
                  long long ibs =
                     pblks_ord[nblks_tot + _nhblks] + pia_wells_hblks_curr[ihblk];
                  long long ibeg_ord = ibs;
                  long long ibs_o = pibs_ord[ihblk];
                  long long ibs_io =
                     pibs_iord[nhblks_max - 1] + (pblks_ord[nblks_tot + _nhblks] +
                                                  pia_wells_hblks_curr[ihblk] -
                                                  pblks_ord[nblks_tot]);
                  int i, jj, jblk, jblkgl, ishift;
                  long long ind, ind1;
                  for (i = pia_wells_hblks_curr[ihblk];
                       i < pia_wells_hblks_curr[ihblk + 1]; i++) {
                     jj = pja_3index_wells_hblks_curr[i * 3];
                     jblk = pja_3index_wells_hblks_curr[i * 3 + 1];
                     jblkgl = ibegblk + jblk;
                     ishift = (int) (_blks[jblkgl] - _blks[ibegblk]);
                     ind1 = ibs_o + ishift + jj;
                     if (porder_ini[ind1] != 0) {
                        cout << " CBMatrix <>::DecompWells_impl: error 5 in order !!!" <<
                           endl;
                        throw " CBMatrix<>::DecompWells_impl: error 5 in order !!!";
                     }
                     porder_ini[ind1] = ibs;
                     ind = ibs_io + ibs - ibeg_ord;
                     if (piorder2ind_ini[ind * 2] != 0) {
                        cout << " CBMatrix <>::DecompWells_impl: error 6 in order !!!" <<
                           endl;
                        throw " CBMatrix<>::DecompWells_impl: error 6 in order !!!";
                     }
                     piorder2ind_ini[ind * 2] = ishift + jj;
                     piorder2ind_ini[ind * 2 + 1] = ihblk;
                     ibs++;
                  }
               }

               nz_ord += ni_curr;

            }

         }
      }

      if (b_blk_wells) {
         int ihblk = nhblks_max - 1;
         long long ibs = pibs_iord[ihblk];
         int ibegblk = phblk2blks_ord[ihblk];
         int iendblk = phblk2blks_ord[ihblk + 1] - 1;
         int ni_curr = (int) (pblks_ord[iendblk + 1] - pblks_ord[ibegblk]);
         CMPIDataExchange::ExchangeArray (_comm, 'L', '+', ni_curr * 2,
                                          piorder2ind_ini + ibs * 2);
      }
// Reformat partitionings

// Filter zero data first

      int nhblks_flt = 0;

      {
         int nblks_flt = 0;
         int ihblk, i, ibegblk, iendblk;
         for (ihblk = 0; ihblk < nhblks_max; ihblk++) {
            ibegblk = phblk2blks_ord[ihblk];
            iendblk = phblk2blks_ord[ihblk + 1] - 1;
            if (pblks_ord[iendblk + 1] > pblks_ord[ibegblk]) {
               for (i = ibegblk; i <= iendblk; i++) {
                  if (pblks_ord[i + 1] > pblks_ord[i]) {
                     pblks_ord[nblks_flt + 1] = pblks_ord[i + 1];
                     nblks_flt++;
                  }
               }
               phblk2blks_ord[nhblks_flt + 1] = nblks_flt;
               phblk2cpu_ord[nhblks_flt] = phblk2cpu_ord[ihblk];
               pibs_iord[nhblks_flt] = pibs_iord[ihblk];
               nhblks_flt++;
            }
         }
      }

// Modify partitioning for last hblock

      if (b_blk_wells) {
         int nblks_flt = phblk2blks_ord[nhblks_flt];
         int nblks_flt1 = nblks_flt - 1;
         int nblks_ini = phblk2blks_ord[nhblks_flt - 1];
         long long ntot = pblks_ord[nblks_flt];
         long long ntot1 = pblks_ord[nblks_flt1];
         int isize_mean = (int) (ntot + nblks_ini) / (nblks_ini + 1);
         int ni_last = (int) (pblks_ord[nblks_flt1] - pblks_ord[nblks_ini]);
         int isize_last = isize_mean / 4;
         if (isize_last <= 0)
            isize_last = 1;
         int nblks_last = (ni_last + isize_last - 1) / isize_last;
         int nblks_new = nblks_ini + nblks_last + 1;
         CVectorData < long long >blks_new (nblks_new + 1);
         long long *pblks_new = blks_new.Ptr ();
         int i;
         for (i = 0; i <= nblks_ini; i++)
            pblks_new[i] = pblks_ord[i];
         for (i = 0; i < nblks_last - 1; i++)
            pblks_new[nblks_ini + i + 1] = pblks_new[nblks_ini + i] + isize_last;
         pblks_new[nblks_new - 1] = ntot1;
         pblks_new[nblks_new] = ntot;
         blks_ord.swap (blks_new);
         phblk2blks_ord[nhblks_flt] = nblks_new;
      }

      pblks_ord = blks_ord.Ptr ();

// Repartition matrix

      vector < CBMatrix < _Int, _Flt > >hmatr_ord (nhblks_flt + 1);
      CBMatrix < _Int, _Flt > *phmatr_ord = &hmatr_ord[0];

      CBMatrix < _Int, _Flt >::ReorderHMatrix (_comm, _nhblks, _hblk2cpu, _hblk2blk,
                                               _blks, _hmatr_arr, porder_ini, nhblks_flt,
                                               phblk2cpu_ord, phblk2blks_ord, pblks_ord,
                                               phmatr_ord);

// For each hblock diagonal part without wells perform its initial ordering and partitioning

      vector < CVectorData < int > >order_dia (nhblks_flt + 1);
      vector < CVectorData < long long > >order_dia_long (nhblks_flt + 1);
      CVectorData < int >nblks_dia (nhblks_flt + 1);
      vector < CVectorData < long long > >blks_dia (nhblks_flt + 1);

      CVectorData < int >*porder_dia = &order_dia[0];
      CVectorData < long long >*porder_dia_long = &order_dia_long[0];
      int *pnblks_dia = nblks_dia.Ptr ();
      CVectorData < long long >*pblks_dia = &blks_dia[0];

      {
         int ihblk;
         for (ihblk = 0; ihblk < nhblks_flt; ihblk++)
            pnblks_dia[ihblk] = 0;
      }

      {

         int ihblk;

         for (ihblk = 0; ihblk < nhblks_flt; ihblk++) {
            if (phblk2cpu_ord[ihblk] == myid) {

               int ibegblk = phblk2blks_ord[ihblk];
               int iendblk_tot = phblk2blks_ord[ihblk + 1] - 1;
               int iendblk = iendblk_tot;
               if (ihblk == nhblks_flt - 1 && b_blk_wells) {
                  iendblk--;
               }

               int ni_subm_tot = (int) (pblks_ord[iendblk_tot + 1] - pblks_ord[ibegblk]);
               int ni_subm = (int) (pblks_ord[iendblk + 1] - pblks_ord[ibegblk]);

               int niblk = iendblk + 1 - ibegblk;

// Get main submatrix as another hmatrix

               CMatrix < int, float >*pHMatrStr = phmatr_ord[ihblk].GetHMatrStr ();
               CMatrix < _Int, _Flt > *pASub = phmatr_ord[ihblk].GetASubArr ();

               int *pia_hmatr = pHMatrStr->GetIaArr ();
               int *pja_hmatr = pHMatrStr->GetJaArr ();
               int *pja2_hmatr = pHMatrStr->GetJa2Arr ();

               int nzblk_sub = 0;

               {
                  int i, j, jblk, jhblk;
                  for (i = 0; i < niblk; i++) {
                     for (j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
                        jblk = pja_hmatr[j];
                        jhblk = pja2_hmatr[j];
                        if (jblk >= 0 && jblk < niblk && jhblk == ihblk)
                           nzblk_sub++;
                     }
                  }

               }

               CBMatrix < _Int, _Flt > hmatr_subm;

               hmatr_subm.SetNzblk (nzblk_sub);
               hmatr_subm.ResizeASub (nzblk_sub);

               CMatrix < int, float >*pHMatrStr_subm = hmatr_subm.GetHMatrStr ();
               CMatrix < _Int, _Flt > *pASub_subm = hmatr_subm.GetASubArr ();

               pHMatrStr_subm->ResizeAndSetAllSp (niblk, niblk, nzblk_sub, nzblk_sub);

               int *plist_hmatr_subm = pHMatrStr_subm->GetListArr ();
               int *plist2_hmatr_subm = pHMatrStr_subm->GetList2Arr ();
               int *pia_hmatr_subm = pHMatrStr_subm->GetIaArr ();
               int *pja_hmatr_subm = pHMatrStr_subm->GetJaArr ();
               int *pja2_hmatr_subm = pHMatrStr_subm->GetJa2Arr ();

               {
                  int i, j, jblk, jhblk;
                  for (i = 0; i < niblk; i++)
                     plist_hmatr_subm[i] = i;
                  for (i = 0; i < niblk; i++)
                     plist2_hmatr_subm[i] = 0;
                  for (i = 0; i < nzblk_sub; i++)
                     pja2_hmatr_subm[i] = 0;
                  nzblk_sub = 0;
                  pia_hmatr_subm[0] = 0;
                  for (i = 0; i < niblk; i++) {
                     for (j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
                        jblk = pja_hmatr[j];
                        jhblk = pja2_hmatr[j];
                        if (jblk >= 0 && jblk < niblk && jhblk == ihblk) {
                           pja_hmatr_subm[nzblk_sub] = jblk;
                           nzblk_sub++;
                        }
                     }
                     pia_hmatr_subm[i + 1] = nzblk_sub;
                  }
               }

               {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int j, jblk, jhblk;
                     int ibs_sub = pia_hmatr_subm[ipar];
                     for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
                        jblk = pja_hmatr[j];
                        jhblk = pja2_hmatr[j];
                        if (jblk >= 0 && jblk < niblk && jhblk == ihblk) {
                           pASub_subm[ibs_sub] = pASub[j];
                           ibs_sub++;
                        }
                     }
                  }

               }

// Prepare control data

               vector < long long >blks_1hblk (niblk + 1);
               long long *pblks_1hblk = &blks_1hblk[0];

               {
                  for (int i = 0; i <= niblk; i++)
                     pblks_1hblk[i] = pblks_ord[ibegblk + i] - pblks_ord[ibegblk];
               }

               int nparts_decomp = (ni_subm + _isize_max2 - 1) / _isize_max2;

// Compute new ordering and partitioning

               CVectorData < int >order_subm (ni_subm_tot);
               int *porder_subm = order_subm.Ptr ();

               int nparts_subm;
               vector < long long >parts_subm;

               bool b_split = true;

               if (ihblk == nhblks_flt - 1 && b_blk_wells) {
                  b_split = false;
                  nparts_decomp = _nparts_W;
               }

               CBMatrix < _Int, _Flt >::DecompWeights_thr (b_split, _degree, _isize_max,
                                                           nparts_decomp, niblk,
                                                           pblks_1hblk, hmatr_subm,
                                                           nparts_subm, parts_subm,
                                                           porder_subm);

               {

                  int i;

                  for (i = ni_subm; i < ni_subm_tot; i++)
                     porder_subm[i] = i;

                  if (ihblk == nhblks_flt - 1 && b_blk_wells) {

                     int nparts_subm_new = nparts_subm + 1;

                     vector < long long >parts_subm_new (nparts_subm_new + 1);
                     long long *pparts_subm_new = &parts_subm_new[0];

                     long long *pparts_subm = &parts_subm[0];

                     for (i = 0; i <= nparts_subm; i++)
                        pparts_subm_new[i] = pparts_subm[i];

                     pparts_subm_new[nparts_subm_new] =
                        pparts_subm_new[nparts_subm_new - 1] +
                        (pblks_ord[iendblk_tot + 1] - pblks_ord[iendblk_tot]);

                     nparts_subm = nparts_subm_new;
                     parts_subm.swap (parts_subm_new);

                  }

               }

// Store data

               long long *pparts_subm = &parts_subm[0];

               pnblks_dia[ihblk] = nparts_subm;
               pblks_dia[ihblk].resize (nparts_subm + 1);
               long long *ppblks_dia = pblks_dia[ihblk].Ptr ();

               {
                  int i;
                  for (i = 0; i <= nparts_subm; i++)
                     ppblks_dia[i] = pparts_subm[i];
               }

               CVectorData < long long >order_subm_store (ni_subm_tot);
               long long *porder_subm_store = order_subm_store.Ptr ();

               {

                  int ni_thr = ni_subm_tot / n_thr;
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < n_thr; ipar++) {
                     int ibeg = ni_thr * ipar;
                     int iend = ni_thr * (ipar + 1) - 1;
                     if (ipar == n_thr - 1)
                        iend = ni_subm_tot - 1;
                     int j;
                     for (j = ibeg; j <= iend; j++) {
                        porder_subm_store[j] = porder_subm[j];
                     }
                  }

               }

               porder_dia[ihblk].swap (order_subm);
               porder_dia_long[ihblk].swap (order_subm_store);

            }
         }

      }

      if (b_blk_wells) {
         int ihblk = nhblks_flt - 1;
         if (ihblk >= 0) {
            int ibegblk = phblk2blks_ord[ihblk];
            int iendblk = phblk2blks_ord[ihblk + 1] - 1;
            if (ibegblk < 0 || ibegblk >= nblks_max) {
               cout <<
                  " CBMatrix <>::DecompWells_impl: error in ibegblk number !!! ibegblk = "
                  << ibegblk << endl;
               throw "  CBMatrix <>::DecompWells_impl: error in ibegblk number !!! ";
            }
            if (iendblk < 0 || iendblk >= nblks_max) {
               cout <<
                  " CBMatrix <>::DecompWells_impl: error in iendblk number !!! iendblk = "
                  << iendblk << endl;
               throw "  CBMatrix <>::DecompWells_impl: error in iendblk number !!! ";
            }
            int ni_curr = (int) (pblks_ord[iendblk + 1] - pblks_ord[ibegblk]);
            if (myid != 0) {
               porder_dia[ihblk].resize (ni_curr);
               int *pporder_dia = porder_dia[ihblk].Ptr ();
               CVectorInt < int >::SetByZeroes (ni_curr, pporder_dia);
            }
            int *pporder_dia = porder_dia[ihblk].Ptr ();
            CMPIDataExchange::ExchangeArray (_comm, 'I', '+', ni_curr, pporder_dia);
         }
      }
// Modify ordering data according to second ordering

      {
         int nhblks_flt1 = nhblks_flt;
         if (b_blk_wells)
            nhblks_flt1--;
         int ihblk;
         for (ihblk = 0; ihblk < nhblks_flt1; ihblk++) {
            if (phblk2cpu_ord[ihblk] == myid) {

               int ibegblk = phblk2blks_ord[ihblk];
               int iendblk = phblk2blks_ord[ihblk + 1] - 1;
               int niblk = iendblk + 1 - ibegblk;

               int *pporder_dia = porder_dia[ihblk].Ptr ();
               long long ibs_iord = pibs_iord[ihblk];
               long long ibeg = pblks_ord[ibegblk];

               {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int iblk = ibegblk + ipar;
                     int niloc = (int) (pblks_ord[iblk + 1] - pblks_ord[iblk]);
                     int ishift = (int) (pblks_ord[iblk] - pblks_ord[ibegblk]);
                     int i, jj, jhblk;
                     long long ind, ibs_ord;
                     for (i = 0; i < niloc; i++) {
                        ind = ibs_iord + ishift + i;
                        jj = (int) piorder2ind_ini[ind * 2];
                        jhblk = (int) piorder2ind_ini[ind * 2 + 1];
                        ibs_ord = pibs_ord[jhblk];
                        porder_ini[ibs_ord + jj] = ibeg + pporder_dia[ishift + i];
                     }
                  }
               }

            }
         }
         if (b_blk_wells) {
            int ihblk = nhblks_flt - 1;
            if (ihblk >= 0) {
               int ibegblk = phblk2blks_ord[ihblk];
               int iendblk = phblk2blks_ord[ihblk + 1] - 1;
               int niblk = iendblk + 1 - ibegblk;

               int *pporder_dia = porder_dia[ihblk].Ptr ();
               long long ibs_iord = pibs_iord[ihblk];
               long long ibeg = pblks_ord[ibegblk];

               {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int iblk = ibegblk + ipar;
                     int niloc = (int) (pblks_ord[iblk + 1] - pblks_ord[iblk]);
                     int ishift = (int) (pblks_ord[iblk] - pblks_ord[ibegblk]);
                     int i, jj, jhblk;
                     long long ind, ibs_ord_temp;
                     for (i = 0; i < niloc; i++) {
                        ind = ibs_iord + ishift + i;
                        jj = (int) piorder2ind_ini[ind * 2];
                        jhblk = (int) piorder2ind_ini[ind * 2 + 1];
                        if (jhblk < 0 || jhblk >= nhblks_flt) {
                           cout <<
                              " CBMatrix <>::DecompWells_impl: error in hblock number !!! jhblk = "
                              << jhblk << endl;
                           throw
                              "  CBMatrix <>::DecompWells_impl: error in hblock number !!! ";
                        }
                        if (_hblk2cpu[jhblk] == myid) {
                           ibs_ord_temp = pibs_ord[jhblk];
                           porder_ini[ibs_ord_temp + jj] = ibeg + pporder_dia[ishift + i];
                        }
                     }
                  }
               }

            }

         }
      }

// Combine new partitioning

      CMPIDataExchange::ExchangeArray (_comm, 'I', '+', nhblks_flt, pnblks_dia);

      int nblks_dia_tot = 0;
      {
         for (int i = 0; i < nhblks_flt; i++)
            nblks_dia_tot += pnblks_dia[i];
      }

      CVectorData < long long >blks_dia_tot (nblks_dia_tot + 1);
      long long *pblks_dia_tot = blks_dia_tot.Ptr ();

      CVectorData < int >hblk2blk_dia (nhblks_flt + 1);
      int *phblk2blk_dia = hblk2blk_dia.Ptr ();

      {
         int ihblk, i;
         phblk2blk_dia[0] = 0;
         for (i = 0; i < nhblks_flt; i++)
            phblk2blk_dia[i + 1] = phblk2blk_dia[i] + pnblks_dia[i];
         for (i = 0; i <= nblks_dia_tot; i++)
            pblks_dia_tot[i] = 0;
         for (ihblk = 0; ihblk < nhblks_flt; ihblk++) {
            if (phblk2cpu_ord[ihblk] == myid) {
               int ibs = phblk2blk_dia[ihblk];
               long long *ppblks_dia = pblks_dia[ihblk].Ptr ();
               for (i = 0; i < pnblks_dia[ihblk]; i++) {
                  pblks_dia_tot[ibs + i + 1] = ppblks_dia[i + 1] - ppblks_dia[i];
               }
            }
         }
      }

      CMPIDataExchange::ExchangeArray (_comm, 'L', '+', nblks_dia_tot + 1, pblks_dia_tot);

      {
         for (int i = 0; i < nblks_dia_tot; i++)
            pblks_dia_tot[i + 1] += pblks_dia_tot[i];
      }

// Perform again local additional partitioning and ordering

      CVectorData < CBMatrix < _Int, _Flt > >hmatr_dia (nhblks_flt + 1);
      CBMatrix < _Int, _Flt > *phmatr_dia = hmatr_dia.Ptr ();

      {

         int nz_ord = 0;

         int ihblk;
         for (ihblk = 0; ihblk < nhblks_flt; ihblk++) {
            if (phblk2cpu_ord[ihblk] == myid) {
               int ibegblk = phblk2blk_dia[ihblk];
               int iendblk = phblk2blk_dia[ihblk + 1] - 1;
               int niloc = (int) (pblks_dia_tot[iendblk + 1] - pblks_dia_tot[ibegblk]);
               nz_ord += niloc;
            }
         }
         CVectorData < long long >order_dia_temp (nz_ord);
         long long *porder_dia_temp = order_dia_temp.Ptr ();
         nz_ord = 0;
         for (ihblk = 0; ihblk < nhblks_flt; ihblk++) {
            if (phblk2cpu_ord[ihblk] == myid) {
               int ibegblk = phblk2blk_dia[ihblk];
               int iendblk = phblk2blk_dia[ihblk + 1] - 1;
               int niloc = (int) (pblks_dia_tot[iendblk + 1] - pblks_dia_tot[ibegblk]);
               long long ishift = pblks_dia_tot[ibegblk];
               long long *pporder_dia_long = porder_dia_long[ihblk].Ptr ();
               CVectorInt < long long >::CopyVectorInt_thr (niloc, pporder_dia_long,
                                                            porder_dia_temp + nz_ord);
               CVectorInt < long long >::ShiftVectorInt_thr (niloc, ishift,
                                                             porder_dia_temp + nz_ord);
               nz_ord += niloc;
            }
         }

         CBMatrix < _Int, _Flt >::ReorderHMatrix (_comm, nhblks_flt, phblk2cpu_ord,
                                                  phblk2blks_ord, pblks_ord, phmatr_ord,
                                                  porder_dia_temp, nhblks_flt,
                                                  phblk2cpu_ord, phblk2blk_dia,
                                                  pblks_dia_tot, phmatr_dia);

      }

// Get weights block matrix on first cpu (no well subblocks)

      CMatrix < int, float >ablk_strW;

      {

         int iblkgl_wells = nblks_dia_tot;
         int nhblks_wells = nhblks_flt;
         if (b_blk_wells) {
            nhblks_wells = nhblks_flt - 1;
            iblkgl_wells = phblk2blk_dia[nhblks_wells];
         }
// Count the number of elems in each block submatrix

         CVectorData < int >ia_hblk_arr (nhblks_wells + 1);
         int *pia_hblk_arr = ia_hblk_arr.Ptr ();

         int i;

         for (i = 0; i <= nhblks_wells; i++)
            pia_hblk_arr[i] = 0;

         int ihblk, iblkgl, j, jblk, jhblk, jblkgl;

         for (ihblk = 0; ihblk < nhblks_wells; ihblk++) {
            if (phblk2cpu_ord[ihblk] == myid) {

               int ibegblk = phblk2blk_dia[ihblk];
               int iendblk = phblk2blk_dia[ihblk + 1] - 1;
               int niblk = iendblk + 1 - ibegblk;

               CMatrix < int, float >*pHMatrStr = phmatr_dia[ihblk].GetHMatrStr ();

               int *pia_hmatr = pHMatrStr->GetIaArr ();
               int *pja_hmatr = pHMatrStr->GetJaArr ();
               int *pja2_hmatr = pHMatrStr->GetJa2Arr ();

               int nzblk_flt = 0;

               for (i = 0; i < niblk; i++) {
                  iblkgl = ibegblk + i;
                  if (iblkgl < iblkgl_wells) {
                     for (j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
                        jblk = pja_hmatr[j];
                        jhblk = pja2_hmatr[j];
                        jblkgl = phblk2blk_dia[jhblk] + jblk;
                        if (jblkgl < iblkgl_wells)
                           nzblk_flt++;
                     }
                  }
               }

               pia_hblk_arr[ihblk + 1] = nzblk_flt;

            }
         }

         CMPIDataExchange::ExchangeArray (_comm, 'I', '+', nhblks_wells + 1,
                                          pia_hblk_arr);

         for (i = 0; i < nhblks_wells; i++)
            pia_hblk_arr[i + 1] += pia_hblk_arr[i];

         int nzblk_tot = pia_hblk_arr[nhblks_wells];

         int nblks_dia_tot1 = phblk2blk_dia[nhblks_wells];

         ablk_strW.ResizeAndSetAllSp (nblks_dia_tot1, nblks_dia_tot1, nzblk_tot,
                                      nzblk_tot);

         int *plist_strW = ablk_strW.GetListArr ();
         int *plist2_strW = ablk_strW.GetList2Arr ();
         int *pia_strW = ablk_strW.GetIaArr ();
         int *pja_strW = ablk_strW.GetJaArr ();
         int *pja2_strW = ablk_strW.GetJa2Arr ();

         for (i = 0; i < nblks_dia_tot1; i++)
            plist_strW[i] = i;

         for (i = 0; i < nblks_dia_tot1; i++)
            plist2_strW[i] = 0;
         for (i = 0; i <= nblks_dia_tot1; i++)
            pia_strW[i] = 0;
         for (i = 0; i < nzblk_tot; i++)
            pja_strW[i] = 0;
         for (i = 0; i < nzblk_tot; i++)
            pja2_strW[i] = 0;

         int ibs, ibs0;

         for (ihblk = 0; ihblk < nhblks_wells; ihblk++) {
            if (phblk2cpu_ord[ihblk] == myid) {

               ibs = pia_hblk_arr[ihblk];

               int ibegblk = phblk2blk_dia[ihblk];
               int iendblk = phblk2blk_dia[ihblk + 1] - 1;
               int niblk = iendblk + 1 - ibegblk;

               CMatrix < int, float >*pHMatrStr = phmatr_dia[ihblk].GetHMatrStr ();
               CMatrix < _Int, _Flt > *pASub = phmatr_dia[ihblk].GetASubArr ();

               int *pia_hmatr = pHMatrStr->GetIaArr ();
               int *pja_hmatr = pHMatrStr->GetJaArr ();
               int *pja2_hmatr = pHMatrStr->GetJa2Arr ();

               for (i = 0; i < niblk; i++) {
                  iblkgl = ibegblk + i;
                  if (iblkgl < iblkgl_wells) {
                     plist2_strW[iblkgl] =
                        (int) (pblks_dia_tot[iblkgl + 1] - pblks_dia_tot[iblkgl]);
                     ibs0 = ibs;
                     for (j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
                        jblk = pja_hmatr[j];
                        jhblk = pja2_hmatr[j];
                        jblkgl = phblk2blk_dia[jhblk] + jblk;
                        if (jblkgl < iblkgl_wells) {
                           pja_strW[ibs] = jblkgl;
                           pja2_strW[ibs] = pASub[j].GetNzja ();
                           ibs++;
                        }
                     }
                     pia_strW[iblkgl + 1] = ibs - ibs0;
                  }
               }

            }
         }

         CMPIDataExchange::ExchangeArray (_comm, 'I', '+', nblks_dia_tot1, plist2_strW);
         CMPIDataExchange::ExchangeArray (_comm, 'I', '+', nblks_dia_tot1 + 1, pia_strW);
         CMPIDataExchange::ExchangeArray (_comm, 'I', '+', nzblk_tot, pja_strW);
         CMPIDataExchange::ExchangeArray (_comm, 'I', '+', nzblk_tot, pja2_strW);

         for (i = 0; i < nblks_dia_tot1; i++)
            pia_strW[i + 1] += pia_strW[i];

      }

// Perform decomposition on zero cpu and send it to all other cpu's

      int nblks_flt = ablk_strW.GetNlist ();

      CVectorData < int >orderblk (nblks_dia_tot);
      int *porderblk = orderblk.Ptr ();

      {
         for (int i = 0; i < nblks_dia_tot; i++)
            porderblk[i] = 0;
      }

      int nhblks_decomp = 0;
      int nblks_decomp = 0;
      vector < int >hblk2blks_decomp;
      vector < int >blkcnd2blks_decomp;

      if (myid == 0) {

         int nhblks_decomp_temp = 0;
         vector < int >hblk2blks_decomp_temp;
         vector < int >blkscnd_decomp_temp;

         CMatrix < int, float >::DecompWeights2Level (_nparts_bdecomp, _nparts, ablk_strW,
                                                      porderblk, nhblks_decomp_temp,
                                                      hblk2blks_decomp_temp,
                                                      blkscnd_decomp_temp);

         int i;

         for (i = nblks_flt; i < nblks_dia_tot; i++)
            porderblk[i] = i;

         nhblks_decomp = nhblks_decomp_temp;

         int *phblk2blks_decomp_temp = &hblk2blks_decomp_temp[0];
         int *pblkscnd_decomp_temp = &blkscnd_decomp_temp[0];

         int nblkscnd_decomp = phblk2blks_decomp_temp[nhblks_decomp_temp];

         if (b_blk_wells) {
            nhblks_decomp++;
         }

         hblk2blks_decomp.resize (nhblks_decomp + 1);
         int *phblk2blks_decomp = &hblk2blks_decomp[0];

         for (i = 0; i <= nhblks_decomp_temp; i++)
            phblk2blks_decomp[i] = phblk2blks_decomp_temp[i];
         if (b_blk_wells) {
            phblk2blks_decomp[nhblks_decomp] =
               phblk2blks_decomp[nhblks_decomp - 1] + (phblk2blk_dia[nhblks_flt] -
                                                       phblk2blk_dia[nhblks_flt - 1]);
         }

         nblks_decomp = phblk2blks_decomp[nhblks_decomp];

         blkcnd2blks_decomp.resize (nblks_decomp + 1);

         int *pblkcnd2blks_decomp = &blkcnd2blks_decomp[0];

         for (i = 0; i <= nblkscnd_decomp; i++)
            pblkcnd2blks_decomp[i] = pblkscnd_decomp_temp[i];
         for (i = nblkscnd_decomp; i < nblks_decomp; i++)
            pblkcnd2blks_decomp[i + 1] = pblkcnd2blks_decomp[i] + 1;

      }

      CMPIDataExchange::ExchangeArray (_comm, 'I', '+', 1, &nhblks_decomp);
      CMPIDataExchange::ExchangeArray (_comm, 'I', '+', 1, &nblks_decomp);

      if (myid != 0) {
         hblk2blks_decomp.resize (nhblks_decomp + 1);
         blkcnd2blks_decomp.resize (nblks_decomp + 1);
      }

      int *phblk2blks_decomp = &hblk2blks_decomp[0];
      int *pblkcnd2blks_decomp = &blkcnd2blks_decomp[0];

      if (myid != 0) {
         int i;
         for (i = 0; i <= nhblks_decomp; i++)
            phblk2blks_decomp[i] = 0;
         for (i = 0; i <= nblks_decomp; i++)
            pblkcnd2blks_decomp[i] = 0;
      }

      CMPIDataExchange::ExchangeArray (_comm, 'I', '+', nblks_dia_tot, porderblk);
      CMPIDataExchange::ExchangeArray (_comm, 'I', '+', nhblks_decomp + 1,
                                       phblk2blks_decomp);
      CMPIDataExchange::ExchangeArray (_comm, 'I', '+', nblks_decomp + 1,
                                       pblkcnd2blks_decomp);

// Compute final ordered partitioning

      _nhblks_new = nhblks_decomp;

      _hblk2cpu_new.resize (_nhblks_new + 1);
      _hblk2blk_new.resize (_nhblks_new + 1);
      _blk2type_new.resize (nblks_decomp + 1);
      _blks_new.resize (nblks_decomp + 1);

      int *p_hblk2cpu_new = &_hblk2cpu_new[0];
      int *p_hblk2blk_new = &_hblk2blk_new[0];
      int *p_blk2type_new = &_blk2type_new[0];
      long long *p_blks_new = &_blks_new[0];

      CVectorData < long long >blks_ord_temp (nblks_dia_tot + 1);
      long long *pblks_ord_temp = blks_ord_temp.Ptr ();

      {
         int i;
         for (i = 0; i < _nhblks_new; i++) {
            p_hblk2cpu_new[i] = i % nproc;
         }
         for (i = 0; i <= _nhblks_new; i++)
            p_hblk2blk_new[i] = phblk2blks_decomp[i];
         for (i = 0; i < nblks_decomp; i++)
            p_blk2type_new[i] = 1;
         if (b_blk_wells)
            p_blk2type_new[nblks_decomp - 1] = 0;
         pblks_ord_temp[0] = 0;
         int j;
         for (i = 0; i < nblks_dia_tot; i++) {
            j = porderblk[i];
            pblks_ord_temp[j + 1] = pblks_dia_tot[i + 1] - pblks_dia_tot[i];
         }
         for (i = 0; i < nblks_dia_tot; i++) {
            pblks_ord_temp[i + 1] += pblks_ord_temp[i];
         }
         p_blks_new[0] = 0;
         int iendblk;
         for (i = 0; i < nblks_decomp; i++) {
            iendblk = pblkcnd2blks_decomp[i + 1] - 1;
            p_blks_new[i + 1] = pblks_ord_temp[iendblk + 1];
         }
      }

// Compute final order assuming that data are in porder_ini

      {

         int nz_ord = 0;

         int ihblk;

         for (ihblk = 0; ihblk < _nhblks; ihblk++) {
            if (_hblk2cpu[ihblk] == myid) {
               int ibegblk = _hblk2blk[ihblk];
               int iendblk = _hblk2blk[ihblk + 1] - 1;
               int niblk = iendblk + 1 - ibegblk;
               int ni_curr = (int) (_blks[iendblk + 1] - _blks[ibegblk]);
               {
                  int nimax = 0;
                  {
                     int i, j, niloc;
                     for (i = 0; i < niblk; i++) {
                        j = ibegblk + i;
                        niloc = (int) (_blks[j + 1] - _blks[j]);
                        if (niloc > nimax)
                           nimax = niloc;
                     }
                  }
                  CVectorData < CSortInt64 > iiarr_threads (nimax * n_thr);
                  CSortInt64 *piiarr_threads = iiarr_threads.Ptr ();
                  CVectorData < long long >listarr_threads (2 * nimax * n_thr);
                  long long *plistarr_threads = listarr_threads.Ptr ();

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif

                     int jblk = ibegblk + ipar;
                     int niloc = (int) (_blks[jblk + 1] - _blks[jblk]);
                     int ibs =
                        (int) pibs_ord[ihblk] + (int) (_blks[jblk] - _blks[ibegblk]);

                     CSortInt64 *piiarr_th = piiarr_threads + nimax * my_thr;
                     long long *plistarr_th = plistarr_threads + 2 * nimax * my_thr;
                     long long *plist2arr_th = plistarr_th + nimax;

                     int i;

                     for (i = 0; i < niloc; i++) {
                        piiarr_th[i].ival = porder_ini[ibs + i];
                        piiarr_th[i].i2val = ibs + i;
                     }
                     sort (piiarr_th, piiarr_th + niloc);

                     for (i = 0; i < niloc; i++) {
                        plistarr_th[i] = piiarr_th[i].ival;
                     }

                     long long ia_temp[2];

                     ia_temp[0] = 0;
                     ia_temp[1] = niloc;

                     CBMatrix < long long, float >::ComputeJa2 (nblks_dia_tot,
                                                                pblks_dia_tot, 1, ia_temp,
                                                                plistarr_th,
                                                                plist2arr_th);

                     int jblk_temp, jj_temp, jblknew_temp;
                     long long ind;

                     for (i = 0; i < niloc; i++) {
                        ind = piiarr_th[i].i2val;
                        jblk_temp = (int) plist2arr_th[i];
                        jj_temp = (int) (plistarr_th[i] - pblks_dia_tot[jblk_temp]);
                        jblknew_temp = porderblk[jblk_temp];
                        _order[ind] = pblks_ord_temp[jblknew_temp] + jj_temp;
                     }
                  }
               }

               nz_ord += ni_curr;
            }
         }

      }

   }

// Compute matrix decomposition (threads parallelization)
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::DecompWeights_thr (bool _split_unconnected, int _degree, int _isize_max,
                                 int _nparts_decomp, int _nblks, long long *_blks,
                                 CBMatrix < _Int, _Flt > &_amatr, int &_nparts,
                                 vector < long long >&_parts, int *_order)
   {

// Perform decomposition

      long long ntot = _blks[_nblks];

      vector < int >partition ((int) ntot + 1);
      int *ppartition = &partition[0];

      CBMatrix < _Int, _Flt >::DecompWeights_impl (_split_unconnected, _degree,
                                                   _isize_max, _nblks, _blks, _amatr,
                                                   _nparts_decomp, ppartition);

// Partition

      int nparts;
      vector < long long >parts;

      int ipart_max = 0;

      int i;

      for (i = 0; i < ntot; i++) {
         if (ppartition[i] > ipart_max)
            ipart_max = ppartition[i];
      }

      nparts = ipart_max + 1;

      parts.resize (nparts + 1);
      long long *pparts = &parts[0];

      for (i = 0; i <= nparts; i++)
         pparts[i] = 0;

      int j;

      for (i = 0; i < ntot; i++) {
         j = ppartition[i];
         pparts[j + 1]++;
      }

      for (i = 0; i < nparts; i++)
         pparts[i + 1] += pparts[i];

      vector < long long >iptr (nparts + 1);
      long long *piptr = &iptr[0];

      for (i = 0; i < nparts; i++)
         piptr[i] = pparts[i];

      int k;

      for (i = 0; i < ntot; i++) {
         j = ppartition[i];
         k = (int) piptr[j];
         _order[i] = k;
         piptr[j]++;
      }

// Filter partitioning

      _parts.resize (nparts + 1);

      long long *p_parts = &_parts[0];

      _nparts = 0;
      p_parts[0] = 0;

      for (i = 0; i < nparts; i++) {
         if (pparts[i + 1] > pparts[i]) {
            p_parts[_nparts + 1] = pparts[i + 1];
            _nparts++;
         }
      }

   }

// Compute matrix decomposition (threads parallelization)
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::DecompWeights_impl (bool _split_unconnected, int _degree, int _isize_max,
                                  int _nblks, long long *_blks, CBMatrix < _Int,
                                  _Flt > &_amatr, int _nparts, int *_partition)
   {

// Open hmatr

      CMatrix < int, float >*phmatr = _amatr.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub = _amatr.GetASubArr ();

      int *pia_hmatr = phmatr->GetIaArr ();
      int *pja_hmatr = phmatr->GetJaArr ();

// Condense diagonal blocks in parallel

      int ntot = (int) _blks[_nblks];

      CVectorData < int >order_part (ntot);
      CVectorData < int >iorder_part (ntot);

      int *porder_part = order_part.Ptr ();
      int *piorder_part = iorder_part.Ptr ();

      vector < int >nsubblks (_nblks + 1);
      vector < vector < long long > >subblks (_nblks + 1);

      int *pnsubblks = &nsubblks[0];
      vector < long long >*psubblks = &subblks[0];

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblks; ipar++) {
            int ibeg = (int) _blks[ipar];
            int ni = (int) (_blks[ipar + 1] - _blks[ipar]);
            int i_dia = -1;
            int j, jj;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               if (jj == ipar)
                  i_dia = j;
            }
            if (i_dia < 0) {
               cout <<
                  " CBMatrix<_Int,_Flt>::DecompWeights_thr: error: diagonal block is not found! "
                  << endl;
               throw
                  " CBMatrix<_Int,_Flt>::DecompWeights_thr: error: diagonal block is not found! ";
            }
            pA_sub[i_dia].SplitMatrix (_degree, _isize_max, pnsubblks[ipar],
                                       psubblks[ipar], porder_part + ibeg);
            for (j = 0; j < ni; j++)
               porder_part[ibeg + j] += ibeg;
            for (j = 0; j < ni; j++) {
               jj = porder_part[ibeg + j];
               piorder_part[jj] = ibeg + j;
            }
         }
      }

// Combine blocks partitioning

      int nblks_new = 0;

      {
         int i;
         for (i = 0; i < _nblks; i++)
            nblks_new += pnsubblks[i];
      }

      vector < long long >blks_new (nblks_new + 1);
      long long *pblks_new = &blks_new[0];

      {

         int i, j;

         pblks_new[0] = 0;
         nblks_new = 0;

         for (i = 0; i < _nblks; i++) {
            long long *ppsubblks = &psubblks[i][0];
            for (j = 0; j < pnsubblks[i]; j++) {
               pblks_new[nblks_new + 1] =
                  pblks_new[nblks_new] + (ppsubblks[j + 1] - ppsubblks[j]);
               nblks_new++;
            }
         }

      }

// Compute double indices

      CVectorData < int >ind2arr (ntot * 2);
      CVectorData < int >ind2arr_new (ntot * 2);

      int *pind2arr = ind2arr.Ptr ();
      int *pind2arr_new = ind2arr_new.Ptr ();

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblks; ipar++) {
            int ibeg = (int) _blks[ipar];
            int ni = (int) (_blks[ipar + 1] - _blks[ipar]);
            int j, jnew;
            for (j = 0; j < ni; j++) {
               jnew = ibeg + j;
               pind2arr[jnew * 2] = j;
               pind2arr[jnew * 2 + 1] = ipar;
            }
         }

      }

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nblks_new; ipar++) {
            int ibeg = (int) pblks_new[ipar];
            int ni = (int) (pblks_new[ipar + 1] - pblks_new[ipar]);
            int j, jnew;
            for (j = 0; j < ni; j++) {
               jnew = ibeg + j;
               pind2arr_new[jnew * 2] = j;
               pind2arr_new[jnew * 2 + 1] = ipar;
            }
         }

      }

// Compute block rows with modified column indices

      vector < CMatrix < _Int, _Flt > >blockrows (_nblks + 1);
      CMatrix < _Int, _Flt > *pblockrows = &blockrows[0];

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblks; ipar++) {
            int ni = (int) (_blks[ipar + 1] - _blks[ipar]);
            int i, j, jrow;
            int nz = 0;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               nz += pA_sub[j].GetNzja ();
            }
            CMatrix < _Int, _Flt > arow;
            arow.ResizeAndSetAllSp (ni, 0, nz * 2, 0);
            _Int *plist_row = arow.GetListArr ();
            _Int *pia_row = arow.GetIaArr ();
            _Int *pja_row = arow.GetJaArr ();
            for (i = 0; i < ni; i++)
               plist_row[i] = (_Int) i;
            for (i = 0; i <= ni; i++)
               pia_row[i] = 0;
            for (i = pia_hmatr[ipar]; i < pia_hmatr[ipar + 1]; i++) {
               int nlist_temp = pA_sub[i].GetNlist ();
               _Int *plist_temp = pA_sub[i].GetListArr ();
               _Int *pia_temp = pA_sub[i].GetIaArr ();
               for (j = 0; j < nlist_temp; j++) {
                  jrow = (int) plist_temp[j];
                  pia_row[jrow + 1] += pia_temp[j + 1] - pia_temp[j];
               }
            }
            for (i = 0; i < ni; i++)
               pia_row[i + 1] += pia_row[i];
            vector < int >iptr (ni + 1);
            int *piptr = &iptr[0];
            for (i = 0; i < ni; i++)
               piptr[i] = (int) pia_row[i];
            int jblk, k, kj, kkglob, kknew, kk;
            for (i = pia_hmatr[ipar]; i < pia_hmatr[ipar + 1]; i++) {
               jblk = pja_hmatr[i];
               int nlist_temp = pA_sub[i].GetNlist ();
               _Int *plist_temp = pA_sub[i].GetListArr ();
               _Int *pia_temp = pA_sub[i].GetIaArr ();
               _Int *pja_temp = pA_sub[i].GetJaArr ();
               for (j = 0; j < nlist_temp; j++) {
                  jrow = (int) plist_temp[j];
                  k = piptr[jrow];
                  for (kj = (int) pia_temp[j]; kj < pia_temp[j + 1]; kj++) {
                     kk = (int) pja_temp[kj];
                     kkglob = (int) _blks[jblk] + kk;
                     kknew = porder_part[kkglob];
                     pja_row[k * 2] = pind2arr_new[kknew * 2];
                     pja_row[k * 2 + 1] = pind2arr_new[kknew * 2 + 1];
                     k++;
                  }
                  piptr[jrow] = k;
               }
            }
            pblockrows[ipar].ReplaceFree (arow);
         }

      }

// Compute block sparsity and weights

      CMatrix < int, float >amatr_strW;

      {

         int n_thr = 1;

#ifdef USE_THREADS
         n_thr = omp_get_max_threads ();
#endif

         vector < int >nzblk_arr (nblks_new + 1);
         vector < vector < int > >ja_arr (nblks_new + 1);
         vector < vector < int > >jaW_arr (nblks_new + 1);

         int *pnzblk_arr = &nzblk_arr[0];
         vector < int >*pja_arr = &ja_arr[0];
         vector < int >*pjaW_arr = &jaW_arr[0];

         CVectorData < int >imaskblk_thr (n_thr * 3 * nblks_new);
         int *pimaskblk_thr = imaskblk_thr.Ptr ();

         vector < int >icycle_thr (n_thr + 1);
         int *picycle_thr = &icycle_thr[0];

         {
            for (int i = 0; i < n_thr; i++)
               picycle_thr[i] = -1;
         }

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nblks_new; ipar++) {
            int ibeg = (int) pblks_new[ipar];
            int ni = (int) (pblks_new[ipar + 1] - pblks_new[ipar]);
            int my_thr = 0;
#ifdef USE_THREADS
            my_thr = omp_get_thread_num ();
#endif
            int *pimaskblk = pimaskblk_thr + my_thr * 3 * nblks_new;
            int *plistblk = pimaskblk + nblks_new;
            int *plistWblk = plistblk + nblks_new;
            int icycle = picycle_thr[my_thr];
            int i;
            if (icycle == -1) {
               for (i = 0; i < nblks_new; i++)
                  pimaskblk[i] = -1;
            }
            icycle++;
            int nlistblk = 0;
            int inew, iold, jblk, jj, j, jblknew;
            for (i = 0; i < ni; i++) {
               inew = ibeg + i;
               iold = piorder_part[inew];
               jj = pind2arr[iold * 2];
               jblk = pind2arr[iold * 2 + 1];
               _Int *pia_temp = pblockrows[jblk].GetIaArr ();
               _Int *pja_temp = pblockrows[jblk].GetJaArr ();
               for (j = (int) pia_temp[jj]; j < pia_temp[jj + 1]; j++) {
                  jblknew = (int) pja_temp[j * 2 + 1];
                  if (pimaskblk[jblknew] != icycle) {
                     pimaskblk[jblknew] = icycle;
                     plistblk[nlistblk] = jblknew;
                     nlistblk++;
                  }
               }
            }
            sort (plistblk, plistblk + nlistblk);
            for (i = 0; i < nlistblk; i++) {
               jblknew = plistblk[i];
               plistWblk[jblknew] = 0;
            }
            for (i = 0; i < ni; i++) {
               inew = ibeg + i;
               iold = piorder_part[inew];
               jj = pind2arr[iold * 2];
               jblk = pind2arr[iold * 2 + 1];
               _Int *pia_temp = pblockrows[jblk].GetIaArr ();
               _Int *pja_temp = pblockrows[jblk].GetJaArr ();
               for (j = (int) pia_temp[jj]; j < pia_temp[jj + 1]; j++) {
                  jblknew = (int) pja_temp[j * 2 + 1];
                  plistWblk[jblknew]++;
               }
            }
            pnzblk_arr[ipar] = nlistblk;
            pja_arr[ipar].resize (nlistblk + 1);
            pjaW_arr[ipar].resize (nlistblk + 1);
            int *ppja_arr = &pja_arr[ipar][0];
            int *ppjaW_arr = &pjaW_arr[ipar][0];
            for (i = 0; i < nlistblk; i++) {
               jblknew = plistblk[i];
               ppja_arr[i] = jblknew;
               ppjaW_arr[i] = plistWblk[jblknew];
            }
            picycle_thr[my_thr] = icycle;
         }

         {
            int nzja_tot = 0;
            int i;
            for (i = 0; i < nblks_new; i++) {
               nzja_tot += pnzblk_arr[i];
            }

            int nzja_new = nzja_tot - nblks_new;

            amatr_strW.ResizeAndSetAllSp (nblks_new, nblks_new, nzja_new, nzja_new);

            int *plist_strW = amatr_strW.GetListArr ();
            int *plist2_strW = amatr_strW.GetList2Arr ();
            int *pia_strW = amatr_strW.GetIaArr ();
            int *pja_strW = amatr_strW.GetJaArr ();
            int *pja2_strW = amatr_strW.GetJa2Arr ();

            int j, jj;

            for (i = 0; i < nblks_new; i++)
               plist_strW[i] = i;
            for (i = 0; i < nblks_new; i++)
               plist2_strW[i] = (int) (pblks_new[i + 1] - pblks_new[i]);

            nzja_new = 0;
            pia_strW[0] = 0;

            for (i = 0; i < nblks_new; i++) {
               int *ppja_arr = &pja_arr[i][0];
               int *ppjaW_arr = &pjaW_arr[i][0];
               for (j = 0; j < pnzblk_arr[i]; j++) {
                  jj = ppja_arr[j];
                  if (jj != i) {
                     pja_strW[nzja_new] = jj;
                     pja2_strW[nzja_new] = ppjaW_arr[j];
                     nzja_new++;
                  }
               }
               pia_strW[i + 1] = nzja_new;
            }

         }

      }

// Perform decomposition

      CVectorData < int >partition_new (nblks_new);
      int *ppartition_new = partition_new.Ptr ();

      CMatrix < int, float >::DecompWeights (_split_unconnected, amatr_strW, _nparts,
                                             ppartition_new);

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nblks_new; ipar++) {
            int ibeg = (int) pblks_new[ipar];
            int ni = (int) (pblks_new[ipar + 1] - pblks_new[ipar]);
            int ipart = ppartition_new[ipar];
            int j, jj;
            for (j = 0; j < ni; j++) {
               jj = piorder_part[ibeg + j];
               _partition[jj] = ipart;
            }
         }

      }

   }

// Prepare data for mvm functions
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::PrepareMvmData (int _myid, int _nhblks, int *_hblk2cpu, int *_hblk2blk,
                              long long *_blks, CBMatrix < _Int, _Flt > *_hmatr_arr,
                              CMatrix < int, float >*_pAHBlkStr_arr,
                              CVectorData < void *>*_ptr_arr,
                              CVectorData < CVectorData < int > >*_listRC_offd)
   {

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      int nblks = _hblk2blk[_nhblks];

      int nimax = 0;

      {

         int i, niloc;

         for (i = 0; i < nblks; i++) {
            niloc = (int) (_blks[i + 1] - _blks[i]);
            if (niloc > nimax)
               nimax = niloc;
         }

      }

      CVectorData < int >imask_thr (nimax * n_thr * 2);
      CVectorData < int >icycle_thr (n_thr);

      int *pimask_thr = imask_thr.Ptr ();
      int *picycle_thr = icycle_thr.Ptr ();

      {
         int i;
         for (i = 0; i < n_thr; i++)
            picycle_thr[i] = -1;
      }

      int ihblk;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == _myid) {

            int nzblk = _hmatr_arr[ihblk].GetNzblk ();
            CMatrix < _Int, _Flt > *pASub = _hmatr_arr[ihblk].GetASubArr ();
            CMatrix < int, float >*pAHMatrStr = _hmatr_arr[ihblk].GetHMatrStr ();

            _pAHBlkStr_arr[ihblk] = *pAHMatrStr;
            _ptr_arr[ihblk].resize (nzblk);
            _listRC_offd[ihblk].resize (2 * nzblk);

            void **p_ptr_arr = _ptr_arr[ihblk].Ptr ();
            CVectorData < int >*p_listRC_offd = _listRC_offd[ihblk].Ptr ();
            {
               int j;
               for (j = 0; j < nzblk; j++)
                  p_ptr_arr[j] = (void *) (pASub + j);
            }

            int *pja2_str = pAHMatrStr->GetJa2Arr ();

            {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
               for (int ipar = 0; ipar < nzblk; ipar++) {

                  int jhblk = pja2_str[ipar];

                  int my_thr = 0;
#ifdef USE_THREADS
                  my_thr = omp_get_thread_num ();
#endif

                  int icycle_th = picycle_thr[my_thr];
                  int *ppimask_thr = pimask_thr + 2 * nimax * my_thr;
                  int *pplist_thr = ppimask_thr + nimax;

                  if (icycle_th == -1) {
                     int j;
                     for (j = 0; j < nimax; j++)
                        ppimask_thr[j] = -1;
                  }

                  icycle_th++;

                  if (jhblk != ihblk) {

                     pASub[ipar].ComputeList2 (icycle_th, ppimask_thr, pplist_thr);

                     int nlistloc = pASub[ipar].GetNlist ();
                     int nlist2loc = pASub[ipar].GetNlist2 ();
                     _Int *plistloc = pASub[ipar].GetListArr ();
                     _Int *plist2loc = pASub[ipar].GetList2Arr ();

                     p_listRC_offd[ipar * 2].resize (nlistloc);
                     p_listRC_offd[ipar * 2 + 1].resize (nlist2loc);

                     int *plistR = p_listRC_offd[ipar * 2].Ptr ();
                     int *plistC = p_listRC_offd[ipar * 2 + 1].Ptr ();

                     int i;

                     for (i = 0; i < nlistloc; i++)
                        plistR[i] = (int) plistloc[i];
                     for (i = 0; i < nlist2loc; i++)
                        plistC[i] = (int) plist2loc[i];

                     pASub[ipar].ResizeList2 (0);
                     pASub[ipar].SetNlist2 (0);

                  }

                  picycle_thr[my_thr] = icycle_th;

               }

            }

         }
      }

   }

// Perform explicit block scaling
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ExplicitBlockScaling (void *_comm, int _blksize, int _nhblks,
                                    int *_hblk2cpu, int *_hblk2blk, long long *_blks,
                                    CBMatrix < _Int, _Flt > *_hmatr_arr, CBMatrix < _Int,
                                    _Flt > *_sclL_arr, CBMatrix < _Int, _Flt > *_sclU_arr)
   {

// Get control data

      int nproc = CMPIDataExchange::GetNproc (_comm);
      int myid = CMPIDataExchange::GetMyid (_comm);

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      int nblks_loc = _hblk2blk[_nhblks];

// Create lists data

      CVectorData < CMatrix < int, float > >A_str_arr (_nhblks);
      CVectorData < CVectorData < void *> >A_ptr_arr (_nhblks);
      CVectorData < CVectorData < CVectorData < int > > >A_listRC_offd_arr (_nhblks);

      CMatrix < int, float >*pA_str_arr = A_str_arr.Ptr ();
      CVectorData < void *>*pA_ptr_arr = A_ptr_arr.Ptr ();
      CVectorData < CVectorData < int > >*pA_listRC_offd_arr = A_listRC_offd_arr.Ptr ();

      CBMatrix < _Int, _Flt >::PrepareMvmData (myid, _nhblks, _hblk2cpu, _hblk2blk, _blks,
                                               _hmatr_arr, pA_str_arr, pA_ptr_arr,
                                               pA_listRC_offd_arr);

// Compute combined columns lists

      CVectorData < int >imaskblk (nblks_loc * 5);

      int *pimaskblk = imaskblk.Ptr ();
      int *pind2blk = pimaskblk + nblks_loc;
      int *plistblk = pind2blk + nblks_loc;
      int *plist2blk = plistblk + nblks_loc;
      int *pnzblk = plist2blk + nblks_loc;

      {
         int i;
         for (i = 0; i < nblks_loc; i++)
            pimaskblk[i] = -1;
      }

      int icycleblk = -1;

      int nimax = 0;

      {
         int i, niloc;

         for (i = 0; i < nblks_loc; i++) {
            niloc = (int) (_blks[i + 1] - _blks[i]);
            if (niloc > nimax)
               nimax = niloc;
         }
      }

      CVectorData < int >imask_thr (n_thr * nimax * 2);
      CVectorData < int >icycle_thr (n_thr);

      int *pimask_thr = imask_thr.Ptr ();
      int *picycle_thr = icycle_thr.Ptr ();

      {
         int i;
         for (i = 0; i < n_thr; i++)
            picycle_thr[i] = -1;
      }

// Create lists of blocks from other cpus

      icycleblk++;

      int nlistblk_off = 0;

      {
         int i, j, iblk, ihblk, iblkgl;
         for (i = 0; i < _nhblks; i++) {
            if (_hblk2cpu[i] == myid) {
               int nzja_temp = pA_str_arr[i].GetNzja ();
               int *pja_temp = pA_str_arr[i].GetJaArr ();
               int *pja2_temp = pA_str_arr[i].GetJa2Arr ();
               for (j = 0; j < nzja_temp; j++) {
                  iblk = pja_temp[j];
                  ihblk = pja2_temp[j];
                  if (_hblk2cpu[ihblk] != myid) {
                     iblkgl = _hblk2blk[ihblk] + iblk;
                     if (pimaskblk[iblkgl] != icycleblk) {
                        pimaskblk[iblkgl] = icycleblk;
                        plistblk[nlistblk_off] = iblk;
                        plist2blk[nlistblk_off] = ihblk;
                        nlistblk_off++;
                     }
                  }
               }
            }
         }
      }

      CVectorData < CSortInt2 > ii2arr (nlistblk_off);
      CSortInt2 *pii2arr = ii2arr.Ptr ();

      {

         int i, iblk, ihblk, iblkgl;

         for (i = 0; i < nlistblk_off; i++) {
            iblk = plistblk[i];
            ihblk = plist2blk[i];
            pii2arr[i].ixval = ihblk;
            pii2arr[i].iyval = iblk;
            pii2arr[i].itail = i;
         }

         sort (pii2arr, pii2arr + nlistblk_off);

         for (i = 0; i < nlistblk_off; i++) {
            ihblk = pii2arr[i].ixval;
            iblk = pii2arr[i].iyval;
            plistblk[i] = iblk;
            plist2blk[i] = ihblk;
            iblkgl = _hblk2blk[ihblk] + iblk;
            pind2blk[iblkgl] = i;
            pnzblk[iblkgl] = 0;
         }

      }

// Create lists of colmns for each block from other cpus

      {

         int i, j, iblk, ihblk, iblkgl;

         for (i = 0; i < _nhblks; i++) {
            if (_hblk2cpu[i] == myid) {
               int nzja_temp = pA_str_arr[i].GetNzja ();
               int *pja_temp = pA_str_arr[i].GetJaArr ();
               int *pja2_temp = pA_str_arr[i].GetJa2Arr ();
               for (j = 0; j < nzja_temp; j++) {
                  iblk = pja_temp[j];
                  ihblk = pja2_temp[j];
                  if (_hblk2cpu[ihblk] != myid) {
                     iblkgl = _hblk2blk[ihblk] + iblk;
                     pnzblk[iblkgl]++;
                  }
               }
            }
         }

      }

      CVectorData < int >ia_off (nlistblk_off + 1);
      int *pia_off = ia_off.Ptr ();

      int nzblk_off = 0;
      pia_off[0] = 0;

      {
         int i, iblk, ihblk, iblkgl;
         for (i = 0; i < nlistblk_off; i++) {
            iblk = plistblk[i];
            ihblk = plist2blk[i];
            iblkgl = _hblk2blk[ihblk] + iblk;
            nzblk_off += pnzblk[iblkgl];
            pia_off[i + 1] = nzblk_off;
         }
      }

      CVectorData < CVectorData < int > >lists_off (nzblk_off);
      CVectorData < void *>ptr_blks_off (nzblk_off);
      CVectorData < int >ind2arr_off (nzblk_off * 2);

      CVectorData < int >*plists_off = lists_off.Ptr ();
      void **pptr_blks_off = ptr_blks_off.Ptr ();
      int *pind2arr_off = ind2arr_off.Ptr ();

      CVectorData < int >iptr (nlistblk_off);
      int *piptr = iptr.Ptr ();

      {

         int i;

         for (i = 0; i < nlistblk_off; i++)
            piptr[i] = pia_off[i];

         int k, ind, jblk, jhblk, jblkgl, i1, iblk, ihblk, j;

         for (i = 0; i < _nhblks; i++) {
            if (_hblk2cpu[i] == myid) {
               int nlist_temp = pA_str_arr[i].GetNlist ();
               int *plist_temp = pA_str_arr[i].GetListArr ();
               int *plist2_temp = pA_str_arr[i].GetList2Arr ();
               int *pia_temp = pA_str_arr[i].GetIaArr ();
               int *pja_temp = pA_str_arr[i].GetJaArr ();
               int *pja2_temp = pA_str_arr[i].GetJa2Arr ();
               CVectorData < int >*p_listRC_offdA = pA_listRC_offd_arr[i].Ptr ();
               void **ppA_ptr_arr = pA_ptr_arr[i].Ptr ();
               for (i1 = 0; i1 < nlist_temp; i1++) {
                  iblk = plist_temp[i1];
                  ihblk = plist2_temp[i1];
                  for (j = pia_temp[i1]; j < pia_temp[i1 + 1]; j++) {
                     jblk = pja_temp[j];
                     jhblk = pja2_temp[j];
                     if (_hblk2cpu[jhblk] != myid) {
                        jblkgl = _hblk2blk[jhblk] + jblk;
                        ind = pind2blk[jblkgl];
                        k = piptr[ind];
                        plists_off[k].swap (p_listRC_offdA[j * 2 + 1]);
                        pptr_blks_off[k] = ppA_ptr_arr[j];
                        pind2arr_off[k * 2] = iblk;
                        pind2arr_off[k * 2 + 1] = ihblk;
                        piptr[ind]++;
                     }
                  }
               }
            }
         }

      }

// Add in parallel lists of columns

      CVectorData < CVectorData < int > >lists_sum (nlistblk_off);
      CVectorData < int >*plists_sum = lists_sum.Ptr ();

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nlistblk_off; ipar++) {

            int my_thr = 0;
#ifdef USE_THREADS
            my_thr = omp_get_thread_num ();
#endif

            int icycle_th = picycle_thr[my_thr];
            int *ppimask_thr = pimask_thr + 2 * nimax * my_thr;
            int *pplist_thr = ppimask_thr + nimax;

            if (icycle_th == -1) {
               int j;
               for (j = 0; j < nimax; j++)
                  ppimask_thr[j] = -1;
            }

            icycle_th++;

// Main

            int i, j, jj, njloc;

            int nlist_add = 0;

            for (i = pia_off[ipar]; i < pia_off[ipar + 1]; i++) {
               njloc = plists_off[i].GetLength ();
               int *piarr = plists_off[i].Ptr ();
               for (j = 0; j < njloc; j++) {
                  jj = piarr[j];
                  if (ppimask_thr[jj] != icycle_th) {
                     ppimask_thr[jj] = icycle_th;
                     pplist_thr[nlist_add] = jj;
                     nlist_add++;
                  }
               }
            }

            sort (pplist_thr, pplist_thr + nlist_add);

            plists_sum[ipar].resize (nlist_add);
            int *piarr_sum = plists_sum[ipar].Ptr ();

            for (i = 0; i < nlist_add; i++)
               piarr_sum[i] = (int) pplist_thr[i];

            picycle_thr[my_thr] = icycle_th;

         }

      }

// Form hblocks

      CVectorData < int >imaskcpu (nproc * 4);

      int *pimaskcpu = imaskcpu.Ptr ();
      int *plistcpu = pimaskcpu + nproc;
      int *pindcpu = plistcpu + nproc;

      {
         int i;
         for (i = 0; i < nproc; i++)
            pimaskcpu[i] = -1;
      }

      int nlistcpu = 0;

      {
         int i, icpu, ihblk;

         for (i = 0; i < nlistblk_off; i++) {
            ihblk = plist2blk[i];
            icpu = (int) _hblk2cpu[ihblk];
            if (pimaskcpu[icpu] < 0) {
               pimaskcpu[icpu] = 1;
               plistcpu[nlistcpu] = icpu;
               nlistcpu++;
            }
         }
      }

      sort (plistcpu, plistcpu + nlistcpu);

      {
         int i, icpu;

         for (i = 0; i < nlistcpu; i++) {
            icpu = plistcpu[i];
            pindcpu[icpu] = (int) i;
         }
      }

      CVectorData < int >iacpu (nlistcpu + 1);
      int *piacpu = iacpu.Ptr ();

      {

         int i, ihblk, icpu, ind;

         for (i = 0; i <= nlistcpu; i++)
            piacpu[i] = 0;

         for (i = 0; i < nlistblk_off; i++) {
            ihblk = plist2blk[i];
            icpu = (int) _hblk2cpu[ihblk];
            ind = pindcpu[icpu];
            piacpu[ind + 1]++;
         }

         for (i = 0; i < nlistcpu; i++)
            piacpu[i + 1] += piacpu[i];

      }

      CVectorData < int >iptr_cpu (nlistcpu + 1);
      int *piptr_cpu = iptr_cpu.Ptr ();

      {
         int i;
         for (i = 0; i < nlistcpu; i++)
            piptr_cpu[i] = 0;
      }

      CVectorData < CBMatrix < _Int, _Flt > >sends_A (nlistcpu);
      CBMatrix < _Int, _Flt > *psends_A = sends_A.Ptr ();

      {

         int i, j;

         for (i = 0; i < nlistcpu; i++) {
            int nzblk = piacpu[i + 1] - piacpu[i];
            psends_A[i].SetNzblk (nzblk);
            psends_A[i].ResizeASub (nzblk);
            CMatrix < int, float >*pAHBlkStr_temp = psends_A[i].GetHMatrStr ();
            pAHBlkStr_temp->ResizeAndSetAllSp (nzblk, nzblk, 0, 0);
            int *pia_temp = pAHBlkStr_temp->GetIaArr ();
            for (j = 0; j <= nzblk; j++)
               pia_temp[j] = j;
         }

         int ihblk, icpu, ind, k;

         for (i = 0; i < nlistblk_off; i++) {
            ihblk = plist2blk[i];
            icpu = (int) _hblk2cpu[ihblk];
            ind = pindcpu[icpu];
            k = piptr_cpu[ind];
            CMatrix < _Int, _Flt > *pASub_temp = psends_A[ind].GetASubArr ();
            CMatrix < int, float >*pAHBlkStr_temp = psends_A[ind].GetHMatrStr ();
            int *plist_temp = pAHBlkStr_temp->GetListArr ();
            int *plist2_temp = pAHBlkStr_temp->GetList2Arr ();
            plist_temp[k] = plistblk[i];
            plist2_temp[k] = plist2blk[i];
            piptr_cpu[ind]++;
            int nlist_temp = plists_sum[i].GetLength ();
            int *pplist_temp = plists_sum[i].Ptr ();
            pASub_temp[k].SetNlist2 (nlist_temp);
            pASub_temp[k].ResizeList2 (nlist_temp);
            _Int *pplist_blk = pASub_temp[k].GetList2Arr ();
            for (j = 0; j < nlist_temp; j++)
               pplist_blk[j] = (_Int) pplist_temp[j];
         }

      }

// Pack hblocks

      vector < int >CpuIDSend (nlistcpu);
      vector < vector < char > >ObjSend (nlistcpu);

      int *pCpuIDSend = NULL;
      vector < char >*pObjSend = NULL;

      if (nlistcpu > 0) {
         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];
      }

      {

         int i;
         long long isize;
         char *pobj;

         for (i = 0; i < nlistcpu; i++) {
            pCpuIDSend[i] = plistcpu[i];
            isize = psends_A[i].GetPackedSize ();
            pObjSend[i].resize ((size_t) isize);
            pobj = &(pObjSend[i][0]);
            psends_A[i].FillPacked (isize, pobj);
            psends_A[i].Clean ();
         }

      }

// Exchange

      vector < int >CpuIDRecv;
      vector < vector < char > >ObjRecv;

      CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      int nrecv = (int) CpuIDRecv.size ();

      vector < char >*pObjRecv = NULL;
      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      vector < CBMatrix < _Int, _Flt > >hblk_recv (nrecv + 1);

      CBMatrix < _Int, _Flt > *phblk_recv = &hblk_recv[0];

      {

         int i;
         long long isize;
         char *pobj;

         for (i = 0; i < nrecv; i++) {
            isize = (long long) pObjRecv[i].size ();
            pobj = &(pObjRecv[i][0]);
            phblk_recv[i].UnPack (isize, pobj);
         }

      }

// Fill send structures in parallel

      int blksize_2 = _blksize * _blksize;

      {

         int irecv;

         for (irecv = 0; irecv < nrecv; irecv++) {

            CMatrix < _Int, _Flt > *pASub_temp = phblk_recv[irecv].GetASubArr ();
            CMatrix < int, float >*pAHBlkStr_temp = phblk_recv[irecv].GetHMatrStr ();

            int nlist_temp = pAHBlkStr_temp->GetNlist ();
            int *plist_temp = pAHBlkStr_temp->GetListArr ();
            int *plist2_temp = pAHBlkStr_temp->GetList2Arr ();

            {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
               for (int ipar = 0; ipar < nlist_temp; ipar++) {

                  int iblk = plist_temp[ipar];
                  int ihblk = plist2_temp[ipar];

                  int nlist2_send = pASub_temp[ipar].GetNlist2 ();
                  _Int *plist2_send = pASub_temp[ipar].GetList2Arr ();

                  pASub_temp[ipar].ResizeA (blksize_2 * nlist2_send);
                  pASub_temp[ipar].SetNza (blksize_2 * nlist2_send);

                  _Flt *pa_send = pASub_temp[ipar].GetAArr ();

                  CMatrix < _Int, _Flt > *pASub_sclU = _sclU_arr[ihblk].GetASubArr ();

                  _Flt *pa_scl = pASub_sclU[iblk].GetAArr ();

                  int i, j, k, ibs_i, ibs_j;

                  for (i = 0; i < nlist2_send; i++) {
                     j = (int) plist2_send[i];
                     ibs_i = blksize_2 * i;
                     ibs_j = blksize_2 * j;
                     for (k = 0; k < blksize_2; k++)
                        pa_send[ibs_i + k] = pa_scl[ibs_j + k];
                  }

               }

            }

         }

      }

// Pack hblocks

      {

         vector < char >*pObjRecv = NULL;
         if (nrecv > 0) {
            pObjRecv = &ObjRecv[0];
         }

         int i;
         long long isize;
         char *pobj;

         for (i = 0; i < nrecv; i++) {
            isize = phblk_recv[i].GetPackedSize ();
            pObjRecv[i].resize ((size_t) isize);
            pobj = &(pObjRecv[i][0]);
            phblk_recv[i].FillPacked (isize, pobj);
            phblk_recv[i].Clean ();
         }

      }

      CMPIDataExchange::DataExchange (_comm, CpuIDRecv, ObjRecv, CpuIDSend, ObjSend);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDRecv.swap (CpuIDSend_temp);
         ObjRecv.swap (ObjSend_temp);
      }

// Unpack receive data

      nrecv = (int) CpuIDSend.size ();

      pObjRecv = NULL;
      if (nrecv > 0) {
         pObjRecv = &ObjSend[0];
      }

      hblk_recv.resize (nrecv + 1);
      phblk_recv = &hblk_recv[0];

      {

         int i;
         long long isize;
         char *pobj;

         for (i = 0; i < nrecv; i++) {
            isize = (long long) pObjRecv[i].size ();
            pobj = &(pObjRecv[i][0]);
            phblk_recv[i].UnPack (isize, pobj);
         }

      }

// Register received block scaling data

      CVectorData < CMatrix < _Int, _Flt > *>ptr_sclU_recv (nlistblk_off);
      CMatrix < _Int, _Flt > **pptr_scl_recv = ptr_sclU_recv.Ptr ();

      {

         int i, j, iblk, ihblk, iblkgl, ind;

         for (i = 0; i < nrecv; i++) {

            CMatrix < _Int, _Flt > *pASub_temp = phblk_recv[i].GetASubArr ();
            CMatrix < int, float >*pAHBlkStr_temp = phblk_recv[i].GetHMatrStr ();

            int nlist_temp = pAHBlkStr_temp->GetNlist ();
            int *plist_temp = pAHBlkStr_temp->GetListArr ();
            int *plist2_temp = pAHBlkStr_temp->GetList2Arr ();

            for (j = 0; j < nlist_temp; j++) {
               iblk = plist_temp[j];
               ihblk = plist2_temp[j];
               iblkgl = _hblk2blk[ihblk] + iblk;
               ind = pind2blk[iblkgl];
               pptr_scl_recv[ind] = pASub_temp + j;
            }

         }

      }

// Perform scaling of own data first

      {

         int ihblk;

         CVectorData < _Flt > work (blksize_2 * n_thr);
         _Flt *pwork = work.Ptr ();

         for (ihblk = 0; ihblk < _nhblks; ihblk++) {
            if (_hblk2cpu[ihblk] == myid) {
               CMatrix < _Int, _Flt > *pASub_matr = _hmatr_arr[ihblk].GetASubArr ();
               CMatrix < int, float >*pAHBlkStr_matr = _hmatr_arr[ihblk].GetHMatrStr ();
               int nlist_matr = pAHBlkStr_matr->GetNlist ();
               int *plist_matr = pAHBlkStr_matr->GetListArr ();
               int *plist2_matr = pAHBlkStr_matr->GetList2Arr ();
               int *pia_matr = pAHBlkStr_matr->GetIaArr ();
               int *pja_matr = pAHBlkStr_matr->GetJaArr ();
               int *pja2_matr = pAHBlkStr_matr->GetJa2Arr ();

               {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < nlist_matr; ipar++) {

                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif

                     int j, iblk, ihblk1, jblk, jhblk;

                     iblk = plist_matr[ipar];
                     ihblk1 = plist2_matr[ipar];
                     CMatrix < _Int, _Flt > *pASub_scl_I =
                        _sclL_arr[ihblk1].GetASubArr ();
                     for (j = pia_matr[ipar]; j < pia_matr[ipar + 1]; j++) {
                        jblk = pja_matr[j];
                        jhblk = pja2_matr[j];
                        if (_hblk2cpu[jhblk] == myid) {

                           CMatrix < _Int, _Flt > *pASub_scl_J =
                              _sclU_arr[jhblk].GetASubArr ();

                           pASub_matr[j].ExplicitBlockScale (_blksize, pASub_scl_I[iblk],
                                                             NULL, pASub_scl_J[jblk],
                                                             pwork + my_thr * blksize_2);

                        }
                     }

                  }

               }

            }

         }

      }

// Scale remaining set of blocks

      {

         CVectorData < _Flt > work (blksize_2 * n_thr);
         _Flt *pwork = work.Ptr ();

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nlistblk_off; ipar++) {

            int my_thr = 0;
#ifdef USE_THREADS
            my_thr = omp_get_thread_num ();
#endif

            int *ppimask_th = pimask_thr + 2 * my_thr * nimax;

            int nlist2_scl_J = pptr_scl_recv[ipar]->GetNlist2 ();
            _Int *plist2_scl_j = pptr_scl_recv[ipar]->GetList2Arr ();

            int i, j;

            for (i = 0; i < nlist2_scl_J; i++) {
               j = (int) plist2_scl_j[i];
               ppimask_th[j] = i;
            }

            int iblk, ihblk;

            for (i = pia_off[ipar]; i < pia_off[ipar + 1]; i++) {
               iblk = pind2arr_off[i * 2];
               ihblk = pind2arr_off[i * 2 + 1];
               CMatrix < _Int, _Flt > *pASub_scl_I = _sclL_arr[ihblk].GetASubArr ();

               ((CMatrix < _Int, _Flt > *)pptr_blks_off[i])->ExplicitBlockScale (_blksize,
                                                                                 pASub_scl_I
                                                                                 [iblk],
                                                                                 ppimask_th,
                                                                                 *pptr_scl_recv
                                                                                 [ipar],
                                                                                 pwork +
                                                                                 my_thr *
                                                                                 blksize_2);

            }

         }

      }

   }

// Compute optimal ordering for the hmatrix via splitting into 3 sets of blocks
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ComputeOptimalOrderSchurWells (bool b_blk_wells, int _nparts_pwr2,
                                             int _nblks, int _nblks1, long long *_blks,
                                             CBMatrix < _Int, _Flt > *_hmatr,
                                             CTree & _tree_0, CTree & _tree_1,
                                             int &_nblks_new, int &_nblks1_new,
                                             int &_nblks2_new,
                                             vector < long long >&_blks_new,
                                             vector < long long >&_nzord_new,
                                             CVectorData < int >&_order)
   {
      if (!b_blk_wells) {
         CBMatrix < _Int, _Flt >::ComputeOptimalOrderSchur (_nparts_pwr2, _nblks, _nblks1,
                                                            _blks, _hmatr, _tree_0,
                                                            _tree_1, _nblks_new,
                                                            _nblks1_new, _nblks2_new,
                                                            _blks_new, _nzord_new,
                                                            _order);
      } else {

// Compute reduced submatrix

         int nblks_wells = _nblks - 1;

         int nzblk_hmatr = _hmatr->GetNzblk ();
         CMatrix < int, float >*phmatr = _hmatr->GetHMatrStr ();
         CMatrix < _Int, _Flt > *pASub = _hmatr->GetASubArr ();

         int *pia_hmatr = phmatr->GetIaArr ();
         int *pja_hmatr = phmatr->GetJaArr ();

         CVectorData < int >ind_o2n (nzblk_hmatr);
         int *pind_o2n = ind_o2n.Ptr ();

         CBMatrix < _Int, _Flt > hmatr_subm;

         hmatr_subm.ResizeASub (nzblk_hmatr);

         CMatrix < _Int, _Flt > *pASub_subm = hmatr_subm.GetASubArr ();
         CMatrix < int, float >*phmatr_subm = hmatr_subm.GetHMatrStr ();

         phmatr_subm->ResizeAndSetAllSp (nblks_wells, nblks_wells, nzblk_hmatr,
                                         nzblk_hmatr);

         int *plist_hmatr_subm = phmatr_subm->GetListArr ();
         int *plist2_hmatr_subm = phmatr_subm->GetList2Arr ();
         int *pia_hmatr_subm = phmatr_subm->GetIaArr ();
         int *pja_hmatr_subm = phmatr_subm->GetJaArr ();
         int *pja2_hmatr_subm = phmatr_subm->GetJa2Arr ();

         int i, j, jj;

         for (i = 0; i < nblks_wells; i++)
            plist_hmatr_subm[i] = i;
         for (i = 0; i < nblks_wells; i++)
            plist2_hmatr_subm[i] = 0;

         int nzblk_hmatr_subm = 0;

         pia_hmatr_subm[0] = 0;

         for (i = 0; i < nblks_wells; i++) {
            for (j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
               jj = pja_hmatr[j];
               if (jj < nblks_wells) {
                  pind_o2n[j] = nzblk_hmatr_subm;
                  pja_hmatr_subm[nzblk_hmatr_subm] = jj;
                  pja2_hmatr_subm[nzblk_hmatr_subm] = 0;
                  pASub_subm[nzblk_hmatr_subm].ReplaceFree (pASub[j]);
                  nzblk_hmatr_subm++;
               } else {
                  pind_o2n[j] = -1;
               }
            }
            pia_hmatr_subm[i + 1] = nzblk_hmatr_subm;
         }

         phmatr_subm->SetNzja (nzblk_hmatr_subm);
         phmatr_subm->SetNzja2 (nzblk_hmatr_subm);

         hmatr_subm.SetNzblk (nzblk_hmatr_subm);

// Compute reduced part and ord data

         CBMatrix < _Int, _Flt >::ComputeOptimalOrderSchur (_nparts_pwr2, nblks_wells,
                                                            _nblks1, _blks, &hmatr_subm,
                                                            _tree_0, _tree_1, _nblks_new,
                                                            _nblks1_new, _nblks2_new,
                                                            _blks_new, _nzord_new,
                                                            _order);

// Restore submatrix

         int k;

         for (i = 0; i < nblks_wells; i++) {
            for (j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
               k = pind_o2n[j];
               if (k >= 0) {
                  pASub[j].ReplaceFree (pASub_subm[k]);
               }
            }
         }

// Restore all part and ord data

         long long *p_blks_new = &_blks_new[0];
         int *p_order = _order.Ptr ();

         int nblks_new = _nblks_new + 1;
         int ntot = (int) _blks[_nblks];
         int ntot_wells = (int) _blks[nblks_wells];

         vector < long long >blks_new (nblks_new + 1);
         long long *pblks_new = &blks_new[0];

         CVectorData < int >order_new (ntot);
         int *porder_new = order_new.Ptr ();

         for (i = 0; i <= _nblks_new; i++)
            pblks_new[i] = p_blks_new[i];
         pblks_new[nblks_new] = ntot;

         CVectorInt < int >::CopyVectorInt_thr (ntot_wells, p_order, porder_new);

         for (i = ntot_wells; i < ntot; i++)
            porder_new[i] = i;

         _nblks_new = nblks_new;
         _blks_new.swap (blks_new);
         _order.swap (order_new);

      }
   }

// Compute optimal ordering for the hmatrix via splitting into 3 sets of blocks
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ComputeOptimalOrderSchur (int _nparts_pwr2, int _nblks, int _nblks1,
                                        long long *_blks, CBMatrix < _Int, _Flt > *_hmatr,
                                        CTree & _tree_0, CTree & _tree_1, int &_nblks_new,
                                        int &_nblks1_new, int &_nblks2_new,
                                        vector < long long >&_blks_new,
                                        vector < long long >&_nzord_new,
                                        CVectorData < int >&_order)
   {

// Open hmatr

      CMatrix < int, float >*phmatr = _hmatr->GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub = _hmatr->GetASubArr ();

      int *pia_hmatr = phmatr->GetIaArr ();
      int *pja_hmatr = phmatr->GetJaArr ();

// Create first large subblock subtree, ordering and blocks partitioning

      int nblks1_new = 0;
      vector < int >blks1_new;
      vector < int >order1_new;

      if (_nblks1 == 0) {
         nblks1_new = 0;
         blks1_new.resize (1);
         order1_new.resize (1);
         blks1_new[0] = 0;
      } else {

// Combine set of initial blocks as parts of block row

         vector < CMatrix < _Int, _Flt > >A_sub_arr (_nblks1 + 1);
         CMatrix < _Int, _Flt > *pA_sub_arr = &A_sub_arr[0];

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblks1; ipar++) {

            int i, j, jj, k, kk, kj, kkk;

            int nlist_curr = (int) (_blks[ipar + 1] - _blks[ipar]);
            int nzja_curr = 0;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               if (jj < _nblks1)
                  nzja_curr += pA_sub[j].GetNzja ();
            }
            pA_sub_arr[ipar].ResizeAndSetAllSp (nlist_curr, 0, nzja_curr, 0);
            _Int *pia_curr = pA_sub_arr[ipar].GetIaArr ();
            _Int *pja_curr = pA_sub_arr[ipar].GetJaArr ();
            for (i = 0; i <= nlist_curr; i++)
               pia_curr[i] = 0;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               if (jj < _nblks1) {
                  int nlist_temp = pA_sub[j].GetNlist ();
                  _Int *plist_temp = pA_sub[j].GetListArr ();
                  _Int *pia_temp = pA_sub[j].GetIaArr ();
                  for (k = 0; k < nlist_temp; k++) {
                     kk = (int) plist_temp[k];
                     pia_curr[kk + 1] += (pia_temp[k + 1] - pia_temp[k]);
                  }
               }
            }
            for (i = 0; i < nlist_curr; i++)
               pia_curr[i + 1] = pia_curr[i] + pia_curr[i + 1];
            vector < int >iptr (nlist_curr + 1);
            int *piptr = &iptr[0];
            for (i = 0; i < nlist_curr; i++)
               piptr[i] = (int) pia_curr[i];
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               if (jj < _nblks1) {
                  int nlist_temp = pA_sub[j].GetNlist ();
                  _Int *plist_temp = pA_sub[j].GetListArr ();
                  _Int *pia_temp = pA_sub[j].GetIaArr ();
                  _Int *pja_temp = pA_sub[j].GetJaArr ();
                  for (k = 0; k < nlist_temp; k++) {
                     kk = (int) plist_temp[k];
                     kkk = piptr[kk];
                     for (kj = (int) pia_temp[k]; kj < pia_temp[k + 1]; kj++) {
                        pja_curr[kkk] = (_Int) (_blks[jj] + pja_temp[kj]);
                        kkk++;
                     }
                     piptr[kk] = kkk;
                  }
               }
            }
         }

// Create first large submatrix as one sparse block

         vector < int >ibs_blks (_nblks1 + 1);
         int *pibs_blks = &ibs_blks[0];

         pibs_blks[0] = 0;

         int i;

         for (i = 0; i < _nblks1; i++) {
            pibs_blks[i + 1] = pibs_blks[i] + pA_sub_arr[i].GetNzja ();
         }

         int nloc_1 = (int) _blks[_nblks1];
         int nzja_1 = pibs_blks[_nblks1];

         CMatrix < _Int, _Flt > A_sub;

         A_sub.ResizeAndSetAllSp (nloc_1, 0, nzja_1, 0);

         _Int *plist_sub = A_sub.GetListArr ();
         _Int *pia_sub = A_sub.GetIaArr ();
         _Int *pja_sub = A_sub.GetJaArr ();

         pia_sub[0] = 0;

         {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < _nblks1; ipar++) {
               int nlist_curr = (int) (_blks[ipar + 1] - _blks[ipar]);
               int nzja_curr = pibs_blks[ipar + 1] - pibs_blks[ipar];
               int ibeg = (int) _blks[ipar];
               int ibs0 = pibs_blks[ipar];
               _Int *pia_curr = pA_sub_arr[ipar].GetIaArr ();
               _Int *pja_curr = pA_sub_arr[ipar].GetJaArr ();
               int j;
               for (j = 0; j < nlist_curr; j++)
                  plist_sub[ibeg + j] = ibeg + j;
               for (j = 0; j < nlist_curr; j++)
                  pia_sub[ibeg + j + 1] = ibs0 + pia_curr[j + 1];
               for (j = 0; j < nzja_curr; j++)
                  pja_sub[ibs0 + j] = pja_curr[j];
            }
         }

// Compute local ND ordering

         vector < _Int > *ptr_ia_sub = A_sub.GetIa ();
         vector < _Int > *ptr_ja_sub = A_sub.GetJa ();

         CFct_impl < _Int, _Flt >::ComputeOptimalOrder (-1, nloc_1, *ptr_ia_sub,
                                                        *ptr_ja_sub, order1_new);

// Compute reordered sparsity

         vector < _Int > ia_ord;
         vector < _Int > ja_ord;

         CFct_impl < _Int, _Flt >::ReorderMatrixSp (nloc_1, order1_new, *ptr_ia_sub,
                                                    *ptr_ja_sub, ia_ord, ja_ord);

// Create extended tree

         CTree tree (_nparts_pwr2, 2);

         int nblks_tree;
         vector < int >blks_tree;

         CFct_impl < _Int, _Flt >::FindSeparatorsForTree (nloc_1, ia_ord, ja_ord, tree,
                                                          nblks_tree, blks_tree);

         int *pblks_tree = &blks_tree[0];

// Perform filtering of zero data in a tree

         int nnodes_ini = tree.GetNnodes ();
         int *psubtree_beg = tree.GetSubtreeBeg ();

         vector < int >imasknd (nnodes_ini + 1);
         int *pimasknd = &imasknd[0];

         for (i = 0; i < nnodes_ini; i++)
            pimasknd[i] = 1;

         nblks1_new = 0;

         for (i = 0; i < nnodes_ini; i++) {
            int ibeg = psubtree_beg[i];
            if (pblks_tree[i + 1] - pblks_tree[ibeg] == 0) {
               pimasknd[i] = -1;
            } else {
               nblks1_new++;
            }
         }

         tree.FilterTree (pimasknd, _tree_0);

         blks1_new.resize (nblks1_new + 1);
         int *pblks1_new = &blks1_new[0];

         pblks1_new[0] = 0;
         nblks1_new = 0;

         for (i = 0; i < nnodes_ini; i++) {
            if (pimasknd[i] > 0) {
               pblks1_new[nblks1_new + 1] = pblks_tree[i + 1];
               nblks1_new++;
            }
         }

      }

// Compute weights submatrix

      int nblks2 = _nblks - _nblks1;

      CMatrix < int, float >matr_str;

      {

         int nzja2_curr = 0;

         int i;

         for (i = _nblks1; i < _nblks; i++) {
            int j;
            for (j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
               int jj = pja_hmatr[j];
               if (jj >= _nblks1 && jj != i)
                  nzja2_curr++;
            }
         }

         matr_str.ResizeAndSetAllSp (nblks2, nblks2, nzja2_curr, nzja2_curr);

         int *plist_str = matr_str.GetListArr ();
         int *plist2_str = matr_str.GetList2Arr ();
         int *pia_str = matr_str.GetIaArr ();
         int *pja_str = matr_str.GetJaArr ();
         int *pja2_str = matr_str.GetJa2Arr ();

         for (i = 0; i < nblks2; i++)
            plist_str[i] = i;
         for (i = 0; i < nblks2; i++)
            plist2_str[i] = (int) (_blks[_nblks1 + i + 1] - _blks[_nblks1 + i]);

         pia_str[0] = 0;
         nzja2_curr = 0;

         for (i = _nblks1; i < _nblks; i++) {
            int j;
            for (j = pia_hmatr[i]; j < pia_hmatr[i + 1]; j++) {
               int jj = pja_hmatr[j];
               if (jj >= _nblks1 && jj != i) {
                  pja_str[nzja2_curr] = jj - _nblks1;
                  pja2_str[nzja2_curr] = pA_sub[j].GetNzja ();
                  nzja2_curr++;
               }
            }
            pia_str[i - _nblks1 + 1] = nzja2_curr;
         }

      }

// Create subtree for main volume data

      vector < int >list2nd (nblks2 + 1);
      int *plist2nd = &list2nd[0];

      CBMatrix < int, float >::DecompWeightsTree (matr_str, 4, _tree_1, plist2nd);

      int nnodes_1 = _tree_1.GetNnodes ();

// Compute new ordering of blocks

      vector < CSortInt > iiarr (nblks2 + 1);
      CSortInt *piiarr = &iiarr[0];

      int i;

      for (i = 0; i < nblks2; i++) {
         piiarr[i].ival = plist2nd[i];
         piiarr[i].i2val = i;
      }

      sort (piiarr, piiarr + nblks2);

      vector < int >orderblk (nblks2 + 1);
      vector < int >iorderblk (nblks2 + 1);

      int *porderblk = &orderblk[0];
      int *piorderblk = &iorderblk[0];

      for (i = 0; i < nblks2; i++) {
         int i1 = piiarr[i].i2val;
         porderblk[i1] = i;
         piorderblk[i] = i1;
      }

      vector < int >list2nd_ord (nblks2 + 1);
      int *plist2nd_ord = &list2nd_ord[0];

      for (i = 0; i < nblks2; i++) {
         int i1 = piorderblk[i];
         plist2nd_ord[i] = plist2nd[i1];
      }

// Compute partitioning of each block into parts and assing new block numbers

      vector < int >nparts_blks (nblks2 + 1);
      vector < vector < int > >partnum_blks (nblks2 + 1);
      vector < vector < int > >parts_blks (nblks2 + 1);
      vector < vector < int > >ibsparts_blks (nblks2 + 1);
      vector < vector < int > >lists_blks (nblks2 + 1);

      int *pnparts_blks = &nparts_blks[0];
      vector < int >*ppartnum_blks = &partnum_blks[0];
      vector < int >*pparts_blks = &parts_blks[0];
      vector < int >*pibsparts_blks = &ibsparts_blks[0];
      vector < int >*plists_blks = &lists_blks[0];

      {

         int n_thr = 1;

#ifdef USE_THREADS
         n_thr = omp_get_max_threads ();
#endif

         vector < int >icycle_thr (n_thr + 1);
         vector < CVectorData < int > >imasknode_thr (n_thr + 1);

         int *picycle_thr = &icycle_thr[0];
         CVectorData < int >*pimasknode_thr = &imasknode_thr[0];

         for (i = 0; i < n_thr; i++)
            picycle_thr[i] = -1;

// Combine sparsity of each block row into one block

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nblks2; ipar++) {

            int my_thr = 0;
#ifdef USE_THREADS
            my_thr = omp_get_thread_num ();
#endif

            int i, j, jj, k, kk, kj, kkk;

            if (picycle_thr[my_thr] == -1) {
               pimasknode_thr[my_thr].resize (4 * nnodes_1 + 1);
               int *pimasknode = pimasknode_thr[my_thr].Ptr ();
               for (j = 0; j < nnodes_1; j++)
                  pimasknode[j] = -1;
            }
            int icyclenode = picycle_thr[my_thr];
            int *pimasknode = pimasknode_thr[my_thr].Ptr ();
            int *plistnode1 = pimasknode + nnodes_1;
            int *plistnode2 = plistnode1 + nnodes_1;
            int *plistnode3 = plistnode2 + nnodes_1;

            int iblkgl = ipar + _nblks1;
            int nlist_curr = (int) (_blks[iblkgl + 1] - _blks[iblkgl]);
            int nzja_curr = 0;
            for (j = pia_hmatr[iblkgl]; j < pia_hmatr[iblkgl + 1]; j++) {
               jj = pja_hmatr[j];
               nzja_curr += pA_sub[j].GetNzja ();
            }
            CMatrix < _Int, _Flt > ASub;
            ASub.ResizeAndSetAllSp (nlist_curr, 0, nzja_curr, nzja_curr);
            _Int *pia_curr = ASub.GetIaArr ();
            _Int *pja2_curr = ASub.GetJa2Arr ();
            for (i = 0; i <= nlist_curr; i++)
               pia_curr[i] = 0;
            for (j = pia_hmatr[iblkgl]; j < pia_hmatr[iblkgl + 1]; j++) {
               jj = pja_hmatr[j];
               int nlist_temp = pA_sub[j].GetNlist ();
               _Int *plist_temp = pA_sub[j].GetListArr ();
               _Int *pia_temp = pA_sub[j].GetIaArr ();
               for (k = 0; k < nlist_temp; k++) {
                  kk = (int) plist_temp[k];
                  pia_curr[kk + 1] += (pia_temp[k + 1] - pia_temp[k]);
               }
            }
            for (i = 0; i < nlist_curr; i++)
               pia_curr[i + 1] = pia_curr[i] + pia_curr[i + 1];
            vector < int >iptr (nlist_curr + 1);
            int *piptr = &iptr[0];
            for (i = 0; i < nlist_curr; i++)
               piptr[i] = (int) pia_curr[i];
            for (j = pia_hmatr[iblkgl]; j < pia_hmatr[iblkgl + 1]; j++) {
               jj = pja_hmatr[j];
               int nlist_temp = pA_sub[j].GetNlist ();
               _Int *plist_temp = pA_sub[j].GetListArr ();
               _Int *pia_temp = pA_sub[j].GetIaArr ();
               for (k = 0; k < nlist_temp; k++) {
                  kk = (int) plist_temp[k];
                  kkk = piptr[kk];
                  for (kj = (int) pia_temp[k]; kj < pia_temp[k + 1]; kj++) {
                     pja2_curr[kkk] = (_Int) (jj);
                     kkk++;
                  }
                  piptr[kk] = kkk;
               }
            }

// Compute reduced list of blocks for each row

            int nzjablk_tot = 0;

            int jblk, jblkprev;

            for (i = 0; i < nlist_curr; i++) {
               jblkprev = -1;
               for (j = (int) pia_curr[i]; j < pia_curr[i + 1]; j++) {
                  jblk = (int) pja2_curr[j];
                  if (jblk != jblkprev) {
                     nzjablk_tot++;
                     jblkprev = jblk;
                  }
               }
            }

            vector < int >ia_blktot (nlist_curr + 1);
            vector < int >ja_blktot (nzjablk_tot + 1);

            int *pia_blktot = &ia_blktot[0];
            int *pja_blktot = &ja_blktot[0];

            pia_blktot[0] = 0;
            nzjablk_tot = 0;

            for (i = 0; i < nlist_curr; i++) {
               jblkprev = -1;
               for (j = (int) pia_curr[i]; j < pia_curr[i + 1]; j++) {
                  jblk = (int) pja2_curr[j];
                  if (jblk != jblkprev) {
                     pja_blktot[nzjablk_tot] = jblk;
                     nzjablk_tot++;
                     jblkprev = jblk;
                  }
               }
               pia_blktot[i + 1] = nzjablk_tot;
            }

            vector < int >blknum_arr (nlist_curr + 1);
            int *pblknum_arr = &blknum_arr[0];

            int ibeg, jblk0, nlistnode, jnode;

            for (i = 0; i < nlist_curr; i++) {
               pblknum_arr[i] = -1;
               if (pia_blktot[i + 1] > pia_blktot[i]) {
                  ibeg = pia_blktot[i];
                  jblk0 = pja_blktot[ibeg];
                  if (jblk0 < _nblks1) {
                     pblknum_arr[i] = nnodes_1 + ipar;
                  } else {
                     if (pia_blktot[i + 1] == pia_blktot[i] + 1) {
                        pblknum_arr[i] = plist2nd[ipar];
                     } else {
                        icyclenode++;
                        nlistnode = 0;
                        for (j = pia_blktot[i]; j < pia_blktot[i + 1]; j++) {
                           jblk = pja_blktot[j];
                           jnode = plist2nd[jblk - _nblks1];
                           if (pimasknode[jnode] != icyclenode) {
                              plistnode3[nlistnode] = jnode;
                              nlistnode++;
                              pimasknode[jnode] = icyclenode;
                           }
                        }
                        sort (plistnode3, plistnode3 + nlistnode);
                        pblknum_arr[i] =
                           _tree_1.FindCommonNode (nlistnode, plistnode3, icyclenode,
                                                   pimasknode);
                     }
                  }
               }
            }
            picycle_thr[my_thr] = icyclenode;

// Transform computed data into output format

            vector < CSortInt > iiarr (nlist_curr + 1);
            CSortInt *piiarr = &iiarr[0];

            for (i = 0; i < nlist_curr; i++) {
               piiarr[i].ival = pblknum_arr[i];
               piiarr[i].i2val = i;
            }

            sort (piiarr, piiarr + nlist_curr);

            int nparts_new = 0;

            int jblk_prev = -1;

            for (i = 0; i < nlist_curr; i++) {
               jblk = piiarr[i].ival;
               if (jblk != jblk_prev) {
                  nparts_new++;
                  jblk_prev = jblk;
               }
            }

            pnparts_blks[ipar] = nparts_new;

            ppartnum_blks[ipar].resize (nparts_new + 1);
            pparts_blks[ipar].resize (nparts_new + 1);
            plists_blks[ipar].resize (nlist_curr + 1);

            int *pppartnum_blks = &ppartnum_blks[ipar][0];
            int *ppparts_blks = &pparts_blks[ipar][0];
            int *pplists_blks = &plists_blks[ipar][0];

            nparts_new = 0;

            jblk_prev = -1;
            ppparts_blks[0] = 0;

            for (i = 0; i < nlist_curr; i++) {
               jblk = piiarr[i].ival;
               if (jblk != jblk_prev) {
                  pppartnum_blks[nparts_new] = jblk;
                  nparts_new++;
                  jblk_prev = jblk;
               }
               ppparts_blks[nparts_new] = i + 1;
               pplists_blks[i] = piiarr[i].i2val;
            }

         }
      }

// Compute new ordering and partitioning for the second set of blocks

      int nblks2_new = nnodes_1 + nblks2;
      int ntot2 = (int) (_blks[_nblks] - _blks[_nblks1]);

      vector < int >blks2_new (nblks2_new + 1);
      CVectorData < int >order2_new (ntot2);

      int *pblks2_new = &blks2_new[0];
      int *porder2_new = order2_new.Ptr ();

      {

         int i, j, jblk, k;

         for (i = 0; i <= nblks2_new; i++)
            pblks2_new[i] = 0;

         for (i = 0; i < nblks2; i++) {
            int *pppartnum_blks = &ppartnum_blks[i][0];
            int *ppparts_blks = &pparts_blks[i][0];
            for (j = 0; j < pnparts_blks[i]; j++) {
               jblk = pppartnum_blks[j];
               pblks2_new[jblk + 1] += (ppparts_blks[j + 1] - ppparts_blks[j]);
            }
         }

         for (i = 0; i < nblks2_new; i++)
            pblks2_new[i + 1] = pblks2_new[i] + pblks2_new[i + 1];

         vector < int >iptr (nblks2_new + 1);
         int *piptr = &iptr[0];

         for (i = 0; i < nblks2_new; i++)
            piptr[i] = pblks2_new[i];

         for (i = 0; i < nblks2; i++) {
            pibsparts_blks[i].resize (pnparts_blks[i] + 1);
            int *pppartnum_blks = &ppartnum_blks[i][0];
            int *ppparts_blks = &pparts_blks[i][0];
            int *ppibsparts_blks = &pibsparts_blks[i][0];
            for (j = 0; j < pnparts_blks[i]; j++) {
               jblk = pppartnum_blks[j];
               k = piptr[jblk];
               ppibsparts_blks[j] = k;
               piptr[jblk] += (ppparts_blks[j + 1] - ppparts_blks[j]);
            }
         }

         {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nblks2; ipar++) {
               int j, k;
               int *ppparts_blks = &pparts_blks[ipar][0];
               int *pplists_blks = &plists_blks[ipar][0];
               int *ppibsparts_blks = &pibsparts_blks[ipar][0];
               int ishift = (int) (_blks[ipar + _nblks1] - _blks[_nblks1]);
               for (j = 0; j < pnparts_blks[ipar]; j++) {
                  int ibs = ppibsparts_blks[j];
                  for (k = ppparts_blks[j]; k < ppparts_blks[j + 1]; k++) {
                     int kk = pplists_blks[k];
                     porder2_new[ishift + kk] = ibs;
                     ibs++;
                  }
               }
            }
         }

      }

// Filter last set of blocks in blocks partitioning

      vector < long long >blks2_new_flt (nblks2_new + 1);
      long long *pblks2_new_flt = &blks2_new_flt[0];

      for (i = 0; i <= nnodes_1; i++)
         pblks2_new_flt[i] = pblks2_new[i];

      int nblks2_new_flt = nnodes_1;

      for (i = nnodes_1; i < nblks2_new; i++) {
         if (pblks2_new[i + 1] > pblks2_new[i]) {
            pblks2_new_flt[nblks2_new_flt + 1] = pblks2_new[i + 1];
            nblks2_new_flt++;
         }
      }

// Combine ordering and blocks partitioning into one array

      int *pblks1_new = &blks1_new[0];
      int *porder1_new = &order1_new[0];

      _nblks_new = nblks1_new + nblks2_new_flt;
      _nblks1_new = nblks1_new;
      _nblks2_new = nnodes_1;

      _blks_new.resize (_nblks_new + 1);

      long long *p_blks_new = &_blks_new[0];

      p_blks_new[0] = 0;

      for (i = 0; i < nblks1_new; i++)
         p_blks_new[i + 1] = pblks1_new[i + 1];

      int ishift = (int) _blks[_nblks1];

      for (i = 0; i < nblks2_new_flt; i++)
         p_blks_new[nblks1_new + i + 1] = ishift + pblks2_new_flt[i + 1];

      int ntot = (int) _blks[_nblks];

      _order.resize (ntot + 1);
      int *p_order = _order.Ptr ();

      for (i = 0; i < ishift; i++)
         p_order[i] = porder1_new[i];
      for (i = 0; i < ntot - ishift; i++)
         p_order[ishift + i] = ishift + porder2_new[i];

   }

// Compute transposed hmatrix
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::TransposeHMatrix (int _nblks, long long *_blks, CBMatrix < _Int,
                                _Flt > &_hmatr_ini, CBMatrix < _Int, _Flt > &_hmatr_fin)
   {

// Open hmatrix

      CMatrix < int, float >*phmatr = _hmatr_ini.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub = _hmatr_ini.GetASubArr ();

      int nzja_hmatr = phmatr->GetNzja ();
      int *pia_hmatr = phmatr->GetIaArr ();

// Compute transposed block sparsity

      CMatrix < int, float >hmatrT_str;
      vector < int >indHt2H (nzja_hmatr + 1);

      int *pindHt2H = &indHt2H[0];

      {

         CVectorData < int >imask (5 * _nblks + 1);
         int *pimask = imask.Ptr ();

         int i;

         for (i = 0; i < _nblks; i++)
            pimask[i] = -1;

         int icycle = -1;

         phmatr->TransposedSparsityListSp (icycle, pimask, pimask + _nblks,
                                           pimask + 2 * _nblks, pimask + 3 * _nblks,
                                           pimask + 4 * _nblks, hmatrT_str);

         int *pia_hmatrT = hmatrT_str.GetIaArr ();
         int *pja_hmatrT = hmatrT_str.GetJaArr ();

         for (i = 0; i < _nblks; i++)
            pimask[i] = pia_hmatr[i];

         int j, jj, k;

         for (i = 0; i < _nblks; i++) {
            for (j = pia_hmatrT[i]; j < pia_hmatrT[i + 1]; j++) {
               jj = pja_hmatrT[j];
               k = pimask[jj];
               pindHt2H[j] = k;
               pimask[jj]++;
            }
         }

      }

      int *pia_hmatrT = hmatrT_str.GetIaArr ();
      int *pja_hmatrT = hmatrT_str.GetJaArr ();

// Compute block sparsity of the triangular part of LU

      _hmatr_fin.SetNzblk (nzja_hmatr);
      _hmatr_fin.ResizeASub (nzja_hmatr);

      CMatrix < int, float >*phmatr_fin = _hmatr_fin.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub_fin = _hmatr_fin.GetASubArr ();

      phmatr_fin->ResizeAndSetAllSp (_nblks, _nblks, nzja_hmatr, nzja_hmatr);

      int *plist_fin = phmatr_fin->GetListArr ();
      int *plist2_fin = phmatr_fin->GetList2Arr ();
      int *pia_fin = phmatr_fin->GetIaArr ();
      int *pja_fin = phmatr_fin->GetJaArr ();
      int *pja2_fin = phmatr_fin->GetJa2Arr ();

      int i;

      for (i = 0; i < _nblks; i++)
         plist_fin[i] = i;
      for (i = 0; i < _nblks; i++)
         plist2_fin[i] = 0;
      for (i = 0; i < nzja_hmatr; i++)
         pja2_fin[i] = 0;
      for (i = 0; i <= _nblks; i++)
         pia_fin[i] = pia_hmatrT[i];
      for (i = 0; i < nzja_hmatr; i++)
         pja_fin[i] = pja_hmatrT[i];

// Compute maximal block size

      int nimax = 0;

      int niloc;

      for (i = 0; i < _nblks; i++) {
         niloc = (int) (_blks[i + 1] - _blks[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

// Transpose blocks

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      vector < int >icycle_thr (n_thr + 1);
      vector < CVectorData < int > >imaskblk_thr (n_thr + 1);

      int *picycle_thr = &icycle_thr[0];
      CVectorData < int >*pimaskblk_thr = &imaskblk_thr[0];

      for (i = 0; i < n_thr; i++)
         picycle_thr[i] = -1;

#ifdef USE_THREADS
#pragma omp parallel for
#endif
      for (int ipar = 0; ipar < _nblks; ipar++) {

         int my_thr = 0;
#ifdef USE_THREADS
         my_thr = omp_get_thread_num ();
#endif

         int ind, j;

         if (picycle_thr[my_thr] == -1) {
            pimaskblk_thr[my_thr].resize (nimax * 5 + 1);
            int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
            for (j = 0; j < nimax; j++)
               pimaskblk[j] = -1;
         }
         int icycleblk = picycle_thr[my_thr];
         int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
         for (j = pia_fin[ipar]; j < pia_fin[ipar + 1]; j++) {
            ind = pindHt2H[j];

            CMatrix < _Int, _Flt > at_blk;

            pA_sub[ind].TransposedSparsityList (icycleblk, pimaskblk, pimaskblk + nimax,
                                                pimaskblk + 2 * nimax,
                                                pimaskblk + 3 * nimax,
                                                pimaskblk + 4 * nimax, at_blk);

            pA_sub_fin[j].ReplaceFree (at_blk);
         }

         picycle_thr[my_thr] = icycleblk;
      }

   }

// Compute transposed hmatrix
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::TransposeHMatrix_BxB (int _blksize, int _nblks, long long *_blks,
                                    CBMatrix < _Int, _Flt > &_hmatr_ini, CBMatrix < _Int,
                                    _Flt > &_hmatr_fin)
   {

// Open hmatrix

      CMatrix < int, float >*phmatr = _hmatr_ini.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub = _hmatr_ini.GetASubArr ();

      int nzja_hmatr = phmatr->GetNzja ();
      int *pia_hmatr = phmatr->GetIaArr ();

// Compute transposed block sparsity

      CMatrix < int, float >hmatrT_str;
      vector < int >indHt2H (nzja_hmatr + 1);

      int *pindHt2H = &indHt2H[0];

      {

         CVectorData < int >imask (5 * _nblks + 1);
         int *pimask = imask.Ptr ();

         int i;

         for (i = 0; i < _nblks; i++)
            pimask[i] = -1;

         int icycle = -1;

         phmatr->TransposedSparsityListSp (icycle, pimask, pimask + _nblks,
                                           pimask + 2 * _nblks, pimask + 3 * _nblks,
                                           pimask + 4 * _nblks, hmatrT_str);

         int *pia_hmatrT = hmatrT_str.GetIaArr ();
         int *pja_hmatrT = hmatrT_str.GetJaArr ();

         for (i = 0; i < _nblks; i++)
            pimask[i] = pia_hmatr[i];

         int j, jj, k;

         for (i = 0; i < _nblks; i++) {
            for (j = pia_hmatrT[i]; j < pia_hmatrT[i + 1]; j++) {
               jj = pja_hmatrT[j];
               k = pimask[jj];
               pindHt2H[j] = k;
               pimask[jj]++;
            }
         }

      }

      int *pia_hmatrT = hmatrT_str.GetIaArr ();
      int *pja_hmatrT = hmatrT_str.GetJaArr ();

// Compute block sparsity of the triangular part of LU

      _hmatr_fin.SetNzblk (nzja_hmatr);
      _hmatr_fin.ResizeASub (nzja_hmatr);

      CMatrix < int, float >*phmatr_fin = _hmatr_fin.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub_fin = _hmatr_fin.GetASubArr ();

      phmatr_fin->ResizeAndSetAllSp (_nblks, _nblks, nzja_hmatr, nzja_hmatr);

      int *plist_fin = phmatr_fin->GetListArr ();
      int *plist2_fin = phmatr_fin->GetList2Arr ();
      int *pia_fin = phmatr_fin->GetIaArr ();
      int *pja_fin = phmatr_fin->GetJaArr ();
      int *pja2_fin = phmatr_fin->GetJa2Arr ();

      int i;

      for (i = 0; i < _nblks; i++)
         plist_fin[i] = i;
      for (i = 0; i < _nblks; i++)
         plist2_fin[i] = 0;
      for (i = 0; i < nzja_hmatr; i++)
         pja2_fin[i] = 0;
      for (i = 0; i <= _nblks; i++)
         pia_fin[i] = pia_hmatrT[i];
      for (i = 0; i < nzja_hmatr; i++)
         pja_fin[i] = pja_hmatrT[i];

// Compute maximal block size

      int nimax = 0;

      int niloc;

      for (i = 0; i < _nblks; i++) {
         niloc = (int) (_blks[i + 1] - _blks[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

// Transpose blocks

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      vector < int >icycle_thr (n_thr + 1);
      vector < CVectorData < int > >imaskblk_thr (n_thr + 1);

      int *picycle_thr = &icycle_thr[0];
      CVectorData < int >*pimaskblk_thr = &imaskblk_thr[0];

      for (i = 0; i < n_thr; i++)
         picycle_thr[i] = -1;

#ifdef USE_THREADS
#pragma omp parallel for
#endif
      for (int ipar = 0; ipar < _nblks; ipar++) {

         int my_thr = 0;
#ifdef USE_THREADS
         my_thr = omp_get_thread_num ();
#endif

         int ind, j;

         if (picycle_thr[my_thr] == -1) {
            pimaskblk_thr[my_thr].resize (nimax * 5 + 1);
            int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
            for (j = 0; j < nimax; j++)
               pimaskblk[j] = -1;
         }
         int icycleblk = picycle_thr[my_thr];
         int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
         for (j = pia_fin[ipar]; j < pia_fin[ipar + 1]; j++) {
            ind = pindHt2H[j];

            CMatrix < _Int, _Flt > at_blk;

            pA_sub[ind].TransposedSparsityList_BxB (_blksize, icycleblk, pimaskblk,
                                                    pimaskblk + nimax,
                                                    pimaskblk + 2 * nimax,
                                                    pimaskblk + 3 * nimax,
                                                    pimaskblk + 4 * nimax, at_blk);

            pA_sub_fin[j].ReplaceFree (at_blk);
         }

         picycle_thr[my_thr] = icycleblk;
      }

   }

// Compute reordered hmatrix
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ReorderHMatrix (int _nblks_ini, long long *_blks_ini, CBMatrix < _Int,
                              _Flt > &_hmatr_ini, int *_order, int _nblks_fin,
                              long long *_blks_fin, CBMatrix < _Int, _Flt > &_hmatr_fin)
   {

// Open hmatr

      CMatrix < int, float >*phmatr = _hmatr_ini.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub = _hmatr_ini.GetASubArr ();

      int *pia_hmatr = phmatr->GetIaArr ();
      int *pja_hmatr = phmatr->GetJaArr ();

// Create arrays that describes block numbers for each index

      int ntot = (int) _blks_ini[_nblks_ini];

      CVectorData < int >ind2blk_ini (ntot + 1);
      CVectorData < int >ind2blk_fin (ntot + 1);

      int *pind2blk_ini = ind2blk_ini.Ptr ();
      int *pind2blk_fin = ind2blk_fin.Ptr ();

      int i;

      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblks_ini; ipar++) {
            for (int i = (int)_blks_ini[ipar]; i < _blks_ini[ipar + 1]; i++) {
               pind2blk_ini[i] = ipar;
            }
         }
      }
      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblks_fin; ipar++) {
            for (int i = (int)_blks_fin[ipar]; i < _blks_fin[ipar + 1]; i++) {
               pind2blk_fin[i] = ipar;
            }
         }
      }

// Compute inverse order

      CVectorData < int >iorder (ntot + 1);

      int *piorder = iorder.Ptr ();

      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblks_ini; ipar++) {
            for (int i = (int)_blks_ini[ipar]; i < _blks_ini[ipar + 1]; i++) {
               piorder[_order[i]] = i;
            }
         }
      }

// Create set of combined initial block rows

      vector < CMatrix < _Int, _Flt > >blkrows (_nblks_ini + 1);
      CMatrix < _Int, _Flt > *pblkrows = &blkrows[0];

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      vector < int >icycle_thr (n_thr + 1);
      vector < CVectorData < int > >imaskblk_thr (n_thr + 1);

      int *picycle_thr = &icycle_thr[0];
      CVectorData < int >*pimaskblk_thr = &imaskblk_thr[0];

      for (i = 0; i < n_thr; i++)
         picycle_thr[i] = -1;

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblks_ini; ipar++) {

            int i, j, jj, k, kk, kkk, kj, jold, jnew, jblknew;

            int nlist_curr = (int) (_blks_ini[ipar + 1] - _blks_ini[ipar]);
            int nzja_curr = 0;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               nzja_curr += pA_sub[j].GetNzja ();
            }
            CMatrix < _Int, _Flt > ASub;
            ASub.ResizeAndSetAll (nlist_curr, 0, nzja_curr, nzja_curr, nzja_curr);
            _Int *pia_curr = ASub.GetIaArr ();
            _Int *pja_curr = ASub.GetJaArr ();
            _Int *pja2_curr = ASub.GetJa2Arr ();
            _Flt *pa_curr = ASub.GetAArr ();
            for (i = 0; i <= nlist_curr; i++)
               pia_curr[i] = 0;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               int nlist_temp = pA_sub[j].GetNlist ();
               _Int *plist_temp = pA_sub[j].GetListArr ();
               _Int *pia_temp = pA_sub[j].GetIaArr ();
               for (k = 0; k < nlist_temp; k++) {
                  kk = (int) plist_temp[k];
                  pia_curr[kk + 1] += (pia_temp[k + 1] - pia_temp[k]);
               }
            }
            for (i = 0; i < nlist_curr; i++)
               pia_curr[i + 1] = pia_curr[i] + pia_curr[i + 1];
            vector < int >iptr (nlist_curr + 1);
            int *piptr = &iptr[0];
            for (i = 0; i < nlist_curr; i++)
               piptr[i] = (int) pia_curr[i];
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               int nlist_temp = pA_sub[j].GetNlist ();
               _Int *plist_temp = pA_sub[j].GetListArr ();
               _Int *pia_temp = pA_sub[j].GetIaArr ();
               _Int *pja_temp = pA_sub[j].GetJaArr ();
               _Flt *pa_temp = pA_sub[j].GetAArr ();
               for (k = 0; k < nlist_temp; k++) {
                  kk = (int) plist_temp[k];
                  kkk = piptr[kk];
                  for (kj = (int) pia_temp[k]; kj < pia_temp[k + 1]; kj++) {
                     jold = (int) (pja_temp[kj] + _blks_ini[jj]);
                     jnew = _order[jold];
                     jblknew = pind2blk_fin[jnew];
                     pja_curr[kkk] = (_Int) (jnew - _blks_fin[jblknew]);
                     pja2_curr[kkk] = (_Int) jblknew;
                     pa_curr[kkk] = pa_temp[kj];
                     kkk++;
                  }
                  piptr[kk] = kkk;
               }
            }
            pblkrows[ipar].ReplaceFree (ASub);
         }
      }

// Compute maximal size

      int nimax = 0;

      int niloc;

      for (i = 0; i < _nblks_fin; i++) {
         niloc = (int) (_blks_fin[i + 1] - _blks_fin[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

// Create set of new block rows

      vector < CBMatrix < _Int, _Flt > >hblkrows_new (_nblks_fin + 1);
      CBMatrix < _Int, _Flt > *phblkrows_new = &hblkrows_new[0];

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblks_fin; ipar++) {

            int my_thr = 0;
#ifdef USE_THREADS
            my_thr = omp_get_thread_num ();
#endif

            int i, j;

            if (picycle_thr[my_thr] == -1) {
               pimaskblk_thr[my_thr].resize (3 * _nblks_fin + 1);
               int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
               for (j = 0; j < _nblks_fin; j++)
                  pimaskblk[j] = -1;
            }
            int icycleblk = picycle_thr[my_thr];
            int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
            int *plistblk = pimaskblk + _nblks_fin;
            int *pindblk = plistblk + _nblks_fin;

// Compute sizes of data

            int nzja_curr = 0;

            int iold, iblkold;

            for (i = (int) _blks_fin[ipar]; i < _blks_fin[ipar + 1]; i++) {
               iold = piorder[i];
               iblkold = pind2blk_ini[iold];
               iold = (int) (iold - _blks_ini[iblkold]);
               _Int *pia_temp = pblkrows[iblkold].GetIaArr ();
               nzja_curr += (int) (pia_temp[iold + 1] - pia_temp[iold]);
            }

            int nlist_curr = (int) (_blks_fin[ipar + 1] - _blks_fin[ipar]);

// Rewrite

            CMatrix < _Int, _Flt > ASub;
            ASub.ResizeAndSetAll (nlist_curr, 0, nzja_curr, nzja_curr, nzja_curr);

            _Int *pia_curr = ASub.GetIaArr ();
            _Int *pja_curr = ASub.GetJaArr ();
            _Int *pja2_curr = ASub.GetJa2Arr ();
            _Flt *pa_curr = ASub.GetAArr ();

            pia_curr[0] = 0;
            nzja_curr = 0;

            int ibeg = (int) _blks_fin[ipar];

            for (i = (int) _blks_fin[ipar]; i < _blks_fin[ipar + 1]; i++) {
               iold = piorder[i];
               iblkold = pind2blk_ini[iold];
               iold = (int) (iold - _blks_ini[iblkold]);
               _Int *pia_temp = pblkrows[iblkold].GetIaArr ();
               _Int *pja_temp = pblkrows[iblkold].GetJaArr ();
               _Int *pja2_temp = pblkrows[iblkold].GetJa2Arr ();
               _Flt *pa_temp = pblkrows[iblkold].GetAArr ();
               for (j = (int) pia_temp[iold]; j < pia_temp[iold + 1]; j++) {
                  pja_curr[nzja_curr] = pja_temp[j];
                  pja2_curr[nzja_curr] = pja2_temp[j];
                  pa_curr[nzja_curr] = pa_temp[j];
                  nzja_curr++;
               }
               pia_curr[i - ibeg + 1] = nzja_curr;
            }

// Split into the set of blocks

            icycleblk++;

            int nlistblk = 0;

            int jblk;

            for (i = 0; i < nzja_curr; i++) {
               jblk = (int) pja2_curr[i];
               if (pimaskblk[jblk] != icycleblk) {
                  plistblk[nlistblk] = jblk;
                  nlistblk++;
                  pimaskblk[jblk] = icycleblk;
               }
            }

            if (nlistblk == 0) {
               plistblk[0] = ipar;
               nlistblk = 1;
            }

            sort (plistblk, plistblk + nlistblk);

            for (i = 0; i < nlistblk; i++) {
               jblk = plistblk[i];
               pindblk[jblk] = i;
            }

            vector < int >nzblk_arr (nlistblk + 1);
            int *pnzblk_arr = &nzblk_arr[0];

            for (i = 0; i < nlistblk; i++)
               pnzblk_arr[i] = 0;

            int ind;

            for (i = 0; i < nzja_curr; i++) {
               jblk = (int) pja2_curr[i];
               ind = pindblk[jblk];
               pnzblk_arr[ind]++;
            }

            vector < vector < _Int > >rows_arr (nlistblk + 1);
            vector < vector < _Int > >cols_arr (nlistblk + 1);
            vector < vector < _Flt > >elems_arr (nlistblk + 1);

            vector < _Int > *prows_arr = &rows_arr[0];
            vector < _Int > *pcols_arr = &cols_arr[0];
            vector < _Flt > *pelems_arr = &elems_arr[0];

            for (i = 0; i < nlistblk; i++) {
               prows_arr[i].resize (pnzblk_arr[i] + 1);
               pcols_arr[i].resize (pnzblk_arr[i] + 1);
               pelems_arr[i].resize (pnzblk_arr[i] + 1);
            }

            for (i = 0; i < nlistblk; i++)
               pnzblk_arr[i] = 0;

            int jj, jj2, k;

            for (i = 0; i < nlist_curr; i++) {
               for (j = (int) pia_curr[i]; j < pia_curr[i + 1]; j++) {
                  jj = (int) pja_curr[j];
                  jj2 = (int) pja2_curr[j];
                  ind = pindblk[jj2];
                  k = pnzblk_arr[ind];
                  _Int *pprows_arr = &prows_arr[ind][0];
                  _Int *ppcols_arr = &pcols_arr[ind][0];
                  _Flt *ppelems_arr = &pelems_arr[ind][0];
                  pprows_arr[k] = i;
                  ppcols_arr[k] = jj;
                  ppelems_arr[k] = pa_curr[j];
                  pnzblk_arr[ind]++;
               }
            }

// Compute hblock

            phblkrows_new[ipar].SetNzblk (nlistblk);
            phblkrows_new[ipar].ResizeASub (nlistblk);

            CMatrix < int, float >*phmatr_new = phblkrows_new[ipar].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub_new = phblkrows_new[ipar].GetASubArr ();

            phmatr_new->SetNzja (nlistblk);
            phmatr_new->ResizeJa (nlistblk);

            int *pja_hmatr_new = phmatr_new->GetJaArr ();

            for (i = 0; i < nlistblk; i++)
               pja_hmatr_new[i] = plistblk[i];

            CVectorData < CSortInt > iiarr (nimax + 1);
            CVectorData < _Flt > elemsarr (nimax + 1);

            vector < int >imaskarr (nlist_curr + 1);
            vector < int >listarr (nlist_curr + 1);
            vector < int >indarr (nlist_curr + 1);

            CSortInt *piiarr = iiarr.Ptr ();
            _Flt *pelemsarr = elemsarr.Ptr ();

            int *pimaskarr = &imaskarr[0];
            int *plistarr = &listarr[0];
            int *pindarr = &indarr[0];

            for (i = 0; i < nlist_curr; i++)
               pimaskarr[i] = -1;

            int icycle = -1;
            int niloc;

            for (i = 0; i < nlistblk; i++) {
               icycle++;
               int nzja_temp = pnzblk_arr[i];
               _Int *pprows_arr = &prows_arr[i][0];
               _Int *ppcols_arr = &pcols_arr[i][0];
               _Flt *ppelems_arr = &pelems_arr[i][0];
               int nlist_temp = 0;
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  if (pimaskarr[jj] != icycle) {
                     plistarr[nlist_temp] = jj;
                     nlist_temp++;
                     pimaskarr[jj] = icycle;
                  }
               }
               sort (plistarr, plistarr + nlist_temp);
               for (j = 0; j < nlist_temp; j++) {
                  jj = plistarr[j];
                  pindarr[jj] = j;
               }
               pA_sub_new[i].ResizeAndSetAll (nlist_temp, 0, nzja_temp, 0, nzja_temp);
               _Int *plist_temp = pA_sub_new[i].GetListArr ();
               _Int *pia_temp = pA_sub_new[i].GetIaArr ();
               _Int *pja_temp = pA_sub_new[i].GetJaArr ();
               _Flt *pa_temp = pA_sub_new[i].GetAArr ();
               for (j = 0; j < nlist_temp; j++)
                  plist_temp[j] = plistarr[j];
               for (j = 0; j <= nlist_temp; j++)
                  pia_temp[j] = 0;
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  ind = pindarr[jj];
                  pia_temp[ind + 1]++;
               }
               for (j = 0; j < nlist_temp; j++)
                  pia_temp[j + 1] = pia_temp[j] + pia_temp[j + 1];
               for (j = 0; j < nlist_temp; j++)
                  plistarr[j] = (int) pia_temp[j];
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  ind = pindarr[jj];
                  k = plistarr[ind];
                  pja_temp[k] = ppcols_arr[j];
                  pa_temp[k] = ppelems_arr[j];
                  plistarr[ind]++;
               }
               for (j = 0; j < nlist_temp; j++) {
                  ibeg = (int) pia_temp[j];
                  niloc = (int) (pia_temp[j + 1] - pia_temp[j]);
                  for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                     piiarr[k - ibeg].ival = (int) pja_temp[k];
                     piiarr[k - ibeg].i2val = k;
                     pelemsarr[k - ibeg] = pa_temp[k];
                  }
                  sort (piiarr, piiarr + niloc);
                  for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                     pja_temp[k] = (_Int) piiarr[k - ibeg].ival;
                     ind = piiarr[k - ibeg].i2val;
                     pa_temp[k] = pelemsarr[ind - ibeg];
                  }
               }
            }

            picycle_thr[my_thr] = icycleblk;

         }

      }

// Combine computed data into one hmatrix

      int nzja_tot = 0;

      for (i = 0; i < _nblks_fin; i++) {
         nzja_tot += phblkrows_new[i].GetNzblk ();
      }

      _hmatr_fin.SetNzblk (nzja_tot);
      _hmatr_fin.ResizeASub (nzja_tot);

      CMatrix < int, float >*phmatr_fin = _hmatr_fin.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub_fin = _hmatr_fin.GetASubArr ();

      phmatr_fin->ResizeAndSetAllSp (_nblks_fin, _nblks_fin, nzja_tot, nzja_tot);

      int *plist_hmatr_fin = phmatr_fin->GetListArr ();
      int *plist2_hmatr_fin = phmatr_fin->GetList2Arr ();
      int *pia_hmatr_fin = phmatr_fin->GetIaArr ();
      int *pja_hmatr_fin = phmatr_fin->GetJaArr ();
      int *pja2_hmatr_fin = phmatr_fin->GetJa2Arr ();

      for (i = 0; i < _nblks_fin; i++)
         plist_hmatr_fin[i] = i;
      for (i = 0; i < _nblks_fin; i++)
         plist2_hmatr_fin[i] = 0;
      for (i = 0; i < nzja_tot; i++)
         pja2_hmatr_fin[i] = 0;

      nzja_tot = 0;
      pia_hmatr_fin[0] = 0;

      for (i = 0; i < _nblks_fin; i++) {
         int nzblk_temp = phblkrows_new[i].GetNzblk ();
         CMatrix < int, float >*phmatr_temp = phblkrows_new[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub_temp = phblkrows_new[i].GetASubArr ();
         int *pja_temp = phmatr_temp->GetJaArr ();
         int j;
         for (j = 0; j < nzblk_temp; j++) {
            pja_hmatr_fin[nzja_tot] = pja_temp[j];
            pA_sub_fin[nzja_tot].ReplaceFree (pA_sub_temp[j]);
            nzja_tot++;
         }
         pia_hmatr_fin[i + 1] = nzja_tot;
      }

   }

// Compute reordered hmatrix
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ReorderHMatrix_BxB (int _blksize, int _nblks_ini, long long *_blks_ini,
                                  const CBMatrix < _Int, _Flt > &_hmatr_ini, int *_order,
                                  int _nblks_fin, long long *_blks_fin, CBMatrix < _Int,
                                  _Flt > &_hmatr_fin)
   {

// Open hmatr

      int nzblk = _hmatr_ini.GetNzblk ();
      const CMatrix < _Int, _Flt > *pA_sub = _hmatr_ini.GetASubArr ();

      bool b_is_char = false;

      int i;

      for (i = 0; i < nzblk; i++) {
         if (pA_sub[i].GetNzjaChar () > 0)
            b_is_char = true;
      }

      if (b_is_char) {
         for (i = 0; i < nzblk; i++) {
            if (pA_sub[i].GetNzjaChar () != pA_sub[i].GetNzja ()) {
               cout <<
                  " CBMatrix<_Int,_Flt>::ReorderHMatrix_BxB: error: incorrect char data in blocks ! "
                  << endl;
               throw
                  " CBMatrix<_Int,_Flt>::ReorderHMatrix_BxB: error: incorrect char data in blocks ! ";
            }
         }
      }
// Reorder

      CBMatrix < _Int, _Flt >::ReorderHMatrix_BxB_impl (b_is_char, _blksize, _nblks_ini,
                                                        _blks_ini, _hmatr_ini, _order,
                                                        _nblks_fin, _blks_fin,
                                                        _hmatr_fin);

   }

// Compute reordered hmatrix (implementation)
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ReorderHMatrix_BxB_impl (bool _b_is_char, int _blksize, int _nblks_ini,
                                       long long *_blks_ini, const CBMatrix < _Int,
                                       _Flt > &_hmatr_ini, int *_order, int _nblks_fin,
                                       long long *_blks_fin, CBMatrix < _Int,
                                       _Flt > &_hmatr_fin)
   {

// Open hmatr

      int b_2 = _blksize * _blksize;

      const CMatrix < int, float >*phmatr = _hmatr_ini.GetHMatrStr ();
      const CMatrix < _Int, _Flt > *pA_sub = _hmatr_ini.GetASubArr ();

      const int *pia_hmatr = phmatr->GetIaArr ();
      const int *pja_hmatr = phmatr->GetJaArr ();

// Create arrays that describes block numbers for each index

      int ntot = (int) _blks_ini[_nblks_ini];

      CVectorData < int >ind2blk_ini (ntot + 1);
      CVectorData < int >ind2blk_fin (ntot + 1);

      int *pind2blk_ini = ind2blk_ini.Ptr ();
      int *pind2blk_fin = ind2blk_fin.Ptr ();

      int i;

      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblks_ini; ipar++) {
            for (int i = (int)_blks_ini[ipar]; i < _blks_ini[ipar + 1]; i++) {
               pind2blk_ini[i] = ipar;
            }
         }
      }
      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblks_fin; ipar++) {
            for (int i = (int)_blks_fin[ipar]; i < _blks_fin[ipar + 1]; i++) {
               pind2blk_fin[i] = ipar;
            }
         }
      }

// Compute inverse order

      CVectorData < int >iorder (ntot + 1);

      int *piorder = iorder.Ptr ();

      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblks_ini; ipar++) {
            for (int i = (int)_blks_ini[ipar]; i < _blks_ini[ipar + 1]; i++) {
               piorder[_order[i]] = i;
            }
         }
      }

// Create set of combined initial block rows

      vector < CMatrix < _Int, _Flt > >blkrows (_nblks_ini + 1);
      CMatrix < _Int, _Flt > *pblkrows = &blkrows[0];

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      vector < int >icycle_thr (n_thr + 1);
      vector < CVectorData < int > >imaskblk_thr (n_thr + 1);

      int *picycle_thr = &icycle_thr[0];
      CVectorData < int >*pimaskblk_thr = &imaskblk_thr[0];

      for (i = 0; i < n_thr; i++)
         picycle_thr[i] = -1;

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblks_ini; ipar++) {

            int i, j, jj, k, kk, kkk, kj, jold, jnew, jblknew;

            int nlist_curr = (int) (_blks_ini[ipar + 1] - _blks_ini[ipar]);
            int nzja_curr = 0;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               nzja_curr += pA_sub[j].GetNzja ();
            }
            CMatrix < _Int, _Flt > ASub;
            ASub.ResizeAndSetAll (nlist_curr, 0, nzja_curr, nzja_curr, nzja_curr * b_2);
            if (_b_is_char) {
               ASub.ResizeJaChar (nzja_curr);
               ASub.SetNzjaChar (nzja_curr);
            }
            _Int *pia_curr = ASub.GetIaArr ();
            _Int *pja_curr = ASub.GetJaArr ();
            _Int *pja2_curr = ASub.GetJa2Arr ();
            char *pjachar_curr = ASub.GetJaCharArr ();
            _Flt *pa_curr = ASub.GetAArr ();
            for (i = 0; i <= nlist_curr; i++)
               pia_curr[i] = 0;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               int nlist_temp = pA_sub[j].GetNlist ();
               const _Int *plist_temp = pA_sub[j].GetListArr ();
               const _Int *pia_temp = pA_sub[j].GetIaArr ();
               for (k = 0; k < nlist_temp; k++) {
                  kk = (int) plist_temp[k];
                  pia_curr[kk + 1] += (pia_temp[k + 1] - pia_temp[k]);
               }
            }
            for (i = 0; i < nlist_curr; i++)
               pia_curr[i + 1] = pia_curr[i] + pia_curr[i + 1];
            vector < int >iptr (nlist_curr + 1);
            int *piptr = &iptr[0];
            for (i = 0; i < nlist_curr; i++)
               piptr[i] = (int) pia_curr[i];
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               int nlist_temp = pA_sub[j].GetNlist ();
               const _Int *plist_temp = pA_sub[j].GetListArr ();
               const _Int *pia_temp = pA_sub[j].GetIaArr ();
               const _Int *pja_temp = pA_sub[j].GetJaArr ();
               const char *pjachar_temp = pA_sub[j].GetJaCharArr ();
               const _Flt *pa_temp = pA_sub[j].GetAArr ();
               for (k = 0; k < nlist_temp; k++) {
                  kk = (int) plist_temp[k];
                  kkk = piptr[kk];
                  for (kj = (int) pia_temp[k]; kj < pia_temp[k + 1]; kj++) {
                     jold = (int) (pja_temp[kj] + _blks_ini[jj]);
                     jnew = _order[jold];
                     jblknew = pind2blk_fin[jnew];
                     pja_curr[kkk] = (_Int) (jnew - _blks_fin[jblknew]);
                     pja2_curr[kkk] = (_Int) jblknew;
                     if (_b_is_char)
                        pjachar_curr[kkk] = pjachar_temp[kj];
                     CVector < _Flt >::CopyVector (b_2, pa_temp + kj * b_2,
                                                   pa_curr + kkk * b_2);
                     kkk++;
                  }
                  piptr[kk] = kkk;
               }
            }
            pblkrows[ipar].ReplaceFree (ASub);
         }
      }

// Compute maximal size

      int nimax = 0;

      int niloc;

      for (i = 0; i < _nblks_fin; i++) {
         niloc = (int) (_blks_fin[i + 1] - _blks_fin[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

// Create set of new block rows

      vector < CBMatrix < _Int, _Flt > >hblkrows_new (_nblks_fin + 1);
      CBMatrix < _Int, _Flt > *phblkrows_new = &hblkrows_new[0];

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblks_fin; ipar++) {

            int my_thr = 0;
#ifdef USE_THREADS
            my_thr = omp_get_thread_num ();
#endif

            int i, j;

            if (picycle_thr[my_thr] == -1) {
               pimaskblk_thr[my_thr].resize (3 * _nblks_fin + 1);
               int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
               for (j = 0; j < _nblks_fin; j++)
                  pimaskblk[j] = -1;
            }
            int icycleblk = picycle_thr[my_thr];
            int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
            int *plistblk = pimaskblk + _nblks_fin;
            int *pindblk = plistblk + _nblks_fin;

// Compute sizes of data

            int nzja_curr = 0;

            int iold, iblkold;

            for (i = (int) _blks_fin[ipar]; i < _blks_fin[ipar + 1]; i++) {
               iold = piorder[i];
               iblkold = pind2blk_ini[iold];
               iold = (int) (iold - _blks_ini[iblkold]);
               _Int *pia_temp = pblkrows[iblkold].GetIaArr ();
               nzja_curr += (int) (pia_temp[iold + 1] - pia_temp[iold]);
            }

            int nlist_curr = (int) (_blks_fin[ipar + 1] - _blks_fin[ipar]);

// Rewrite

            CMatrix < _Int, _Flt > ASub;
            ASub.ResizeAndSetAll (nlist_curr, 0, nzja_curr, nzja_curr, nzja_curr * b_2);
            if (_b_is_char) {
               ASub.ResizeJaChar (nzja_curr);
               ASub.SetNzjaChar (nzja_curr);
            }
            _Int *pia_curr = ASub.GetIaArr ();
            _Int *pja_curr = ASub.GetJaArr ();
            _Int *pja2_curr = ASub.GetJa2Arr ();
            char *pjachar_curr = ASub.GetJaCharArr ();
            _Flt *pa_curr = ASub.GetAArr ();

            pia_curr[0] = 0;
            nzja_curr = 0;

            int ibeg = (int) _blks_fin[ipar];

            for (i = (int) _blks_fin[ipar]; i < _blks_fin[ipar + 1]; i++) {
               iold = piorder[i];
               iblkold = pind2blk_ini[iold];
               iold = (int) (iold - _blks_ini[iblkold]);
               _Int *pia_temp = pblkrows[iblkold].GetIaArr ();
               _Int *pja_temp = pblkrows[iblkold].GetJaArr ();
               _Int *pja2_temp = pblkrows[iblkold].GetJa2Arr ();
               char *pjachar_temp = pblkrows[iblkold].GetJaCharArr ();
               _Flt *pa_temp = pblkrows[iblkold].GetAArr ();
               for (j = (int) pia_temp[iold]; j < pia_temp[iold + 1]; j++) {
                  pja_curr[nzja_curr] = pja_temp[j];
                  pja2_curr[nzja_curr] = pja2_temp[j];
                  if (_b_is_char)
                     pjachar_curr[nzja_curr] = pjachar_temp[j];
                  CVector < _Flt >::CopyVector (b_2, pa_temp + j * b_2,
                                                pa_curr + nzja_curr * b_2);
                  nzja_curr++;
               }
               pia_curr[i - ibeg + 1] = nzja_curr;
            }

// Split into the set of blocks

            icycleblk++;

            int nlistblk = 0;

            int jblk;

            for (i = 0; i < nzja_curr; i++) {
               jblk = (int) pja2_curr[i];
               if (pimaskblk[jblk] != icycleblk) {
                  plistblk[nlistblk] = jblk;
                  nlistblk++;
                  pimaskblk[jblk] = icycleblk;
               }
            }

            if (nlistblk == 0) {
               plistblk[0] = ipar;
               nlistblk = 1;
            }

            sort (plistblk, plistblk + nlistblk);

            for (i = 0; i < nlistblk; i++) {
               jblk = plistblk[i];
               pindblk[jblk] = i;
            }

            vector < int >nzblk_arr (nlistblk + 1);
            int *pnzblk_arr = &nzblk_arr[0];

            for (i = 0; i < nlistblk; i++)
               pnzblk_arr[i] = 0;

            int ind;

            for (i = 0; i < nzja_curr; i++) {
               jblk = (int) pja2_curr[i];
               ind = pindblk[jblk];
               pnzblk_arr[ind]++;
            }

            vector < vector < _Int > >rows_arr (nlistblk + 1);
            vector < vector < _Int > >cols_arr (nlistblk + 1);
            vector < vector < char > >chars_arr (nlistblk + 1);
            vector < vector < _Flt > >elems_arr (nlistblk + 1);

            vector < _Int > *prows_arr = rows_arr.data ();
            vector < _Int > *pcols_arr = cols_arr.data ();
            vector < char >*pchars_arr = chars_arr.data ();
            vector < _Flt > *pelems_arr = elems_arr.data ();

            for (i = 0; i < nlistblk; i++) {
               prows_arr[i].resize (pnzblk_arr[i] + 1);
               pcols_arr[i].resize (pnzblk_arr[i] + 1);
               if (_b_is_char)
                  pchars_arr[i].resize (pnzblk_arr[i] + 1);
               pelems_arr[i].resize (pnzblk_arr[i] * b_2 + 1);
            }

            for (i = 0; i < nlistblk; i++)
               pnzblk_arr[i] = 0;

            int jj, jj2, k;

            for (i = 0; i < nlist_curr; i++) {
               for (j = (int) pia_curr[i]; j < pia_curr[i + 1]; j++) {
                  jj = (int) pja_curr[j];
                  jj2 = (int) pja2_curr[j];
                  ind = pindblk[jj2];
                  k = pnzblk_arr[ind];
                  _Int *pprows_arr = prows_arr[ind].data ();
                  _Int *ppcols_arr = pcols_arr[ind].data ();
                  char *ppchars_arr = pchars_arr[ind].data ();
                  _Flt *ppelems_arr = pelems_arr[ind].data ();
                  pprows_arr[k] = i;
                  ppcols_arr[k] = jj;
                  if (_b_is_char)
                     ppchars_arr[k] = pjachar_curr[j];
                  CVector < _Flt >::CopyVector (b_2, pa_curr + j * b_2,
                                                ppelems_arr + k * b_2);
                  pnzblk_arr[ind]++;
               }
            }

// Compute hblock

            phblkrows_new[ipar].SetNzblk (nlistblk);
            phblkrows_new[ipar].ResizeASub (nlistblk);

            CMatrix < int, float >*phmatr_new = phblkrows_new[ipar].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub_new = phblkrows_new[ipar].GetASubArr ();

            phmatr_new->SetNzja (nlistblk);
            phmatr_new->ResizeJa (nlistblk);

            int *pja_hmatr_new = phmatr_new->GetJaArr ();

            for (i = 0; i < nlistblk; i++)
               pja_hmatr_new[i] = plistblk[i];

            CVectorData < CSortInt > iiarr (nimax + 1);
            CVectorData < _Flt > elemsarr (nimax * b_2 + 1);

            vector < int >imaskarr (nlist_curr + 1);
            vector < int >listarr (nlist_curr + 1);
            vector < int >indarr (nlist_curr + 1);

            CSortInt *piiarr = iiarr.Ptr ();
            _Flt *pelemsarr = elemsarr.Ptr ();

            int *pimaskarr = imaskarr.data ();
            int *plistarr = listarr.data ();
            int *pindarr = indarr.data ();

            for (i = 0; i < nlist_curr; i++)
               pimaskarr[i] = -1;

            int icycle = -1;
            int niloc;

            for (i = 0; i < nlistblk; i++) {
               icycle++;
               int nzja_temp = pnzblk_arr[i];
               _Int *pprows_arr = prows_arr[i].data ();
               _Int *ppcols_arr = pcols_arr[i].data ();
               char *ppchars_arr = pchars_arr[i].data ();
               _Flt *ppelems_arr = pelems_arr[i].data ();
               int nlist_temp = 0;
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  if (pimaskarr[jj] != icycle) {
                     plistarr[nlist_temp] = jj;
                     nlist_temp++;
                     pimaskarr[jj] = icycle;
                  }
               }
               sort (plistarr, plistarr + nlist_temp);
               for (j = 0; j < nlist_temp; j++) {
                  jj = plistarr[j];
                  pindarr[jj] = j;
               }
               pA_sub_new[i].ResizeAndSetAll (nlist_temp, 0, nzja_temp, 0,
                                              nzja_temp * b_2);
               if (_b_is_char) {
                  pA_sub_new[i].ResizeJaChar (nzja_temp);
                  pA_sub_new[i].SetNzjaChar (nzja_temp);
               }
               _Int *plist_temp = pA_sub_new[i].GetListArr ();
               _Int *pia_temp = pA_sub_new[i].GetIaArr ();
               _Int *pja_temp = pA_sub_new[i].GetJaArr ();
               char *pjachar_temp = pA_sub_new[i].GetJaCharArr ();
               _Flt *pa_temp = pA_sub_new[i].GetAArr ();
               for (j = 0; j < nlist_temp; j++)
                  plist_temp[j] = plistarr[j];
               for (j = 0; j <= nlist_temp; j++)
                  pia_temp[j] = 0;
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  ind = pindarr[jj];
                  pia_temp[ind + 1]++;
               }
               for (j = 0; j < nlist_temp; j++)
                  pia_temp[j + 1] = pia_temp[j] + pia_temp[j + 1];
               for (j = 0; j < nlist_temp; j++)
                  plistarr[j] = (int) pia_temp[j];
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  ind = pindarr[jj];
                  k = plistarr[ind];
                  pja_temp[k] = ppcols_arr[j];
                  if (_b_is_char)
                     pjachar_temp[k] = ppchars_arr[j];
                  CVector < _Flt >::CopyVector (b_2, ppelems_arr + j * b_2,
                                                pa_temp + k * b_2);
                  plistarr[ind]++;
               }
               for (j = 0; j < nlist_temp; j++) {
                  ibeg = (int) pia_temp[j];
                  niloc = (int) (pia_temp[j + 1] - pia_temp[j]);
                  for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                     piiarr[k - ibeg].ival = (int) pja_temp[k];
                     piiarr[k - ibeg].i2val = k;
                     if (_b_is_char)
                        ppchars_arr[k - ibeg] = pjachar_temp[k];
                     CVector < _Flt >::CopyVector (b_2, pa_temp + k * b_2,
                                                   pelemsarr + (k - ibeg) * b_2);
                  }
                  sort (piiarr, piiarr + niloc);
                  for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                     pja_temp[k] = (_Int) piiarr[k - ibeg].ival;
                     ind = piiarr[k - ibeg].i2val;
                     if (_b_is_char)
                        pjachar_temp[k] = ppchars_arr[ind - ibeg];
                     CVector < _Flt >::CopyVector (b_2, pelemsarr + (ind - ibeg) * b_2,
                                                   pa_temp + k * b_2);
                  }
               }
            }

            picycle_thr[my_thr] = icycleblk;

         }

      }

// Combine computed data into one hmatrix

      int nzja_tot = 0;

      for (i = 0; i < _nblks_fin; i++) {
         nzja_tot += phblkrows_new[i].GetNzblk ();
      }

      _hmatr_fin.SetNzblk (nzja_tot);
      _hmatr_fin.ResizeASub (nzja_tot);

      CMatrix < int, float >*phmatr_fin = _hmatr_fin.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub_fin = _hmatr_fin.GetASubArr ();

      phmatr_fin->ResizeAndSetAllSp (_nblks_fin, _nblks_fin, nzja_tot, nzja_tot);

      int *plist_hmatr_fin = phmatr_fin->GetListArr ();
      int *plist2_hmatr_fin = phmatr_fin->GetList2Arr ();
      int *pia_hmatr_fin = phmatr_fin->GetIaArr ();
      int *pja_hmatr_fin = phmatr_fin->GetJaArr ();
      int *pja2_hmatr_fin = phmatr_fin->GetJa2Arr ();

      for (i = 0; i < _nblks_fin; i++)
         plist_hmatr_fin[i] = i;
      for (i = 0; i < _nblks_fin; i++)
         plist2_hmatr_fin[i] = 0;
      for (i = 0; i < nzja_tot; i++)
         pja2_hmatr_fin[i] = 0;

      nzja_tot = 0;
      pia_hmatr_fin[0] = 0;

      for (i = 0; i < _nblks_fin; i++) {
         int nzblk_temp = phblkrows_new[i].GetNzblk ();
         CMatrix < int, float >*phmatr_temp = phblkrows_new[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub_temp = phblkrows_new[i].GetASubArr ();
         int *pja_temp = phmatr_temp->GetJaArr ();
         int j;
         for (j = 0; j < nzblk_temp; j++) {
            pja_hmatr_fin[nzja_tot] = pja_temp[j];
            pA_sub_fin[nzja_tot].ReplaceFree (pA_sub_temp[j]);
            nzja_tot++;
         }
         pia_hmatr_fin[i + 1] = nzja_tot;
      }

   }

// Compute reordered hmatrix rows
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ReorderHMatrixRows (int _nblksC, long long *_blksC, int _nblksR_ini,
                                  long long *_blksR_ini, CBMatrix < _Int,
                                  _Flt > &_hmatr_ini, int *_orderR, int _nblksR_fin,
                                  long long *_blksR_fin, CBMatrix < _Int,
                                  _Flt > &_hmatr_fin)
   {

// Open hmatr

      CMatrix < int, float >*phmatr = _hmatr_ini.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub = _hmatr_ini.GetASubArr ();

      int *pia_hmatr = phmatr->GetIaArr ();
      int *pja_hmatr = phmatr->GetJaArr ();

// Create arrays that describes block numbers for each index

      int mtot = (int) _blksR_ini[_nblksR_ini];

      CVectorData < int >ind2blkR_ini (mtot + 1);
      CVectorData < int >ind2blkR_fin (mtot + 1);

      int *pind2blkR_ini = ind2blkR_ini.Ptr ();
      int *pind2blkR_fin = ind2blkR_fin.Ptr ();

      int i;

      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksR_ini; ipar++) {
            for (int i = (int)_blksR_ini[ipar]; i < _blksR_ini[ipar + 1]; i++) {
               pind2blkR_ini[i] = ipar;
            }
         }
      }
      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksR_fin; ipar++) {
            for (int i = (int)_blksR_fin[ipar]; i < _blksR_fin[ipar + 1]; i++) {
               pind2blkR_fin[i] = ipar;
            }
         }
      }

      int nblks_max = _nblksR_ini;
      if (_nblksR_fin > nblks_max)
         nblks_max = _nblksR_fin;
      if (_nblksC > nblks_max)
         nblks_max = _nblksC;

// Compute inverse order

      CVectorData < int >iorderR (mtot + 1);

      int *piorderR = iorderR.Ptr ();

      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksR_ini; ipar++) {
            for (int i = (int)_blksR_ini[ipar]; i < _blksR_ini[ipar + 1]; i++) {
               piorderR[_orderR[i]] = i;
            }
         }
      }

// Create set of combined initial block rows

      vector < CMatrix < _Int, _Flt > >blkrows (_nblksR_ini + 1);
      CMatrix < _Int, _Flt > *pblkrows = &blkrows[0];

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      vector < int >icycle_thr (n_thr + 1);
      vector < CVectorData < int > >imaskblk_thr (n_thr + 1);

      int *picycle_thr = &icycle_thr[0];
      CVectorData < int >*pimaskblk_thr = &imaskblk_thr[0];

      for (i = 0; i < n_thr; i++)
         picycle_thr[i] = -1;

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksR_ini; ipar++) {

            int i, j, jj, k, kk, kkk, kj, jold;

            int nlist_curr = (int) (_blksR_ini[ipar + 1] - _blksR_ini[ipar]);
            int nzja_curr = 0;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               nzja_curr += pA_sub[j].GetNzja ();
            }
            CMatrix < _Int, _Flt > ASub;
            ASub.ResizeAndSetAll (nlist_curr, 0, nzja_curr, nzja_curr, nzja_curr);
            _Int *pia_curr = ASub.GetIaArr ();
            _Int *pja_curr = ASub.GetJaArr ();
            _Int *pja2_curr = ASub.GetJa2Arr ();
            _Flt *pa_curr = ASub.GetAArr ();
            for (i = 0; i <= nlist_curr; i++)
               pia_curr[i] = 0;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               int nlist_temp = pA_sub[j].GetNlist ();
               _Int *plist_temp = pA_sub[j].GetListArr ();
               _Int *pia_temp = pA_sub[j].GetIaArr ();
               for (k = 0; k < nlist_temp; k++) {
                  kk = (int) plist_temp[k];
                  pia_curr[kk + 1] += (pia_temp[k + 1] - pia_temp[k]);
               }
            }
            for (i = 0; i < nlist_curr; i++)
               pia_curr[i + 1] = pia_curr[i] + pia_curr[i + 1];
            vector < int >iptr (nlist_curr + 1);
            int *piptr = &iptr[0];
            for (i = 0; i < nlist_curr; i++)
               piptr[i] = (int) pia_curr[i];
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               int nlist_temp = pA_sub[j].GetNlist ();
               _Int *plist_temp = pA_sub[j].GetListArr ();
               _Int *pia_temp = pA_sub[j].GetIaArr ();
               _Int *pja_temp = pA_sub[j].GetJaArr ();
               _Flt *pa_temp = pA_sub[j].GetAArr ();
               for (k = 0; k < nlist_temp; k++) {
                  kk = (int) plist_temp[k];
                  kkk = piptr[kk];
                  for (kj = (int) pia_temp[k]; kj < pia_temp[k + 1]; kj++) {
                     jold = (int) (pja_temp[kj]);
                     pja_curr[kkk] = (_Int) (jold);
                     pja2_curr[kkk] = (_Int) jj;
                     pa_curr[kkk] = pa_temp[kj];
                     kkk++;
                  }
                  piptr[kk] = kkk;
               }
            }
            pblkrows[ipar].ReplaceFree (ASub);
         }
      }

// Compute maximal size

      int nimax = 0;

      int niloc;

      for (i = 0; i < _nblksC; i++) {
         niloc = (int) (_blksC[i + 1] - _blksC[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

      for (i = 0; i < _nblksR_fin; i++) {
         niloc = (int) (_blksR_fin[i + 1] - _blksR_fin[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

// Create set of new block rows

      vector < CBMatrix < _Int, _Flt > >hblkrows_new (_nblksR_fin + 1);
      CBMatrix < _Int, _Flt > *phblkrows_new = &hblkrows_new[0];

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksR_fin; ipar++) {

            int my_thr = 0;
#ifdef USE_THREADS
            my_thr = omp_get_thread_num ();
#endif

            int i, j;

            if (picycle_thr[my_thr] == -1) {
               pimaskblk_thr[my_thr].resize (3 * nblks_max + 1);
               int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
               for (j = 0; j < nblks_max; j++)
                  pimaskblk[j] = -1;
            }
            int icycleblk = picycle_thr[my_thr];
            int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
            int *plistblk = pimaskblk + nblks_max;
            int *pindblk = plistblk + nblks_max;

// Compute sizes of data

            int nzja_curr = 0;

            int iold, iblkold;

            for (i = (int) _blksR_fin[ipar]; i < _blksR_fin[ipar + 1]; i++) {
               iold = piorderR[i];
               iblkold = pind2blkR_ini[iold];
               iold = (int) (iold - _blksR_ini[iblkold]);
               _Int *pia_temp = pblkrows[iblkold].GetIaArr ();
               nzja_curr += (int) (pia_temp[iold + 1] - pia_temp[iold]);
            }

            int nlist_curr = (int) (_blksR_fin[ipar + 1] - _blksR_fin[ipar]);

// Rewrite

            CMatrix < _Int, _Flt > ASub;
            ASub.ResizeAndSetAll (nlist_curr, 0, nzja_curr, nzja_curr, nzja_curr);

            _Int *pia_curr = ASub.GetIaArr ();
            _Int *pja_curr = ASub.GetJaArr ();
            _Int *pja2_curr = ASub.GetJa2Arr ();
            _Flt *pa_curr = ASub.GetAArr ();

            pia_curr[0] = 0;
            nzja_curr = 0;

            int ibeg = (int) _blksR_fin[ipar];

            for (i = (int) _blksR_fin[ipar]; i < _blksR_fin[ipar + 1]; i++) {
               iold = piorderR[i];
               iblkold = pind2blkR_ini[iold];
               iold = (int) (iold - _blksR_ini[iblkold]);
               _Int *pia_temp = pblkrows[iblkold].GetIaArr ();
               _Int *pja_temp = pblkrows[iblkold].GetJaArr ();
               _Int *pja2_temp = pblkrows[iblkold].GetJa2Arr ();
               _Flt *pa_temp = pblkrows[iblkold].GetAArr ();
               for (j = (int) pia_temp[iold]; j < pia_temp[iold + 1]; j++) {
                  pja_curr[nzja_curr] = pja_temp[j];
                  pja2_curr[nzja_curr] = pja2_temp[j];
                  pa_curr[nzja_curr] = pa_temp[j];
                  nzja_curr++;
               }
               pia_curr[i - ibeg + 1] = nzja_curr;
            }

// Split into the set of blocks

            icycleblk++;

            int nlistblk = 0;

            int jblk;

            for (i = 0; i < nzja_curr; i++) {
               jblk = (int) pja2_curr[i];
               if (pimaskblk[jblk] != icycleblk) {
                  plistblk[nlistblk] = jblk;
                  nlistblk++;
                  pimaskblk[jblk] = icycleblk;
               }
            }

            if (nlistblk == 0) {
               plistblk[0] = ipar;
               nlistblk = 1;
            }

            sort (plistblk, plistblk + nlistblk);

            for (i = 0; i < nlistblk; i++) {
               jblk = plistblk[i];
               pindblk[jblk] = i;
            }

            vector < int >nzblk_arr (nlistblk + 1);
            int *pnzblk_arr = &nzblk_arr[0];

            for (i = 0; i < nlistblk; i++)
               pnzblk_arr[i] = 0;

            int ind;

            for (i = 0; i < nzja_curr; i++) {
               jblk = (int) pja2_curr[i];
               ind = pindblk[jblk];
               pnzblk_arr[ind]++;
            }

            vector < vector < _Int > >rows_arr (nlistblk + 1);
            vector < vector < _Int > >cols_arr (nlistblk + 1);
            vector < vector < _Flt > >elems_arr (nlistblk + 1);

            vector < _Int > *prows_arr = &rows_arr[0];
            vector < _Int > *pcols_arr = &cols_arr[0];
            vector < _Flt > *pelems_arr = &elems_arr[0];

            for (i = 0; i < nlistblk; i++) {
               prows_arr[i].resize (pnzblk_arr[i] + 1);
               pcols_arr[i].resize (pnzblk_arr[i] + 1);
               pelems_arr[i].resize (pnzblk_arr[i] + 1);
            }

            for (i = 0; i < nlistblk; i++)
               pnzblk_arr[i] = 0;

            int jj, jj2, k;

            for (i = 0; i < nlist_curr; i++) {
               for (j = (int) pia_curr[i]; j < pia_curr[i + 1]; j++) {
                  jj = (int) pja_curr[j];
                  jj2 = (int) pja2_curr[j];
                  ind = pindblk[jj2];
                  k = pnzblk_arr[ind];
                  _Int *pprows_arr = &prows_arr[ind][0];
                  _Int *ppcols_arr = &pcols_arr[ind][0];
                  _Flt *ppelems_arr = &pelems_arr[ind][0];
                  pprows_arr[k] = i;
                  ppcols_arr[k] = jj;
                  ppelems_arr[k] = pa_curr[j];
                  pnzblk_arr[ind]++;
               }
            }

// Compute hblock

            phblkrows_new[ipar].SetNzblk (nlistblk);
            phblkrows_new[ipar].ResizeASub (nlistblk);

            CMatrix < int, float >*phmatr_new = phblkrows_new[ipar].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub_new = phblkrows_new[ipar].GetASubArr ();

            phmatr_new->SetNzja (nlistblk);
            phmatr_new->ResizeJa (nlistblk);

            int *pja_hmatr_new = phmatr_new->GetJaArr ();

            for (i = 0; i < nlistblk; i++)
               pja_hmatr_new[i] = plistblk[i];

            CVectorData < CSortInt > iiarr (nimax + 1);
            CVectorData < _Flt > elemsarr (nimax + 1);

            vector < int >imaskarr (nlist_curr + 1);
            vector < int >listarr (nlist_curr + 1);
            vector < int >indarr (nlist_curr + 1);

            CSortInt *piiarr = iiarr.Ptr ();
            _Flt *pelemsarr = elemsarr.Ptr ();

            int *pimaskarr = &imaskarr[0];
            int *plistarr = &listarr[0];
            int *pindarr = &indarr[0];

            for (i = 0; i < nlist_curr; i++)
               pimaskarr[i] = -1;

            int icycle = -1;
            int niloc;

            for (i = 0; i < nlistblk; i++) {
               icycle++;
               int nzja_temp = pnzblk_arr[i];
               _Int *pprows_arr = &prows_arr[i][0];
               _Int *ppcols_arr = &pcols_arr[i][0];
               _Flt *ppelems_arr = &pelems_arr[i][0];
               int nlist_temp = 0;
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  if (pimaskarr[jj] != icycle) {
                     plistarr[nlist_temp] = jj;
                     nlist_temp++;
                     pimaskarr[jj] = icycle;
                  }
               }
               sort (plistarr, plistarr + nlist_temp);
               for (j = 0; j < nlist_temp; j++) {
                  jj = plistarr[j];
                  pindarr[jj] = j;
               }
               pA_sub_new[i].ResizeAndSetAll (nlist_temp, 0, nzja_temp, 0, nzja_temp);
               _Int *plist_temp = pA_sub_new[i].GetListArr ();
               _Int *pia_temp = pA_sub_new[i].GetIaArr ();
               _Int *pja_temp = pA_sub_new[i].GetJaArr ();
               _Flt *pa_temp = pA_sub_new[i].GetAArr ();
               for (j = 0; j < nlist_temp; j++)
                  plist_temp[j] = plistarr[j];
               for (j = 0; j <= nlist_temp; j++)
                  pia_temp[j] = 0;
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  ind = pindarr[jj];
                  pia_temp[ind + 1]++;
               }
               for (j = 0; j < nlist_temp; j++)
                  pia_temp[j + 1] = pia_temp[j] + pia_temp[j + 1];
               for (j = 0; j < nlist_temp; j++)
                  plistarr[j] = (int) pia_temp[j];
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  ind = pindarr[jj];
                  k = plistarr[ind];
                  pja_temp[k] = ppcols_arr[j];
                  pa_temp[k] = ppelems_arr[j];
                  plistarr[ind]++;
               }
               for (j = 0; j < nlist_temp; j++) {
                  ibeg = (int) pia_temp[j];
                  niloc = (int) (pia_temp[j + 1] - pia_temp[j]);
                  for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                     piiarr[k - ibeg].ival = (int) pja_temp[k];
                     piiarr[k - ibeg].i2val = k;
                     pelemsarr[k - ibeg] = pa_temp[k];
                  }
                  sort (piiarr, piiarr + niloc);
                  for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                     pja_temp[k] = (_Int) piiarr[k - ibeg].ival;
                     ind = piiarr[k - ibeg].i2val;
                     pa_temp[k] = pelemsarr[ind - ibeg];
                  }
               }
            }

            picycle_thr[my_thr] = icycleblk;

         }

      }

// Combine computed data into one hmatrix

      int nzja_tot = 0;

      for (i = 0; i < _nblksR_fin; i++) {
         nzja_tot += phblkrows_new[i].GetNzblk ();
      }

      _hmatr_fin.SetNzblk (nzja_tot);
      _hmatr_fin.ResizeASub (nzja_tot);

      CMatrix < int, float >*phmatr_fin = _hmatr_fin.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub_fin = _hmatr_fin.GetASubArr ();

      phmatr_fin->ResizeAndSetAllSp (_nblksR_fin, _nblksR_fin, nzja_tot, nzja_tot);

      int *plist_hmatr_fin = phmatr_fin->GetListArr ();
      int *plist2_hmatr_fin = phmatr_fin->GetList2Arr ();
      int *pia_hmatr_fin = phmatr_fin->GetIaArr ();
      int *pja_hmatr_fin = phmatr_fin->GetJaArr ();
      int *pja2_hmatr_fin = phmatr_fin->GetJa2Arr ();

      for (i = 0; i < _nblksR_fin; i++)
         plist_hmatr_fin[i] = i;
      for (i = 0; i < _nblksR_fin; i++)
         plist2_hmatr_fin[i] = 0;
      for (i = 0; i < nzja_tot; i++)
         pja2_hmatr_fin[i] = 0;

      nzja_tot = 0;
      pia_hmatr_fin[0] = 0;

      for (i = 0; i < _nblksR_fin; i++) {
         int nzblk_temp = phblkrows_new[i].GetNzblk ();
         CMatrix < int, float >*phmatr_temp = phblkrows_new[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub_temp = phblkrows_new[i].GetASubArr ();
         int *pja_temp = phmatr_temp->GetJaArr ();
         int j;
         for (j = 0; j < nzblk_temp; j++) {
            pja_hmatr_fin[nzja_tot] = pja_temp[j];
            pA_sub_fin[nzja_tot].ReplaceFree (pA_sub_temp[j]);
            nzja_tot++;
         }
         pia_hmatr_fin[i + 1] = nzja_tot;
      }

   }

// Compute reordered hmatrix rows
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ReorderHMatrixRows_BxB (int _blksize, int _nblksC, long long *_blksC,
                                      int _nblksR_ini, long long *_blksR_ini,
                                      CBMatrix < _Int, _Flt > &_hmatr_ini, int *_orderR,
                                      int _nblksR_fin, long long *_blksR_fin,
                                      CBMatrix < _Int, _Flt > &_hmatr_fin)
   {

// Open hmatr

      int b_2 = _blksize * _blksize;

      CMatrix < int, float >*phmatr = _hmatr_ini.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub = _hmatr_ini.GetASubArr ();

      int *pia_hmatr = phmatr->GetIaArr ();
      int *pja_hmatr = phmatr->GetJaArr ();

// Create arrays that describes block numbers for each index

      int mtot = (int) _blksR_ini[_nblksR_ini];

      CVectorData < int >ind2blkR_ini (mtot + 1);
      CVectorData < int >ind2blkR_fin (mtot + 1);

      int *pind2blkR_ini = ind2blkR_ini.Ptr ();
      int *pind2blkR_fin = ind2blkR_fin.Ptr ();

      int i;

      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksR_ini; ipar++) {
            for (int i = (int)_blksR_ini[ipar]; i < _blksR_ini[ipar + 1]; i++) {
               pind2blkR_ini[i] = ipar;
            }
         }
      }
      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksR_fin; ipar++) {
            for (int i = (int)_blksR_fin[ipar]; i < _blksR_fin[ipar + 1]; i++) {
               pind2blkR_fin[i] = ipar;
            }
         }
      }

      int nblks_max = _nblksR_ini;
      if (_nblksR_fin > nblks_max)
         nblks_max = _nblksR_fin;
      if (_nblksC > nblks_max)
         nblks_max = _nblksC;

// Compute inverse order

      CVectorData < int >iorderR (mtot + 1);

      int *piorderR = iorderR.Ptr ();

      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksR_ini; ipar++) {
            for (int i = (int)_blksR_ini[ipar]; i < _blksR_ini[ipar + 1]; i++) {
               piorderR[_orderR[i]] = i;
            }
         }
      }

// Create set of combined initial block rows

      vector < CMatrix < _Int, _Flt > >blkrows (_nblksR_ini + 1);
      CMatrix < _Int, _Flt > *pblkrows = &blkrows[0];

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      vector < int >icycle_thr (n_thr + 1);
      vector < CVectorData < int > >imaskblk_thr (n_thr + 1);

      int *picycle_thr = &icycle_thr[0];
      CVectorData < int >*pimaskblk_thr = &imaskblk_thr[0];

      for (i = 0; i < n_thr; i++)
         picycle_thr[i] = -1;

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksR_ini; ipar++) {

            int i, j, jj, k, kk, kkk, kj, jold;

            int nlist_curr = (int) (_blksR_ini[ipar + 1] - _blksR_ini[ipar]);
            int nzja_curr = 0;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               nzja_curr += pA_sub[j].GetNzja ();
            }
            CMatrix < _Int, _Flt > ASub;
            ASub.ResizeAndSetAll (nlist_curr, 0, nzja_curr, nzja_curr, nzja_curr * b_2);
            _Int *pia_curr = ASub.GetIaArr ();
            _Int *pja_curr = ASub.GetJaArr ();
            _Int *pja2_curr = ASub.GetJa2Arr ();
            _Flt *pa_curr = ASub.GetAArr ();
            for (i = 0; i <= nlist_curr; i++)
               pia_curr[i] = 0;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               int nlist_temp = pA_sub[j].GetNlist ();
               _Int *plist_temp = pA_sub[j].GetListArr ();
               _Int *pia_temp = pA_sub[j].GetIaArr ();
               for (k = 0; k < nlist_temp; k++) {
                  kk = (int) plist_temp[k];
                  pia_curr[kk + 1] += (pia_temp[k + 1] - pia_temp[k]);
               }
            }
            for (i = 0; i < nlist_curr; i++)
               pia_curr[i + 1] = pia_curr[i] + pia_curr[i + 1];
            vector < int >iptr (nlist_curr + 1);
            int *piptr = &iptr[0];
            for (i = 0; i < nlist_curr; i++)
               piptr[i] = (int) pia_curr[i];
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               int nlist_temp = pA_sub[j].GetNlist ();
               _Int *plist_temp = pA_sub[j].GetListArr ();
               _Int *pia_temp = pA_sub[j].GetIaArr ();
               _Int *pja_temp = pA_sub[j].GetJaArr ();
               _Flt *pa_temp = pA_sub[j].GetAArr ();
               for (k = 0; k < nlist_temp; k++) {
                  kk = (int) plist_temp[k];
                  kkk = piptr[kk];
                  for (kj = (int) pia_temp[k]; kj < pia_temp[k + 1]; kj++) {
                     jold = (int) (pja_temp[kj]);
                     pja_curr[kkk] = (_Int) (jold);
                     pja2_curr[kkk] = (_Int) jj;
                     CVector < _Flt >::CopyVector (b_2, pa_temp + kj * b_2,
                                                   pa_curr + kkk * b_2);
                     kkk++;
                  }
                  piptr[kk] = kkk;
               }
            }
            pblkrows[ipar].ReplaceFree (ASub);
         }
      }

// Compute maximal size

      int nimax = 0;

      int niloc;

      for (i = 0; i < _nblksC; i++) {
         niloc = (int) (_blksC[i + 1] - _blksC[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

      for (i = 0; i < _nblksR_fin; i++) {
         niloc = (int) (_blksR_fin[i + 1] - _blksR_fin[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

// Create set of new block rows

      vector < CBMatrix < _Int, _Flt > >hblkrows_new (_nblksR_fin + 1);
      CBMatrix < _Int, _Flt > *phblkrows_new = &hblkrows_new[0];

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksR_fin; ipar++) {

            int my_thr = 0;
#ifdef USE_THREADS
            my_thr = omp_get_thread_num ();
#endif

            int i, j;

            if (picycle_thr[my_thr] == -1) {
               pimaskblk_thr[my_thr].resize (3 * nblks_max + 1);
               int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
               for (j = 0; j < nblks_max; j++)
                  pimaskblk[j] = -1;
            }
            int icycleblk = picycle_thr[my_thr];
            int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
            int *plistblk = pimaskblk + nblks_max;
            int *pindblk = plistblk + nblks_max;

// Compute sizes of data

            int nzja_curr = 0;

            int iold, iblkold;

            for (i = (int) _blksR_fin[ipar]; i < _blksR_fin[ipar + 1]; i++) {
               iold = piorderR[i];
               iblkold = pind2blkR_ini[iold];
               iold = (int) (iold - _blksR_ini[iblkold]);
               _Int *pia_temp = pblkrows[iblkold].GetIaArr ();
               nzja_curr += (int) (pia_temp[iold + 1] - pia_temp[iold]);
            }

            int nlist_curr = (int) (_blksR_fin[ipar + 1] - _blksR_fin[ipar]);

// Rewrite

            CMatrix < _Int, _Flt > ASub;
            ASub.ResizeAndSetAll (nlist_curr, 0, nzja_curr, nzja_curr, nzja_curr * b_2);

            _Int *pia_curr = ASub.GetIaArr ();
            _Int *pja_curr = ASub.GetJaArr ();
            _Int *pja2_curr = ASub.GetJa2Arr ();
            _Flt *pa_curr = ASub.GetAArr ();

            pia_curr[0] = 0;
            nzja_curr = 0;

            int ibeg = (int) _blksR_fin[ipar];

            for (i = (int) _blksR_fin[ipar]; i < _blksR_fin[ipar + 1]; i++) {
               iold = piorderR[i];
               iblkold = pind2blkR_ini[iold];
               iold = (int) (iold - _blksR_ini[iblkold]);
               _Int *pia_temp = pblkrows[iblkold].GetIaArr ();
               _Int *pja_temp = pblkrows[iblkold].GetJaArr ();
               _Int *pja2_temp = pblkrows[iblkold].GetJa2Arr ();
               _Flt *pa_temp = pblkrows[iblkold].GetAArr ();
               for (j = (int) pia_temp[iold]; j < pia_temp[iold + 1]; j++) {
                  pja_curr[nzja_curr] = pja_temp[j];
                  pja2_curr[nzja_curr] = pja2_temp[j];
                  CVector < _Flt >::CopyVector (b_2, pa_temp + j * b_2,
                                                pa_curr + nzja_curr * b_2);
                  nzja_curr++;
               }
               pia_curr[i - ibeg + 1] = nzja_curr;
            }

// Split into the set of blocks

            icycleblk++;

            int nlistblk = 0;

            int jblk;

            for (i = 0; i < nzja_curr; i++) {
               jblk = (int) pja2_curr[i];
               if (pimaskblk[jblk] != icycleblk) {
                  plistblk[nlistblk] = jblk;
                  nlistblk++;
                  pimaskblk[jblk] = icycleblk;
               }
            }

            if (nlistblk == 0) {
               plistblk[0] = ipar;
               nlistblk = 1;
            }

            sort (plistblk, plistblk + nlistblk);

            for (i = 0; i < nlistblk; i++) {
               jblk = plistblk[i];
               pindblk[jblk] = i;
            }

            vector < int >nzblk_arr (nlistblk + 1);
            int *pnzblk_arr = &nzblk_arr[0];

            for (i = 0; i < nlistblk; i++)
               pnzblk_arr[i] = 0;

            int ind;

            for (i = 0; i < nzja_curr; i++) {
               jblk = (int) pja2_curr[i];
               ind = pindblk[jblk];
               pnzblk_arr[ind]++;
            }

            vector < vector < _Int > >rows_arr (nlistblk + 1);
            vector < vector < _Int > >cols_arr (nlistblk + 1);
            vector < vector < _Flt > >elems_arr (nlistblk + 1);

            vector < _Int > *prows_arr = &rows_arr[0];
            vector < _Int > *pcols_arr = &cols_arr[0];
            vector < _Flt > *pelems_arr = &elems_arr[0];

            for (i = 0; i < nlistblk; i++) {
               prows_arr[i].resize (pnzblk_arr[i] + 1);
               pcols_arr[i].resize (pnzblk_arr[i] + 1);
               pelems_arr[i].resize (pnzblk_arr[i] * b_2 + 1);
            }

            for (i = 0; i < nlistblk; i++)
               pnzblk_arr[i] = 0;

            int jj, jj2, k;

            for (i = 0; i < nlist_curr; i++) {
               for (j = (int) pia_curr[i]; j < pia_curr[i + 1]; j++) {
                  jj = (int) pja_curr[j];
                  jj2 = (int) pja2_curr[j];
                  ind = pindblk[jj2];
                  k = pnzblk_arr[ind];
                  _Int *pprows_arr = &prows_arr[ind][0];
                  _Int *ppcols_arr = &pcols_arr[ind][0];
                  _Flt *ppelems_arr = &pelems_arr[ind][0];
                  pprows_arr[k] = i;
                  ppcols_arr[k] = jj;
                  CVector < _Flt >::CopyVector (b_2, pa_curr + j * b_2,
                                                ppelems_arr + k * b_2);
                  pnzblk_arr[ind]++;
               }
            }

// Compute hblock

            phblkrows_new[ipar].SetNzblk (nlistblk);
            phblkrows_new[ipar].ResizeASub (nlistblk);

            CMatrix < int, float >*phmatr_new = phblkrows_new[ipar].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub_new = phblkrows_new[ipar].GetASubArr ();

            phmatr_new->SetNzja (nlistblk);
            phmatr_new->ResizeJa (nlistblk);

            int *pja_hmatr_new = phmatr_new->GetJaArr ();

            for (i = 0; i < nlistblk; i++)
               pja_hmatr_new[i] = plistblk[i];

            CVectorData < CSortInt > iiarr (nimax + 1);
            CVectorData < _Flt > elemsarr (nimax * b_2 + 1);

            vector < int >imaskarr (nlist_curr + 1);
            vector < int >listarr (nlist_curr + 1);
            vector < int >indarr (nlist_curr + 1);

            CSortInt *piiarr = iiarr.Ptr ();
            _Flt *pelemsarr = elemsarr.Ptr ();

            int *pimaskarr = &imaskarr[0];
            int *plistarr = &listarr[0];
            int *pindarr = &indarr[0];

            for (i = 0; i < nlist_curr; i++)
               pimaskarr[i] = -1;

            int icycle = -1;
            int niloc;

            for (i = 0; i < nlistblk; i++) {
               icycle++;
               int nzja_temp = pnzblk_arr[i];
               _Int *pprows_arr = &prows_arr[i][0];
               _Int *ppcols_arr = &pcols_arr[i][0];
               _Flt *ppelems_arr = &pelems_arr[i][0];
               int nlist_temp = 0;
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  if (pimaskarr[jj] != icycle) {
                     plistarr[nlist_temp] = jj;
                     nlist_temp++;
                     pimaskarr[jj] = icycle;
                  }
               }
               sort (plistarr, plistarr + nlist_temp);
               for (j = 0; j < nlist_temp; j++) {
                  jj = plistarr[j];
                  pindarr[jj] = j;
               }
               pA_sub_new[i].ResizeAndSetAll (nlist_temp, 0, nzja_temp, 0,
                                              nzja_temp * b_2);
               _Int *plist_temp = pA_sub_new[i].GetListArr ();
               _Int *pia_temp = pA_sub_new[i].GetIaArr ();
               _Int *pja_temp = pA_sub_new[i].GetJaArr ();
               _Flt *pa_temp = pA_sub_new[i].GetAArr ();
               for (j = 0; j < nlist_temp; j++)
                  plist_temp[j] = plistarr[j];
               for (j = 0; j <= nlist_temp; j++)
                  pia_temp[j] = 0;
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  ind = pindarr[jj];
                  pia_temp[ind + 1]++;
               }
               for (j = 0; j < nlist_temp; j++)
                  pia_temp[j + 1] = pia_temp[j] + pia_temp[j + 1];
               for (j = 0; j < nlist_temp; j++)
                  plistarr[j] = (int) pia_temp[j];
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  ind = pindarr[jj];
                  k = plistarr[ind];
                  pja_temp[k] = ppcols_arr[j];
                  CVector < _Flt >::CopyVector (b_2, ppelems_arr + j * b_2,
                                                pa_temp + k * b_2);
                  plistarr[ind]++;
               }
               for (j = 0; j < nlist_temp; j++) {
                  ibeg = (int) pia_temp[j];
                  niloc = (int) (pia_temp[j + 1] - pia_temp[j]);
                  for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                     piiarr[k - ibeg].ival = (int) pja_temp[k];
                     piiarr[k - ibeg].i2val = k;
                     CVector < _Flt >::CopyVector (b_2, pa_temp + k * b_2,
                                                   pelemsarr + (k - ibeg) * b_2);
                  }
                  sort (piiarr, piiarr + niloc);
                  for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                     pja_temp[k] = (_Int) piiarr[k - ibeg].ival;
                     ind = piiarr[k - ibeg].i2val;
                     CVector < _Flt >::CopyVector (b_2, pelemsarr + (ind - ibeg) * b_2,
                                                   pa_temp + k * b_2);
                  }
               }
            }

            picycle_thr[my_thr] = icycleblk;

         }

      }

// Combine computed data into one hmatrix

      int nzja_tot = 0;

      for (i = 0; i < _nblksR_fin; i++) {
         nzja_tot += phblkrows_new[i].GetNzblk ();
      }

      _hmatr_fin.SetNzblk (nzja_tot);
      _hmatr_fin.ResizeASub (nzja_tot);

      CMatrix < int, float >*phmatr_fin = _hmatr_fin.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub_fin = _hmatr_fin.GetASubArr ();

      phmatr_fin->ResizeAndSetAllSp (_nblksR_fin, _nblksR_fin, nzja_tot, nzja_tot);

      int *plist_hmatr_fin = phmatr_fin->GetListArr ();
      int *plist2_hmatr_fin = phmatr_fin->GetList2Arr ();
      int *pia_hmatr_fin = phmatr_fin->GetIaArr ();
      int *pja_hmatr_fin = phmatr_fin->GetJaArr ();
      int *pja2_hmatr_fin = phmatr_fin->GetJa2Arr ();

      for (i = 0; i < _nblksR_fin; i++)
         plist_hmatr_fin[i] = i;
      for (i = 0; i < _nblksR_fin; i++)
         plist2_hmatr_fin[i] = 0;
      for (i = 0; i < nzja_tot; i++)
         pja2_hmatr_fin[i] = 0;

      nzja_tot = 0;
      pia_hmatr_fin[0] = 0;

      for (i = 0; i < _nblksR_fin; i++) {
         int nzblk_temp = phblkrows_new[i].GetNzblk ();
         CMatrix < int, float >*phmatr_temp = phblkrows_new[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub_temp = phblkrows_new[i].GetASubArr ();
         int *pja_temp = phmatr_temp->GetJaArr ();
         int j;
         for (j = 0; j < nzblk_temp; j++) {
            pja_hmatr_fin[nzja_tot] = pja_temp[j];
            pA_sub_fin[nzja_tot].ReplaceFree (pA_sub_temp[j]);
            nzja_tot++;
         }
         pia_hmatr_fin[i + 1] = nzja_tot;
      }

   }

// Compute reordered hmatrix cols
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ReorderHMatrixCols (int _nblksR, long long *_blksR, int _nblksC_ini,
                                  long long *_blksC_ini, CBMatrix < _Int,
                                  _Flt > &_hmatr_ini, int *_orderC, int _nblksC_fin,
                                  long long *_blksC_fin, CBMatrix < _Int,
                                  _Flt > &_hmatr_fin)
   {

// Open hmatr

      CMatrix < int, float >*phmatr = _hmatr_ini.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub = _hmatr_ini.GetASubArr ();

      int *pia_hmatr = phmatr->GetIaArr ();
      int *pja_hmatr = phmatr->GetJaArr ();

// Create arrays that describes block numbers for each index

      int ntot = (int) _blksC_ini[_nblksC_ini];

      CVectorData < int >ind2blkC_ini (ntot + 1);
      CVectorData < int >ind2blkC_fin (ntot + 1);

      int *pind2blkC_ini = ind2blkC_ini.Ptr ();
      int *pind2blkC_fin = ind2blkC_fin.Ptr ();

      int i;

      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksC_ini; ipar++) {
            for (int i = (int)_blksC_ini[ipar]; i < _blksC_ini[ipar + 1]; i++) {
               pind2blkC_ini[i] = ipar;
            }
         }
      }
      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksC_fin; ipar++) {
            for (int i = (int)_blksC_fin[ipar]; i < _blksC_fin[ipar + 1]; i++) {
               pind2blkC_fin[i] = ipar;
            }
         }
      }

// Compute inverse order

      CVectorData < int >iorderC (ntot + 1);

      int *piorderC = iorderC.Ptr ();

      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksC_ini; ipar++) {
            for (int i = (int)_blksC_ini[ipar]; i < _blksC_ini[ipar + 1]; i++) {
               piorderC[_orderC[i]] = i;
            }
         }
      }

// Compute maximal size

      int nimax = 0;

      int niloc;

      for (i = 0; i < _nblksC_fin; i++) {
         niloc = (int) (_blksC_fin[i + 1] - _blksC_fin[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

// Create set of combined initial block rows

      vector < CBMatrix < _Int, _Flt > >hblkrows_new (_nblksR + 1);
      CBMatrix < _Int, _Flt > *phblkrows_new = &hblkrows_new[0];

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      vector < int >icycle_thr (n_thr + 1);
      vector < CVectorData < int > >imaskblk_thr (n_thr + 1);

      int *picycle_thr = &icycle_thr[0];
      CVectorData < int >*pimaskblk_thr = &imaskblk_thr[0];

      for (i = 0; i < n_thr; i++)
         picycle_thr[i] = -1;

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksR; ipar++) {

            int my_thr = 0;
#ifdef USE_THREADS
            my_thr = omp_get_thread_num ();
#endif

            int i, j;

            if (picycle_thr[my_thr] == -1) {
               pimaskblk_thr[my_thr].resize (3 * _nblksC_fin + 1);
               int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
               for (j = 0; j < _nblksC_fin; j++)
                  pimaskblk[j] = -1;
            }
            int icycleblk = picycle_thr[my_thr];
            int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
            int *plistblk = pimaskblk + _nblksC_fin;
            int *pindblk = plistblk + _nblksC_fin;

            int jj, k, kk, kkk, kj, jold, jnew, jblknew;

            int nlist_curr = (int) (_blksR[ipar + 1] - _blksR[ipar]);
            int nzja_curr = 0;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               nzja_curr += pA_sub[j].GetNzja ();
            }
            CMatrix < _Int, _Flt > ASub;
            ASub.ResizeAndSetAll (nlist_curr, 0, nzja_curr, nzja_curr, nzja_curr);
            _Int *pia_curr = ASub.GetIaArr ();
            _Int *pja_curr = ASub.GetJaArr ();
            _Int *pja2_curr = ASub.GetJa2Arr ();
            _Flt *pa_curr = ASub.GetAArr ();
            for (i = 0; i <= nlist_curr; i++)
               pia_curr[i] = 0;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               int nlist_temp = pA_sub[j].GetNlist ();
               _Int *plist_temp = pA_sub[j].GetListArr ();
               _Int *pia_temp = pA_sub[j].GetIaArr ();
               for (k = 0; k < nlist_temp; k++) {
                  kk = (int) plist_temp[k];
                  pia_curr[kk + 1] += (pia_temp[k + 1] - pia_temp[k]);
               }
            }
            for (i = 0; i < nlist_curr; i++)
               pia_curr[i + 1] = pia_curr[i] + pia_curr[i + 1];
            vector < int >iptr (nlist_curr + 1);
            int *piptr = &iptr[0];
            for (i = 0; i < nlist_curr; i++)
               piptr[i] = (int) pia_curr[i];
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               int nlist_temp = pA_sub[j].GetNlist ();
               _Int *plist_temp = pA_sub[j].GetListArr ();
               _Int *pia_temp = pA_sub[j].GetIaArr ();
               _Int *pja_temp = pA_sub[j].GetJaArr ();
               _Flt *pa_temp = pA_sub[j].GetAArr ();
               for (k = 0; k < nlist_temp; k++) {
                  kk = (int) plist_temp[k];
                  kkk = piptr[kk];
                  for (kj = (int) pia_temp[k]; kj < pia_temp[k + 1]; kj++) {
                     jold = (int) (pja_temp[kj] + _blksC_ini[jj]);
                     jnew = _orderC[jold];
                     jblknew = pind2blkC_fin[jnew];
                     pja_curr[kkk] = (_Int) (jnew - _blksC_fin[jblknew]);
                     pja2_curr[kkk] = (_Int) jblknew;
                     pa_curr[kkk] = pa_temp[kj];
                     kkk++;
                  }
                  piptr[kk] = kkk;
               }
            }

// Split into the set of blocks

            icycleblk++;

            int nlistblk = 0;

            int jblk;

            for (i = 0; i < nzja_curr; i++) {
               jblk = (int) pja2_curr[i];
               if (pimaskblk[jblk] != icycleblk) {
                  plistblk[nlistblk] = jblk;
                  nlistblk++;
                  pimaskblk[jblk] = icycleblk;
               }
            }

            if (nlistblk == 0) {
               plistblk[0] = ipar;
               nlistblk = 1;
            }

            sort (plistblk, plistblk + nlistblk);

            for (i = 0; i < nlistblk; i++) {
               jblk = plistblk[i];
               pindblk[jblk] = i;
            }

            vector < int >nzblk_arr (nlistblk + 1);
            int *pnzblk_arr = &nzblk_arr[0];

            for (i = 0; i < nlistblk; i++)
               pnzblk_arr[i] = 0;

            int ind;

            for (i = 0; i < nzja_curr; i++) {
               jblk = (int) pja2_curr[i];
               ind = pindblk[jblk];
               pnzblk_arr[ind]++;
            }

            vector < vector < _Int > >rows_arr (nlistblk + 1);
            vector < vector < _Int > >cols_arr (nlistblk + 1);
            vector < vector < _Flt > >elems_arr (nlistblk + 1);

            vector < _Int > *prows_arr = &rows_arr[0];
            vector < _Int > *pcols_arr = &cols_arr[0];
            vector < _Flt > *pelems_arr = &elems_arr[0];

            for (i = 0; i < nlistblk; i++) {
               prows_arr[i].resize (pnzblk_arr[i] + 1);
               pcols_arr[i].resize (pnzblk_arr[i] + 1);
               pelems_arr[i].resize (pnzblk_arr[i] + 1);
            }

            for (i = 0; i < nlistblk; i++)
               pnzblk_arr[i] = 0;

            int jj2;

            for (i = 0; i < nlist_curr; i++) {
               for (j = (int) pia_curr[i]; j < pia_curr[i + 1]; j++) {
                  jj = (int) pja_curr[j];
                  jj2 = (int) pja2_curr[j];
                  ind = pindblk[jj2];
                  k = pnzblk_arr[ind];
                  _Int *pprows_arr = &prows_arr[ind][0];
                  _Int *ppcols_arr = &pcols_arr[ind][0];
                  _Flt *ppelems_arr = &pelems_arr[ind][0];
                  pprows_arr[k] = i;
                  ppcols_arr[k] = jj;
                  ppelems_arr[k] = pa_curr[j];
                  pnzblk_arr[ind]++;
               }
            }

// Compute hblock

            phblkrows_new[ipar].SetNzblk (nlistblk);
            phblkrows_new[ipar].ResizeASub (nlistblk);

            CMatrix < int, float >*phmatr_new = phblkrows_new[ipar].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub_new = phblkrows_new[ipar].GetASubArr ();

            phmatr_new->SetNzja (nlistblk);
            phmatr_new->ResizeJa (nlistblk);

            int *pja_hmatr_new = phmatr_new->GetJaArr ();

            for (i = 0; i < nlistblk; i++)
               pja_hmatr_new[i] = plistblk[i];

            CVectorData < CSortInt > iiarr (nimax + 1);
            CVectorData < _Flt > elemsarr (nimax + 1);

            vector < int >imaskarr (nlist_curr + 1);
            vector < int >listarr (nlist_curr + 1);
            vector < int >indarr (nlist_curr + 1);

            CSortInt *piiarr = iiarr.Ptr ();
            _Flt *pelemsarr = elemsarr.Ptr ();

            int *pimaskarr = &imaskarr[0];
            int *plistarr = &listarr[0];
            int *pindarr = &indarr[0];

            for (i = 0; i < nlist_curr; i++)
               pimaskarr[i] = -1;

            int icycle = -1;
            int niloc;

            int ibeg;

            for (i = 0; i < nlistblk; i++) {
               icycle++;
               int nzja_temp = pnzblk_arr[i];
               _Int *pprows_arr = &prows_arr[i][0];
               _Int *ppcols_arr = &pcols_arr[i][0];
               _Flt *ppelems_arr = &pelems_arr[i][0];
               int nlist_temp = 0;
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  if (pimaskarr[jj] != icycle) {
                     plistarr[nlist_temp] = jj;
                     nlist_temp++;
                     pimaskarr[jj] = icycle;
                  }
               }
               sort (plistarr, plistarr + nlist_temp);
               for (j = 0; j < nlist_temp; j++) {
                  jj = plistarr[j];
                  pindarr[jj] = j;
               }
               pA_sub_new[i].ResizeAndSetAll (nlist_temp, 0, nzja_temp, 0, nzja_temp);
               _Int *plist_temp = pA_sub_new[i].GetListArr ();
               _Int *pia_temp = pA_sub_new[i].GetIaArr ();
               _Int *pja_temp = pA_sub_new[i].GetJaArr ();
               _Flt *pa_temp = pA_sub_new[i].GetAArr ();
               for (j = 0; j < nlist_temp; j++)
                  plist_temp[j] = plistarr[j];
               for (j = 0; j <= nlist_temp; j++)
                  pia_temp[j] = 0;
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  ind = pindarr[jj];
                  pia_temp[ind + 1]++;
               }
               for (j = 0; j < nlist_temp; j++)
                  pia_temp[j + 1] = pia_temp[j] + pia_temp[j + 1];
               for (j = 0; j < nlist_temp; j++)
                  plistarr[j] = (int) pia_temp[j];
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  ind = pindarr[jj];
                  k = plistarr[ind];
                  pja_temp[k] = ppcols_arr[j];
                  pa_temp[k] = ppelems_arr[j];
                  plistarr[ind]++;
               }
               for (j = 0; j < nlist_temp; j++) {
                  ibeg = (int) pia_temp[j];
                  niloc = (int) (pia_temp[j + 1] - pia_temp[j]);
                  for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                     piiarr[k - ibeg].ival = (int) pja_temp[k];
                     piiarr[k - ibeg].i2val = k;
                     pelemsarr[k - ibeg] = pa_temp[k];
                  }
                  sort (piiarr, piiarr + niloc);
                  for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                     pja_temp[k] = (_Int) piiarr[k - ibeg].ival;
                     ind = piiarr[k - ibeg].i2val;
                     pa_temp[k] = pelemsarr[ind - ibeg];
                  }
               }
            }

            picycle_thr[my_thr] = icycleblk;

         }

      }

// Combine computed data into one hmatrix

      int nzja_tot = 0;

      for (i = 0; i < _nblksR; i++) {
         nzja_tot += phblkrows_new[i].GetNzblk ();
      }

      _hmatr_fin.SetNzblk (nzja_tot);
      _hmatr_fin.ResizeASub (nzja_tot);

      CMatrix < int, float >*phmatr_fin = _hmatr_fin.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub_fin = _hmatr_fin.GetASubArr ();

      phmatr_fin->ResizeAndSetAllSp (_nblksR, _nblksR, nzja_tot, nzja_tot);

      int *plist_hmatr_fin = phmatr_fin->GetListArr ();
      int *plist2_hmatr_fin = phmatr_fin->GetList2Arr ();
      int *pia_hmatr_fin = phmatr_fin->GetIaArr ();
      int *pja_hmatr_fin = phmatr_fin->GetJaArr ();
      int *pja2_hmatr_fin = phmatr_fin->GetJa2Arr ();

      for (i = 0; i < _nblksR; i++)
         plist_hmatr_fin[i] = i;
      for (i = 0; i < _nblksR; i++)
         plist2_hmatr_fin[i] = 0;
      for (i = 0; i < nzja_tot; i++)
         pja2_hmatr_fin[i] = 0;

      nzja_tot = 0;
      pia_hmatr_fin[0] = 0;

      for (i = 0; i < _nblksR; i++) {
         int nzblk_temp = phblkrows_new[i].GetNzblk ();
         CMatrix < int, float >*phmatr_temp = phblkrows_new[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub_temp = phblkrows_new[i].GetASubArr ();
         int *pja_temp = phmatr_temp->GetJaArr ();
         int j;
         for (j = 0; j < nzblk_temp; j++) {
            pja_hmatr_fin[nzja_tot] = pja_temp[j];
            pA_sub_fin[nzja_tot].ReplaceFree (pA_sub_temp[j]);
            nzja_tot++;
         }
         pia_hmatr_fin[i + 1] = nzja_tot;
      }

   }

// Compute reordered hmatrix cols
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ReorderHMatrixCols_BxB (int _blksize, int _nblksR, long long *_blksR,
                                      int _nblksC_ini, long long *_blksC_ini,
                                      CBMatrix < _Int, _Flt > &_hmatr_ini, int *_orderC,
                                      int _nblksC_fin, long long *_blksC_fin,
                                      CBMatrix < _Int, _Flt > &_hmatr_fin)
   {

      int b_2 = _blksize * _blksize;

// Open hmatr

      CMatrix < int, float >*phmatr = _hmatr_ini.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub = _hmatr_ini.GetASubArr ();

      int *pia_hmatr = phmatr->GetIaArr ();
      int *pja_hmatr = phmatr->GetJaArr ();

// Create arrays that describes block numbers for each index

      int ntot = (int) _blksC_ini[_nblksC_ini];

      CVectorData < int >ind2blkC_ini (ntot + 1);
      CVectorData < int >ind2blkC_fin (ntot + 1);

      int *pind2blkC_ini = ind2blkC_ini.Ptr ();
      int *pind2blkC_fin = ind2blkC_fin.Ptr ();

      int i;

      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksC_ini; ipar++) {
            for (int i = (int)_blksC_ini[ipar]; i < _blksC_ini[ipar + 1]; i++) {
               pind2blkC_ini[i] = ipar;
            }
         }
      }
      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksC_fin; ipar++) {
            for (int i = (int)_blksC_fin[ipar]; i < _blksC_fin[ipar + 1]; i++) {
               pind2blkC_fin[i] = ipar;
            }
         }
      }

// Compute inverse order

      CVectorData < int >iorderC (ntot + 1);

      int *piorderC = iorderC.Ptr ();

      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksC_ini; ipar++) {
            for (int i = (int)_blksC_ini[ipar]; i < _blksC_ini[ipar + 1]; i++) {
               piorderC[_orderC[i]] = i;
            }
         }
      }

// Compute maximal size

      int nimax = 0;

      int niloc;

      for (i = 0; i < _nblksC_fin; i++) {
         niloc = (int) (_blksC_fin[i + 1] - _blksC_fin[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

// Create set of combined initial block rows

      vector < CBMatrix < _Int, _Flt > >hblkrows_new (_nblksR + 1);
      CBMatrix < _Int, _Flt > *phblkrows_new = &hblkrows_new[0];

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      vector < int >icycle_thr (n_thr + 1);
      vector < CVectorData < int > >imaskblk_thr (n_thr + 1);

      int *picycle_thr = &icycle_thr[0];
      CVectorData < int >*pimaskblk_thr = &imaskblk_thr[0];

      for (i = 0; i < n_thr; i++)
         picycle_thr[i] = -1;

      {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblksR; ipar++) {

            int my_thr = 0;
#ifdef USE_THREADS
            my_thr = omp_get_thread_num ();
#endif

            int i, j;

            if (picycle_thr[my_thr] == -1) {
               pimaskblk_thr[my_thr].resize (3 * _nblksC_fin + 1);
               int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
               for (j = 0; j < _nblksC_fin; j++)
                  pimaskblk[j] = -1;
            }
            int icycleblk = picycle_thr[my_thr];
            int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
            int *plistblk = pimaskblk + _nblksC_fin;
            int *pindblk = plistblk + _nblksC_fin;

            int jj, k, kk, kkk, kj, jold, jnew, jblknew;

            int nlist_curr = (int) (_blksR[ipar + 1] - _blksR[ipar]);
            int nzja_curr = 0;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               nzja_curr += pA_sub[j].GetNzja ();
            }
            CMatrix < _Int, _Flt > ASub;
            ASub.ResizeAndSetAll (nlist_curr, 0, nzja_curr, nzja_curr, nzja_curr * b_2);
            _Int *pia_curr = ASub.GetIaArr ();
            _Int *pja_curr = ASub.GetJaArr ();
            _Int *pja2_curr = ASub.GetJa2Arr ();
            _Flt *pa_curr = ASub.GetAArr ();
            for (i = 0; i <= nlist_curr; i++)
               pia_curr[i] = 0;
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               int nlist_temp = pA_sub[j].GetNlist ();
               _Int *plist_temp = pA_sub[j].GetListArr ();
               _Int *pia_temp = pA_sub[j].GetIaArr ();
               for (k = 0; k < nlist_temp; k++) {
                  kk = (int) plist_temp[k];
                  pia_curr[kk + 1] += (pia_temp[k + 1] - pia_temp[k]);
               }
            }
            for (i = 0; i < nlist_curr; i++)
               pia_curr[i + 1] = pia_curr[i] + pia_curr[i + 1];
            vector < int >iptr (nlist_curr + 1);
            int *piptr = &iptr[0];
            for (i = 0; i < nlist_curr; i++)
               piptr[i] = (int) pia_curr[i];
            for (j = pia_hmatr[ipar]; j < pia_hmatr[ipar + 1]; j++) {
               jj = pja_hmatr[j];
               int nlist_temp = pA_sub[j].GetNlist ();
               _Int *plist_temp = pA_sub[j].GetListArr ();
               _Int *pia_temp = pA_sub[j].GetIaArr ();
               _Int *pja_temp = pA_sub[j].GetJaArr ();
               _Flt *pa_temp = pA_sub[j].GetAArr ();
               for (k = 0; k < nlist_temp; k++) {
                  kk = (int) plist_temp[k];
                  kkk = piptr[kk];
                  for (kj = (int) pia_temp[k]; kj < pia_temp[k + 1]; kj++) {
                     jold = (int) (pja_temp[kj] + _blksC_ini[jj]);
                     jnew = _orderC[jold];
                     jblknew = pind2blkC_fin[jnew];
                     pja_curr[kkk] = (_Int) (jnew - _blksC_fin[jblknew]);
                     pja2_curr[kkk] = (_Int) jblknew;
                     CVector < _Flt >::CopyVector (b_2, pa_temp + kj * b_2,
                                                   pa_curr + kkk * b_2);
                     kkk++;
                  }
                  piptr[kk] = kkk;
               }
            }

// Split into the set of blocks

            icycleblk++;

            int nlistblk = 0;

            int jblk;

            for (i = 0; i < nzja_curr; i++) {
               jblk = (int) pja2_curr[i];
               if (pimaskblk[jblk] != icycleblk) {
                  plistblk[nlistblk] = jblk;
                  nlistblk++;
                  pimaskblk[jblk] = icycleblk;
               }
            }

            if (nlistblk == 0) {
               plistblk[0] = ipar;
               nlistblk = 1;
            }

            sort (plistblk, plistblk + nlistblk);

            for (i = 0; i < nlistblk; i++) {
               jblk = plistblk[i];
               pindblk[jblk] = i;
            }

            vector < int >nzblk_arr (nlistblk + 1);
            int *pnzblk_arr = &nzblk_arr[0];

            for (i = 0; i < nlistblk; i++)
               pnzblk_arr[i] = 0;

            int ind;

            for (i = 0; i < nzja_curr; i++) {
               jblk = (int) pja2_curr[i];
               ind = pindblk[jblk];
               pnzblk_arr[ind]++;
            }

            vector < vector < _Int > >rows_arr (nlistblk + 1);
            vector < vector < _Int > >cols_arr (nlistblk + 1);
            vector < vector < _Flt > >elems_arr (nlistblk + 1);

            vector < _Int > *prows_arr = &rows_arr[0];
            vector < _Int > *pcols_arr = &cols_arr[0];
            vector < _Flt > *pelems_arr = &elems_arr[0];

            for (i = 0; i < nlistblk; i++) {
               prows_arr[i].resize (pnzblk_arr[i] + 1);
               pcols_arr[i].resize (pnzblk_arr[i] + 1);
               pelems_arr[i].resize (pnzblk_arr[i] * b_2 + 1);
            }

            for (i = 0; i < nlistblk; i++)
               pnzblk_arr[i] = 0;

            int jj2;

            for (i = 0; i < nlist_curr; i++) {
               for (j = (int) pia_curr[i]; j < pia_curr[i + 1]; j++) {
                  jj = (int) pja_curr[j];
                  jj2 = (int) pja2_curr[j];
                  ind = pindblk[jj2];
                  k = pnzblk_arr[ind];
                  _Int *pprows_arr = &prows_arr[ind][0];
                  _Int *ppcols_arr = &pcols_arr[ind][0];
                  _Flt *ppelems_arr = &pelems_arr[ind][0];
                  pprows_arr[k] = i;
                  ppcols_arr[k] = jj;
                  CVector < _Flt >::CopyVector (b_2, pa_curr + j * b_2,
                                                ppelems_arr + k * b_2);
                  pnzblk_arr[ind]++;
               }
            }

// Compute hblock

            phblkrows_new[ipar].SetNzblk (nlistblk);
            phblkrows_new[ipar].ResizeASub (nlistblk);

            CMatrix < int, float >*phmatr_new = phblkrows_new[ipar].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub_new = phblkrows_new[ipar].GetASubArr ();

            phmatr_new->SetNzja (nlistblk);
            phmatr_new->ResizeJa (nlistblk);

            int *pja_hmatr_new = phmatr_new->GetJaArr ();

            for (i = 0; i < nlistblk; i++)
               pja_hmatr_new[i] = plistblk[i];

            CVectorData < CSortInt > iiarr (nimax + 1);
            CVectorData < _Flt > elemsarr (nimax * b_2 + 1);

            vector < int >imaskarr (nlist_curr + 1);
            vector < int >listarr (nlist_curr + 1);
            vector < int >indarr (nlist_curr + 1);

            CSortInt *piiarr = iiarr.Ptr ();
            _Flt *pelemsarr = elemsarr.Ptr ();

            int *pimaskarr = &imaskarr[0];
            int *plistarr = &listarr[0];
            int *pindarr = &indarr[0];

            for (i = 0; i < nlist_curr; i++)
               pimaskarr[i] = -1;

            int icycle = -1;
            int niloc;

            int ibeg;

            for (i = 0; i < nlistblk; i++) {
               icycle++;
               int nzja_temp = pnzblk_arr[i];
               _Int *pprows_arr = &prows_arr[i][0];
               _Int *ppcols_arr = &pcols_arr[i][0];
               _Flt *ppelems_arr = &pelems_arr[i][0];
               int nlist_temp = 0;
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  if (pimaskarr[jj] != icycle) {
                     plistarr[nlist_temp] = jj;
                     nlist_temp++;
                     pimaskarr[jj] = icycle;
                  }
               }
               sort (plistarr, plistarr + nlist_temp);
               for (j = 0; j < nlist_temp; j++) {
                  jj = plistarr[j];
                  pindarr[jj] = j;
               }
               pA_sub_new[i].ResizeAndSetAll (nlist_temp, 0, nzja_temp, 0,
                                              nzja_temp * b_2);
               _Int *plist_temp = pA_sub_new[i].GetListArr ();
               _Int *pia_temp = pA_sub_new[i].GetIaArr ();
               _Int *pja_temp = pA_sub_new[i].GetJaArr ();
               _Flt *pa_temp = pA_sub_new[i].GetAArr ();
               for (j = 0; j < nlist_temp; j++)
                  plist_temp[j] = plistarr[j];
               for (j = 0; j <= nlist_temp; j++)
                  pia_temp[j] = 0;
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  ind = pindarr[jj];
                  pia_temp[ind + 1]++;
               }
               for (j = 0; j < nlist_temp; j++)
                  pia_temp[j + 1] = pia_temp[j] + pia_temp[j + 1];
               for (j = 0; j < nlist_temp; j++)
                  plistarr[j] = (int) pia_temp[j];
               for (j = 0; j < nzja_temp; j++) {
                  jj = (int) pprows_arr[j];
                  ind = pindarr[jj];
                  k = plistarr[ind];
                  pja_temp[k] = ppcols_arr[j];
                  CVector < _Flt >::CopyVector (b_2, ppelems_arr + j * b_2,
                                                pa_temp + k * b_2);
                  plistarr[ind]++;
               }
               for (j = 0; j < nlist_temp; j++) {
                  ibeg = (int) pia_temp[j];
                  niloc = (int) (pia_temp[j + 1] - pia_temp[j]);
                  for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                     piiarr[k - ibeg].ival = (int) pja_temp[k];
                     piiarr[k - ibeg].i2val = k;
                     CVector < _Flt >::CopyVector (b_2, pa_temp + k * b_2,
                                                   pelemsarr + (k - ibeg) * b_2);
                  }
                  sort (piiarr, piiarr + niloc);
                  for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                     pja_temp[k] = (_Int) piiarr[k - ibeg].ival;
                     ind = piiarr[k - ibeg].i2val;
                     CVector < _Flt >::CopyVector (b_2, pelemsarr + (ind - ibeg) * b_2,
                                                   pa_temp + k * b_2);
                  }
               }
            }

            picycle_thr[my_thr] = icycleblk;

         }

      }

// Combine computed data into one hmatrix

      int nzja_tot = 0;

      for (i = 0; i < _nblksR; i++) {
         nzja_tot += phblkrows_new[i].GetNzblk ();
      }

      _hmatr_fin.SetNzblk (nzja_tot);
      _hmatr_fin.ResizeASub (nzja_tot);

      CMatrix < int, float >*phmatr_fin = _hmatr_fin.GetHMatrStr ();
      CMatrix < _Int, _Flt > *pA_sub_fin = _hmatr_fin.GetASubArr ();

      phmatr_fin->ResizeAndSetAllSp (_nblksR, _nblksR, nzja_tot, nzja_tot);

      int *plist_hmatr_fin = phmatr_fin->GetListArr ();
      int *plist2_hmatr_fin = phmatr_fin->GetList2Arr ();
      int *pia_hmatr_fin = phmatr_fin->GetIaArr ();
      int *pja_hmatr_fin = phmatr_fin->GetJaArr ();
      int *pja2_hmatr_fin = phmatr_fin->GetJa2Arr ();

      for (i = 0; i < _nblksR; i++)
         plist_hmatr_fin[i] = i;
      for (i = 0; i < _nblksR; i++)
         plist2_hmatr_fin[i] = 0;
      for (i = 0; i < nzja_tot; i++)
         pja2_hmatr_fin[i] = 0;

      nzja_tot = 0;
      pia_hmatr_fin[0] = 0;

      for (i = 0; i < _nblksR; i++) {
         int nzblk_temp = phblkrows_new[i].GetNzblk ();
         CMatrix < int, float >*phmatr_temp = phblkrows_new[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub_temp = phblkrows_new[i].GetASubArr ();
         int *pja_temp = phmatr_temp->GetJaArr ();
         int j;
         for (j = 0; j < nzblk_temp; j++) {
            pja_hmatr_fin[nzja_tot] = pja_temp[j];
            pA_sub_fin[nzja_tot].ReplaceFree (pA_sub_temp[j]);
            nzja_tot++;
         }
         pia_hmatr_fin[i + 1] = nzja_tot;
      }

   }

// Compute reordered hmatrix (orderings are local inside hblocks)
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ReorderHMatrixDiag (void *_comm, int _nhblks, int *_hblk2cpu,
                                  int *_hblk2blk_ini, int _nblks_ini,
                                  long long *_blks_ini, CBMatrix < _Int,
                                  _Flt > *_hmatr_arr_ini, CVectorData < int >*_order_diag,
                                  int *_hblk2blk_fin, int _nblks_fin,
                                  long long *_blks_fin, CBMatrix < _Int,
                                  _Flt > *_hmatr_arr_fin)
   {

      int myid = CMPIDataExchange::GetMyid (_comm);
      int nproc = CMPIDataExchange::GetNproc (_comm);

// Prepare send data

      vector < int >imaskcpu (nproc + 1);
      vector < int >listcpu (nproc + 1);

      int *pimaskcpu = &imaskcpu[0];
      int *plistcpu = &listcpu[0];

      int i;

      for (i = 0; i < nproc; i++)
         pimaskcpu[i] = -1;

      int j, jj2, jproc;

      int nlistcpu = 0;

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            CMatrix < int, float >*phmatr = _hmatr_arr_ini[i].GetHMatrStr ();
            int nzja_temp = phmatr->GetNzja ();
            int *pja2_temp = phmatr->GetJa2Arr ();
            for (j = 0; j < nzja_temp; j++) {
               jj2 = pja2_temp[j];
               jproc = _hblk2cpu[jj2];
               if (pimaskcpu[jproc] < 0) {
                  plistcpu[nlistcpu] = jproc;
                  nlistcpu++;
                  pimaskcpu[jproc] = 1;
               }
            }
         }
      }

      sort (plistcpu, plistcpu + nlistcpu);

      for (i = 0; i < nlistcpu; i++) {
         j = plistcpu[i];
         pimaskcpu[j] = i;
      }

      vector < int >nzblk_cpu (nlistcpu + 1);
      int *pnzblk_cpu = &nzblk_cpu[0];

      for (i = 0; i < nlistcpu; i++)
         pnzblk_cpu[i] = 0;

      int ind;

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            CMatrix < int, float >*phmatr = _hmatr_arr_ini[i].GetHMatrStr ();
            int nzja_temp = phmatr->GetNzja ();
            int *pja2_temp = phmatr->GetJa2Arr ();
            for (j = 0; j < nzja_temp; j++) {
               jj2 = pja2_temp[j];
               jproc = _hblk2cpu[jj2];
               ind = pimaskcpu[jproc];
               pnzblk_cpu[ind]++;
            }
         }
      }

      vector < vector < int > >blknum_arr (nlistcpu + 1);
      vector < vector < CMatrix < _Int, _Flt > > >blk_arr (nlistcpu + 1);

      vector < int >*pblknum_arr = &blknum_arr[0];
      vector < CMatrix < _Int, _Flt > >*pblk_arr = &blk_arr[0];

      for (i = 0; i < nlistcpu; i++) {
         pblknum_arr[i].resize (4 * pnzblk_cpu[i] + 1);
         pblk_arr[i].resize (pnzblk_cpu[i] + 1);
      }

      for (i = 0; i < nlistcpu; i++)
         pnzblk_cpu[i] = 0;

      int k, kkk, iblk, jj;

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            CMatrix < int, float >*phmatr = _hmatr_arr_ini[i].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr_ini[i].GetASubArr ();
            int nlist_temp = phmatr->GetNlist ();
            int *plist_temp = phmatr->GetListArr ();
            int *pia_temp = phmatr->GetIaArr ();
            int *pja_temp = phmatr->GetJaArr ();
            int *pja2_temp = phmatr->GetJa2Arr ();
            for (j = 0; j < nlist_temp; j++) {
               iblk = plist_temp[j];
               for (k = pia_temp[j]; k < pia_temp[j + 1]; k++) {
                  jj = pja_temp[k];
                  jj2 = pja2_temp[k];
                  jproc = _hblk2cpu[jj2];
                  ind = pimaskcpu[jproc];
                  int *ppblknum = &pblknum_arr[ind][0];
                  CMatrix < _Int, _Flt > *pA_sub_temp = &pblk_arr[ind][0];
                  kkk = pnzblk_cpu[ind];
                  pA_sub_temp[kkk].ReplaceFree (pA_sub[k]);
                  ppblknum[kkk * 4] = iblk;
                  ppblknum[kkk * 4 + 1] = i;
                  ppblknum[kkk * 4 + 2] = jj;
                  ppblknum[kkk * 4 + 3] = jj2;
                  pnzblk_cpu[ind]++;
               }
            }
         }
      }

// Fill block sparsity structures

      int nblks_max = _nblks_ini;
      if (_nblks_fin > nblks_max)
         nblks_max = _nblks_fin;

      vector < int >imaskblk (nblks_max + 1);
      vector < int >listblk (nblks_max + 1);
      vector < int >list2blk (nblks_max + 1);
      vector < int >indblk (nblks_max + 1);

      int *pimaskblk = &imaskblk[0];
      int *plistblk = &listblk[0];
      int *plist2blk = &list2blk[0];
      int *pindblk = &indblk[0];

      for (i = 0; i < nblks_max; i++)
         pimaskblk[i] = -1;

      int icycleblk = -1;

      vector < CBMatrix < _Int, _Flt > >hblks_send_temp (nlistcpu + 1);
      CBMatrix < _Int, _Flt > *phblks_send_temp = &hblks_send_temp[0];

      int nlistblk, ihblk, iblkgl, jblkgl;

      for (i = 0; i < nlistcpu; i++) {

         int *ppblknum = &pblknum_arr[i][0];
         CMatrix < _Int, _Flt > *ppblk_arr = &pblk_arr[i][0];

// Compute block sparsity

         icycleblk++;

         nlistblk = 0;

         for (j = 0; j < pnzblk_cpu[i]; j++) {
            iblk = ppblknum[j * 4];
            ihblk = ppblknum[j * 4 + 1];
            iblkgl = _hblk2blk_ini[ihblk] + iblk;
            if (pimaskblk[iblkgl] != icycleblk) {
               plistblk[nlistblk] = iblkgl;
               plist2blk[nlistblk] = ihblk;
               nlistblk++;
               pimaskblk[iblkgl] = icycleblk;
            }
         }

         vector < CSortInt > iiarr (nlistblk + 1);
         CSortInt *piiarr = &iiarr[0];

         for (j = 0; j < nlistblk; j++) {
            piiarr[j].ival = plistblk[j];
            piiarr[j].i2val = j;
         }

         sort (piiarr, piiarr + nlistblk);

         for (j = 0; j < nlistblk; j++) {
            plistblk[j] = piiarr[j].ival;
            ind = piiarr[j].i2val;
            pindblk[j] = plist2blk[ind];
         }

         for (j = 0; j < nlistblk; j++)
            plist2blk[j] = pindblk[j];

         for (j = 0; j < nlistblk; j++) {
            ind = plistblk[j];
            pindblk[ind] = j;
         }

         phblks_send_temp[i].SetNzblk (pnzblk_cpu[i]);
         phblks_send_temp[i].ResizeASub (pnzblk_cpu[i]);

         CMatrix < int, float >*phmatr_send = phblks_send_temp[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub_send = phblks_send_temp[i].GetASubArr ();

         phmatr_send->ResizeAndSetAllSp (nlistblk, nlistblk, pnzblk_cpu[i],
                                         pnzblk_cpu[i]);

         int *plist_send = phmatr_send->GetListArr ();
         int *plist2_send = phmatr_send->GetList2Arr ();
         int *pia_send = phmatr_send->GetIaArr ();
         int *pja_send = phmatr_send->GetJaArr ();
         int *pja2_send = phmatr_send->GetJa2Arr ();

         for (j = 0; j < nlistblk; j++) {
            jblkgl = plistblk[j];
            jj2 = plist2blk[j];
            plist_send[j] = jblkgl - _hblk2blk_ini[jj2];
            plist2_send[j] = jj2;
         }

         for (j = 0; j <= nlistblk; j++)
            pia_send[j] = 0;

         for (j = 0; j < pnzblk_cpu[i]; j++) {
            iblk = ppblknum[j * 4];
            ihblk = ppblknum[j * 4 + 1];
            iblkgl = _hblk2blk_ini[ihblk] + iblk;
            ind = pindblk[iblkgl];
            pia_send[ind + 1]++;
         }

         for (j = 0; j < nlistblk; j++)
            pia_send[j + 1] = pia_send[j] + pia_send[j + 1];

         vector < int >iptr (nlistblk + 1);
         int *piptr = &iptr[0];

         for (j = 0; j < nlistblk; j++)
            piptr[j] = pia_send[j];

         for (j = 0; j < pnzblk_cpu[i]; j++) {
            iblk = ppblknum[j * 4];
            ihblk = ppblknum[j * 4 + 1];
            iblkgl = _hblk2blk_ini[ihblk] + iblk;
            ind = pindblk[iblkgl];
            k = piptr[ind];
            pja_send[k] = ppblknum[j * 4 + 2];
            pja2_send[k] = ppblknum[j * 4 + 3];
            pA_sub_send[k].ReplaceFree (ppblk_arr[j]);
            piptr[ind]++;
         }

      }

// Free temp data

      {

         vector < vector < int > >blknum_arr_temp;
         vector < vector < CMatrix < _Int, _Flt > > >blk_arr_temp;

         blknum_arr.swap (blknum_arr_temp);
         blk_arr.swap (blk_arr_temp);

      }


// Send outer data to another CPU's

      CBMatrix < _Int, _Flt > hblk_send_own;

      vector < CBMatrix < _Int, _Flt > >hblks_send (nlistcpu + 1);
      CBMatrix < _Int, _Flt > *phblks_send = &hblks_send[0];

      int nlistcpu_new = 0;

      for (i = 0; i < nlistcpu; i++) {
         if (plistcpu[i] == myid) {
            hblk_send_own.ReplaceFree (phblks_send_temp[i]);
         } else {
            phblks_send[nlistcpu_new].ReplaceFree (phblks_send_temp[i]);
            plistcpu[nlistcpu_new] = plistcpu[i];
            nlistcpu_new++;
         }
      }

      nlistcpu = nlistcpu_new;

// Pack send data

      vector < int >CpuIDSend (nlistcpu);
      vector < vector < char > >ObjSend (nlistcpu);

      int *pCpuIDSend = NULL;
      vector < char >*pObjSend = NULL;

      if (nlistcpu > 0) {
         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];
      }

      long long isize;
      char *pobj;

      for (i = 0; i < nlistcpu; i++) {
         pCpuIDSend[i] = plistcpu[i];
         isize = phblks_send[i].GetPackedSize ();
         pObjSend[i].resize ((size_t) isize);
         pobj = &(pObjSend[i][0]);
         phblks_send[i].FillPacked_thr (isize, pobj);
         phblks_send[i].Clean ();
      }

// Exchange

      vector < int >CpuIDRecv;
      vector < vector < char > >ObjRecv;

      CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      int nrecv = (int) CpuIDRecv.size ();

      vector < char >*pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      vector < CBMatrix < _Int, _Flt > >hblk_recv (nrecv + 2);

      CBMatrix < _Int, _Flt > *phblk_recv = &hblk_recv[0];

      for (i = 0; i < nrecv; i++) {
         isize = (long long) pObjRecv[i].size ();
         pobj = &(pObjRecv[i][0]);
         phblk_recv[i].UnPack_thr (isize, pobj);
      }

      phblk_recv[nrecv].ReplaceFree (hblk_send_own);

      nrecv++;

// Free recv data

      {
         vector < int >CpuIDRecv_temp;
         vector < vector < char > >ObjRecv_temp;
         CpuIDRecv.swap (CpuIDRecv_temp);
         ObjRecv.swap (ObjRecv_temp);
      }

// Create sets of blocks for block columns

      vector < int >nzblk_col (_nhblks + 1);
      blknum_arr.resize (_nhblks + 1);
      blk_arr.resize (_nhblks + 1);

      int *pnzblk_col = &nzblk_col[0];
      pblknum_arr = &blknum_arr[0];
      pblk_arr = &blk_arr[0];

      for (i = 0; i < _nhblks; i++)
         pnzblk_col[i] = 0;

      for (i = 0; i < nrecv; i++) {
         CMatrix < int, float >*phmatr = phblk_recv[i].GetHMatrStr ();
         int nlist_temp = phmatr->GetNlist ();
         int *plist_temp = phmatr->GetListArr ();
         int *plist2_temp = phmatr->GetList2Arr ();
         int *pia_temp = phmatr->GetIaArr ();
         int *pja_temp = phmatr->GetJaArr ();
         int *pja2_temp = phmatr->GetJa2Arr ();
         for (j = 0; j < nlist_temp; j++) {
            iblk = plist_temp[j];
            ihblk = plist2_temp[j];
            for (k = pia_temp[j]; k < pia_temp[j + 1]; k++) {
               jj = pja_temp[k];
               jj2 = pja2_temp[k];
               pnzblk_col[jj2]++;
            }
         }
      }

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            pblknum_arr[i].resize (4 * pnzblk_col[i] + 1);
            pblk_arr[i].resize (pnzblk_col[i] + 1);
         }
      }

      for (i = 0; i < _nhblks; i++)
         pnzblk_col[i] = 0;

      for (i = 0; i < nrecv; i++) {
         CMatrix < int, float >*phmatr = phblk_recv[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub = phblk_recv[i].GetASubArr ();
         int nlist_temp = phmatr->GetNlist ();
         int *plist_temp = phmatr->GetListArr ();
         int *plist2_temp = phmatr->GetList2Arr ();
         int *pia_temp = phmatr->GetIaArr ();
         int *pja_temp = phmatr->GetJaArr ();
         int *pja2_temp = phmatr->GetJa2Arr ();
         for (j = 0; j < nlist_temp; j++) {
            iblk = plist_temp[j];
            ihblk = plist2_temp[j];
            for (k = pia_temp[j]; k < pia_temp[j + 1]; k++) {
               jj = pja_temp[k];
               jj2 = pja2_temp[k];
               int *ppblknum = &pblknum_arr[jj2][0];
               CMatrix < _Int, _Flt > *pA_sub_temp = &pblk_arr[jj2][0];
               kkk = pnzblk_col[jj2];
               pA_sub_temp[kkk].ReplaceFree (pA_sub[k]);
               ppblknum[kkk * 4] = iblk;
               ppblknum[kkk * 4 + 1] = ihblk;
               ppblknum[kkk * 4 + 2] = jj;
               ppblknum[kkk * 4 + 3] = jj2;
               pnzblk_col[jj2]++;
            }
         }
      }

// Combine all received data into the set of block columns

      vector < CBMatrix < _Int, _Flt > >hblk_cols (_nhblks + 1);
      CBMatrix < _Int, _Flt > *phblk_cols = &hblk_cols[0];

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {

            int *ppblknum = &pblknum_arr[i][0];
            CMatrix < _Int, _Flt > *ppblk_arr = &pblk_arr[i][0];

// Compute block sparsity

            icycleblk++;

            nlistblk = 0;

            for (j = 0; j < pnzblk_col[i]; j++) {
               iblk = ppblknum[j * 4];
               ihblk = ppblknum[j * 4 + 1];
               iblkgl = _hblk2blk_ini[ihblk] + iblk;
               if (pimaskblk[iblkgl] != icycleblk) {
                  plistblk[nlistblk] = iblkgl;
                  plist2blk[nlistblk] = ihblk;
                  nlistblk++;
                  pimaskblk[iblkgl] = icycleblk;
               }
            }

            vector < CSortInt > iiarr (nlistblk + 1);
            CSortInt *piiarr = &iiarr[0];

            for (j = 0; j < nlistblk; j++) {
               piiarr[j].ival = plistblk[j];
               piiarr[j].i2val = j;
            }

            sort (piiarr, piiarr + nlistblk);

            for (j = 0; j < nlistblk; j++) {
               plistblk[j] = piiarr[j].ival;
               ind = piiarr[j].i2val;
               pindblk[j] = plist2blk[ind];
            }

            for (j = 0; j < nlistblk; j++)
               plist2blk[j] = pindblk[j];

            for (j = 0; j < nlistblk; j++) {
               ind = plistblk[j];
               pindblk[ind] = j;
            }

            phblk_cols[i].SetNzblk (pnzblk_col[i]);
            phblk_cols[i].ResizeASub (pnzblk_col[i]);

            CMatrix < int, float >*phmatr_cols = phblk_cols[i].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub_cols = phblk_cols[i].GetASubArr ();

            phmatr_cols->ResizeAndSetAllSp (nlistblk, nlistblk, pnzblk_col[i],
                                            pnzblk_col[i]);

            int *plist_cols = phmatr_cols->GetListArr ();
            int *plist2_cols = phmatr_cols->GetList2Arr ();
            int *pia_cols = phmatr_cols->GetIaArr ();
            int *pja_cols = phmatr_cols->GetJaArr ();
            int *pja2_cols = phmatr_cols->GetJa2Arr ();

            for (j = 0; j < nlistblk; j++) {
               jblkgl = plistblk[j];
               jj2 = plist2blk[j];
               plist_cols[j] = jblkgl - _hblk2blk_ini[jj2];
               plist2_cols[j] = jj2;
            }

            for (j = 0; j <= nlistblk; j++)
               pia_cols[j] = 0;

            for (j = 0; j < pnzblk_col[i]; j++) {
               iblk = ppblknum[j * 4];
               ihblk = ppblknum[j * 4 + 1];
               iblkgl = _hblk2blk_ini[ihblk] + iblk;
               ind = pindblk[iblkgl];
               pia_cols[ind + 1]++;
            }

            for (j = 0; j < nlistblk; j++)
               pia_cols[j + 1] = pia_cols[j] + pia_cols[j + 1];

            vector < int >iptr (nlistblk + 1);
            int *piptr = &iptr[0];

            for (j = 0; j < nlistblk; j++)
               piptr[j] = pia_cols[j];

            for (j = 0; j < pnzblk_col[i]; j++) {
               iblk = ppblknum[j * 4];
               ihblk = ppblknum[j * 4 + 1];
               iblkgl = _hblk2blk_ini[ihblk] + iblk;
               ind = pindblk[iblkgl];
               k = piptr[ind];
               pja_cols[k] = ppblknum[j * 4 + 2];
               pja2_cols[k] = ppblknum[j * 4 + 3];
               pA_sub_cols[k].ReplaceFree (ppblk_arr[j]);
               piptr[ind]++;
            }
         }

      }

// Prepare mask data

      int nimax = 0;
      int niloc = 0;

      for (i = 0; i < _nblks_ini; i++) {
         niloc = (int) (_blks_ini[i + 1] - _blks_ini[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      vector < int >icycle_thr (n_thr + 1);
      vector < CVectorData < int > >imaskblk_thr (n_thr + 1);

      int *picycle_thr = &icycle_thr[0];
      CVectorData < int >*pimaskblk_thr = &imaskblk_thr[0];

      for (i = 0; i < n_thr; i++)
         picycle_thr[i] = -1;

// Perform columns ordering of own hblocks

      CVectorData < long long >blksR_cnd (nblks_max + 1);
      vector < CVectorData < int > >listindR (nblks_max + 1);
      CVectorData < long long >blksC_ini_cnd (nblks_max + 1);
      CVectorData < long long >blksC_fin_cnd (nblks_max + 1);

      long long *pblksR_cnd = blksR_cnd.Ptr ();
      CVectorData < int >*plistindR = &listindR[0];
      long long *pblksC_ini_cnd = blksC_ini_cnd.Ptr ();
      long long *pblksC_fin_cnd = blksC_fin_cnd.Ptr ();

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {

            CMatrix < int, float >*phmatr = phblk_cols[ihblk].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub = phblk_cols[ihblk].GetASubArr ();

            int nlist_hblk = phmatr->GetNlist ();
            int *pia_hblk = phmatr->GetIaArr ();

            for (j = 0; j <= nlist_hblk; j++)
               pblksR_cnd[j] = 0;

// Compute lists of work rows indices in all block rows

#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nlist_hblk; ipar++) {
               int my_thr = 0;
#ifdef USE_THREADS
               my_thr = omp_get_thread_num ();
#endif
               int i, j, jj, ind;

               if (picycle_thr[my_thr] == -1) {
                  pimaskblk_thr[my_thr].resize (3 * nimax + 1);
                  int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
                  for (j = 0; j < nimax; j++)
                     pimaskblk[j] = -1;
               }

               int icycleblk = picycle_thr[my_thr];
               int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
               int *plistblk = pimaskblk + nimax;
               int *pindblk = plistblk + nimax;

               icycleblk++;

               int nlistR_loc = 0;

               for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                  int nlistR_temp = pA_sub[i].GetNlist ();
                  _Int *plistR_temp = pA_sub[i].GetListArr ();
                  for (j = 0; j < nlistR_temp; j++) {
                     jj = (int) plistR_temp[j];
                     if (pimaskblk[jj] != icycleblk) {
                        plistblk[nlistR_loc] = jj;
                        nlistR_loc++;
                        pimaskblk[jj] = icycleblk;
                     }
                  }
               }

               sort (plistblk, plistblk + nlistR_loc);

               for (i = 0; i < nlistR_loc; i++) {
                  j = plistblk[i];
                  pindblk[j] = i;
               }

               pblksR_cnd[ipar + 1] = nlistR_loc;

               plistindR[ipar].resize (nlistR_loc);

               int *pplistindR = plistindR[ipar].Ptr ();

               for (i = 0; i < nlistR_loc; i++)
                  pplistindR[i] = plistblk[i];

               for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                  int nlistR_temp = pA_sub[i].GetNlist ();
                  _Int *plistR_temp = pA_sub[i].GetListArr ();
                  for (j = 0; j < nlistR_temp; j++) {
                     jj = (int) plistR_temp[j];
                     ind = pindblk[jj];
                     plistR_temp[j] = (_Int) ind;
                  }
               }

               picycle_thr[my_thr] = icycleblk;

            }

// Prepare blocks partitionings

            for (i = 0; i < nlist_hblk; i++)
               pblksR_cnd[i + 1] = pblksR_cnd[i] + pblksR_cnd[i + 1];

            int ibegblk_ini = _hblk2blk_ini[ihblk];
            int ibegblk_fin = _hblk2blk_fin[ihblk];

            int nblksC_ini_loc = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
            int nblksC_fin_loc = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];

            for (i = ibegblk_ini; i < ibegblk_ini + nblksC_ini_loc + 1; i++)
               pblksC_ini_cnd[i - ibegblk_ini] = _blks_ini[i] - _blks_ini[ibegblk_ini];
            for (i = ibegblk_fin; i < ibegblk_fin + nblksC_fin_loc + 1; i++)
               pblksC_fin_cnd[i - ibegblk_fin] = _blks_fin[i] - _blks_fin[ibegblk_fin];

// Reorder cols

            CMatrix < int, float >*phmatr_temp_0 = phblk_cols[ihblk].GetHMatrStr ();

            int nlist_hblk_temp_0 = phmatr_temp_0->GetNlist ();
            int *plist_hblk_temp_0 = phmatr_temp_0->GetListArr ();
            int *plist2_hblk_temp_0 = phmatr_temp_0->GetList2Arr ();

            for (i = 0; i < nlist_hblk_temp_0; i++)
               plistblk[i] = plist_hblk_temp_0[i];
            for (i = 0; i < nlist_hblk_temp_0; i++)
               plist2blk[i] = plist2_hblk_temp_0[i];

            for (i = 0; i < nlist_hblk_temp_0; i++)
               plist_hblk_temp_0[i] = i;
            for (i = 0; i < nlist_hblk_temp_0; i++)
               plist2_hblk_temp_0[i] = 0;

            int *porderC_loc = _order_diag[ihblk].Ptr ();

            CBMatrix < _Int, _Flt > hblk_temp;

            CBMatrix < _Int, _Flt >::ReorderHMatrixCols (nlist_hblk, pblksR_cnd,
                                                         nblksC_ini_loc, pblksC_ini_cnd,
                                                         phblk_cols[ihblk], porderC_loc,
                                                         nblksC_fin_loc, pblksC_fin_cnd,
                                                         hblk_temp);

            CMatrix < int, float >*phmatr_temp = hblk_temp.GetHMatrStr ();

            int nzja_hblk_temp = phmatr_temp->GetNzja ();
            int *plist_hblk_temp = phmatr_temp->GetListArr ();
            int *plist2_hblk_temp = phmatr_temp->GetList2Arr ();
            int *pja2_hblk_temp = phmatr_temp->GetJa2Arr ();

            for (i = 0; i < nlist_hblk; i++)
               plist_hblk_temp[i] = plistblk[i];
            for (i = 0; i < nlist_hblk; i++)
               plist2_hblk_temp[i] = plist2blk[i];
            for (i = 0; i < nzja_hblk_temp; i++)
               pja2_hblk_temp[i] = ihblk;

            phblk_cols[ihblk].ReplaceFree (hblk_temp);

            phmatr = phblk_cols[ihblk].GetHMatrStr ();
            pA_sub = phblk_cols[ihblk].GetASubArr ();

            nlist_hblk = phmatr->GetNlist ();
            pia_hblk = phmatr->GetIaArr ();

// Renumber back the rows lists

            {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
               for (int ipar = 0; ipar < nlist_hblk; ipar++) {

                  int *pplistindR = plistindR[ipar].Ptr ();

                  int i, j, jj, ind;

                  for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                     int nlistR_temp = pA_sub[i].GetNlist ();
                     _Int *plistR_temp = pA_sub[i].GetListArr ();
                     for (j = 0; j < nlistR_temp; j++) {
                        jj = (int) plistR_temp[j];
                        ind = pplistindR[jj];
                        plistR_temp[j] = (_Int) ind;
                     }
                  }

               }

            }

         }
      }

// Prepare exchange data again

      for (i = 0; i < nproc; i++)
         pimaskcpu[i] = -1;

      nlistcpu = 0;

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            CMatrix < int, float >*phmatr = phblk_cols[i].GetHMatrStr ();
            int nlist_temp = phmatr->GetNlist ();
            int *plist2_temp = phmatr->GetList2Arr ();
            for (j = 0; j < nlist_temp; j++) {
               jj2 = plist2_temp[j];
               jproc = _hblk2cpu[jj2];
               if (pimaskcpu[jproc] < 0) {
                  plistcpu[nlistcpu] = jproc;
                  nlistcpu++;
                  pimaskcpu[jproc] = 1;
               }
            }
         }
      }

      sort (plistcpu, plistcpu + nlistcpu);

      for (i = 0; i < nlistcpu; i++) {
         j = plistcpu[i];
         pimaskcpu[j] = i;
      }

      nzblk_cpu.resize (nlistcpu + 1);

      for (i = 0; i < nlistcpu; i++)
         pnzblk_cpu[i] = 0;

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            CMatrix < int, float >*phmatr = phblk_cols[i].GetHMatrStr ();
            int nlist_temp = phmatr->GetNlist ();
            int *plist2_temp = phmatr->GetList2Arr ();
            int *pia_temp = phmatr->GetIaArr ();
            for (j = 0; j < nlist_temp; j++) {
               jj2 = plist2_temp[j];
               jproc = _hblk2cpu[jj2];
               ind = pimaskcpu[jproc];
               pnzblk_cpu[ind] += (pia_temp[j + 1] - pia_temp[j]);
            }
         }
      }

      blknum_arr.resize (nlistcpu + 1);
      blk_arr.resize (nlistcpu + 1);

      pblknum_arr = &blknum_arr[0];
      pblk_arr = &blk_arr[0];

      for (i = 0; i < nlistcpu; i++) {
         pblknum_arr[i].resize (4 * pnzblk_cpu[i] + 1);
         pblk_arr[i].resize (pnzblk_cpu[i] + 1);
      }

      for (i = 0; i < nlistcpu; i++)
         pnzblk_cpu[i] = 0;

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            CMatrix < int, float >*phmatr = phblk_cols[i].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub = phblk_cols[i].GetASubArr ();
            int nlist_temp = phmatr->GetNlist ();
            int *plist_temp = phmatr->GetListArr ();
            int *plist2_temp = phmatr->GetList2Arr ();
            int *pia_temp = phmatr->GetIaArr ();
            int *pja_temp = phmatr->GetJaArr ();
            int *pja2_temp = phmatr->GetJa2Arr ();
            for (j = 0; j < nlist_temp; j++) {
               iblk = plist_temp[j];
               ihblk = plist2_temp[j];
               for (k = pia_temp[j]; k < pia_temp[j + 1]; k++) {
                  jj = pja_temp[k];
                  jj2 = pja2_temp[k];
                  jproc = _hblk2cpu[ihblk];
                  ind = pimaskcpu[jproc];
                  int *ppblknum = &pblknum_arr[ind][0];
                  CMatrix < _Int, _Flt > *pA_sub_temp = &pblk_arr[ind][0];
                  kkk = pnzblk_cpu[ind];
                  pA_sub_temp[kkk].ReplaceFree (pA_sub[k]);
                  ppblknum[kkk * 4] = iblk;
                  ppblknum[kkk * 4 + 1] = ihblk;
                  ppblknum[kkk * 4 + 2] = jj;
                  ppblknum[kkk * 4 + 3] = jj2;
                  pnzblk_cpu[ind]++;
               }
            }
         }
      }

      hblks_send_temp.resize (nlistcpu + 1);
      phblks_send_temp = &hblks_send_temp[0];

      for (i = 0; i < nlistcpu; i++) {

         int *ppblknum = &pblknum_arr[i][0];
         CMatrix < _Int, _Flt > *ppblk_arr = &pblk_arr[i][0];

// Compute block sparsity

         icycleblk++;

         nlistblk = 0;

         for (j = 0; j < pnzblk_cpu[i]; j++) {
            iblk = ppblknum[j * 4];
            ihblk = ppblknum[j * 4 + 1];
            iblkgl = _hblk2blk_ini[ihblk] + iblk;
            if (pimaskblk[iblkgl] != icycleblk) {
               plistblk[nlistblk] = iblkgl;
               plist2blk[nlistblk] = ihblk;
               nlistblk++;
               pimaskblk[iblkgl] = icycleblk;
            }
         }

         vector < CSortInt > iiarr (nlistblk + 1);
         CSortInt *piiarr = &iiarr[0];

         for (j = 0; j < nlistblk; j++) {
            piiarr[j].ival = plistblk[j];
            piiarr[j].i2val = j;
         }

         sort (piiarr, piiarr + nlistblk);

         for (j = 0; j < nlistblk; j++) {
            plistblk[j] = piiarr[j].ival;
            ind = piiarr[j].i2val;
            pindblk[j] = plist2blk[ind];
         }

         for (j = 0; j < nlistblk; j++)
            plist2blk[j] = pindblk[j];

         for (j = 0; j < nlistblk; j++) {
            ind = plistblk[j];
            pindblk[ind] = j;
         }

         phblks_send_temp[i].SetNzblk (pnzblk_cpu[i]);
         phblks_send_temp[i].ResizeASub (pnzblk_cpu[i]);

         CMatrix < int, float >*phmatr_send = phblks_send_temp[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub_send = phblks_send_temp[i].GetASubArr ();

         phmatr_send->ResizeAndSetAllSp (nlistblk, nlistblk, pnzblk_cpu[i],
                                         pnzblk_cpu[i]);

         int *plist_send = phmatr_send->GetListArr ();
         int *plist2_send = phmatr_send->GetList2Arr ();
         int *pia_send = phmatr_send->GetIaArr ();
         int *pja_send = phmatr_send->GetJaArr ();
         int *pja2_send = phmatr_send->GetJa2Arr ();

         for (j = 0; j < nlistblk; j++) {
            jblkgl = plistblk[j];
            jj2 = plist2blk[j];
            plist_send[j] = jblkgl - _hblk2blk_ini[jj2];
            plist2_send[j] = jj2;
         }

         for (j = 0; j <= nlistblk; j++)
            pia_send[j] = 0;

         for (j = 0; j < pnzblk_cpu[i]; j++) {
            iblk = ppblknum[j * 4];
            ihblk = ppblknum[j * 4 + 1];
            iblkgl = _hblk2blk_ini[ihblk] + iblk;
            ind = pindblk[iblkgl];
            pia_send[ind + 1]++;
         }

         for (j = 0; j < nlistblk; j++)
            pia_send[j + 1] = pia_send[j] + pia_send[j + 1];

         vector < int >iptr (nlistblk + 1);
         int *piptr = &iptr[0];

         for (j = 0; j < nlistblk; j++)
            piptr[j] = pia_send[j];

         for (j = 0; j < pnzblk_cpu[i]; j++) {
            iblk = ppblknum[j * 4];
            ihblk = ppblknum[j * 4 + 1];
            iblkgl = _hblk2blk_ini[ihblk] + iblk;
            ind = pindblk[iblkgl];
            k = piptr[ind];
            pja_send[k] = ppblknum[j * 4 + 2];
            pja2_send[k] = ppblknum[j * 4 + 3];
            pA_sub_send[k].ReplaceFree (ppblk_arr[j]);
            piptr[ind]++;
         }

      }

// Send outer data to another CPU's

      hblk_send_own.Clean ();

      hblks_send.resize (nlistcpu + 1);
      phblks_send = &hblks_send[0];

      nlistcpu_new = 0;

      for (i = 0; i < nlistcpu; i++) {
         if (plistcpu[i] == myid) {
            hblk_send_own.ReplaceFree (phblks_send_temp[i]);
         } else {
            phblks_send[nlistcpu_new].ReplaceFree (phblks_send_temp[i]);
            plistcpu[nlistcpu_new] = plistcpu[i];
            nlistcpu_new++;
         }
      }

      nlistcpu = nlistcpu_new;

// Pack send data

      CpuIDSend.resize (nlistcpu);
      ObjSend.resize (nlistcpu);

      pCpuIDSend = NULL;
      pObjSend = NULL;

      if (nlistcpu > 0) {
         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];
      }

      for (i = 0; i < nlistcpu; i++) {
         pCpuIDSend[i] = plistcpu[i];
         isize = phblks_send[i].GetPackedSize ();
         pObjSend[i].resize ((size_t) isize);
         pobj = &(pObjSend[i][0]);
         phblks_send[i].FillPacked_thr (isize, pobj);
         phblks_send[i].Clean ();
      }

// Exchange

      CpuIDRecv.resize (0);
      ObjRecv.resize (0);

      CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      nrecv = (int) CpuIDRecv.size ();

      pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      hblk_recv.resize (nrecv + 2);

      phblk_recv = &hblk_recv[0];

      for (i = 0; i < nrecv; i++) {
         isize = (long long) pObjRecv[i].size ();
         pobj = &(pObjRecv[i][0]);
         phblk_recv[i].UnPack_thr (isize, pobj);
      }

      phblk_recv[nrecv].ReplaceFree (hblk_send_own);

      nrecv++;

// Free recv data

      {
         vector < int >CpuIDRecv_temp;
         vector < vector < char > >ObjRecv_temp;
         CpuIDRecv.swap (CpuIDRecv_temp);
         ObjRecv.swap (ObjRecv_temp);
      }

// Create sets of blocks for block rows

      vector < int >nzblk_row (_nhblks + 1);
      blknum_arr.resize (_nhblks + 1);
      blk_arr.resize (_nhblks + 1);

      int *pnzblk_row = &nzblk_row[0];
      pblknum_arr = &blknum_arr[0];
      pblk_arr = &blk_arr[0];

      for (i = 0; i < _nhblks; i++)
         pnzblk_row[i] = 0;

      for (i = 0; i < nrecv; i++) {
         CMatrix < int, float >*phmatr = phblk_recv[i].GetHMatrStr ();
         int nlist_temp = phmatr->GetNlist ();
         int *plist_temp = phmatr->GetListArr ();
         int *plist2_temp = phmatr->GetList2Arr ();
         int *pia_temp = phmatr->GetIaArr ();
         for (j = 0; j < nlist_temp; j++) {
            iblk = plist_temp[j];
            ihblk = plist2_temp[j];
            pnzblk_row[ihblk] += (pia_temp[j + 1] - pia_temp[j]);
         }
      }

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            pblknum_arr[i].resize (4 * pnzblk_row[i] + 1);
            pblk_arr[i].resize (pnzblk_row[i] + 1);
         }
      }

      for (i = 0; i < _nhblks; i++)
         pnzblk_row[i] = 0;

      for (i = 0; i < nrecv; i++) {
         CMatrix < int, float >*phmatr = phblk_recv[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub = phblk_recv[i].GetASubArr ();
         int nlist_temp = phmatr->GetNlist ();
         int *plist_temp = phmatr->GetListArr ();
         int *plist2_temp = phmatr->GetList2Arr ();
         int *pia_temp = phmatr->GetIaArr ();
         int *pja_temp = phmatr->GetJaArr ();
         int *pja2_temp = phmatr->GetJa2Arr ();
         for (j = 0; j < nlist_temp; j++) {
            iblk = plist_temp[j];
            ihblk = plist2_temp[j];
            for (k = pia_temp[j]; k < pia_temp[j + 1]; k++) {
               jj = pja_temp[k];
               jj2 = pja2_temp[k];
               int *ppblknum = &pblknum_arr[ihblk][0];
               CMatrix < _Int, _Flt > *pA_sub_temp = &pblk_arr[ihblk][0];
               kkk = pnzblk_row[ihblk];
               pA_sub_temp[kkk].ReplaceFree (pA_sub[k]);
               ppblknum[kkk * 4] = iblk;
               ppblknum[kkk * 4 + 1] = ihblk;
               ppblknum[kkk * 4 + 2] = jj;
               ppblknum[kkk * 4 + 3] = jj2;
               pnzblk_row[ihblk]++;
            }
         }
      }

// Combine all received data into the set of block columns

      vector < CBMatrix < _Int, _Flt > >hblk_rows (_nhblks + 1);
      CBMatrix < _Int, _Flt > *phblk_rows = &hblk_rows[0];

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {

            int *ppblknum = &pblknum_arr[i][0];
            CMatrix < _Int, _Flt > *ppblk_arr = &pblk_arr[i][0];

// Compute block sparsity

            icycleblk++;

            nlistblk = 0;

            for (j = 0; j < pnzblk_row[i]; j++) {
               iblk = ppblknum[j * 4];
               ihblk = ppblknum[j * 4 + 1];
               iblkgl = _hblk2blk_ini[ihblk] + iblk;
               if (pimaskblk[iblkgl] != icycleblk) {
                  plistblk[nlistblk] = iblkgl;
                  plist2blk[nlistblk] = ihblk;
                  nlistblk++;
                  pimaskblk[iblkgl] = icycleblk;
               }
            }

            vector < CSortInt > iiarr (nlistblk + 1);
            CSortInt *piiarr = &iiarr[0];

            for (j = 0; j < nlistblk; j++) {
               piiarr[j].ival = plistblk[j];
               piiarr[j].i2val = j;
            }

            sort (piiarr, piiarr + nlistblk);

            for (j = 0; j < nlistblk; j++) {
               plistblk[j] = piiarr[j].ival;
               ind = piiarr[j].i2val;
               pindblk[j] = plist2blk[ind];
            }

            for (j = 0; j < nlistblk; j++)
               plist2blk[j] = pindblk[j];

            for (j = 0; j < nlistblk; j++) {
               ind = plistblk[j];
               pindblk[ind] = j;
            }

            phblk_rows[i].SetNzblk (pnzblk_row[i]);
            phblk_rows[i].ResizeASub (pnzblk_row[i]);

            CMatrix < int, float >*phmatr_rows = phblk_rows[i].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub_rows = phblk_rows[i].GetASubArr ();

            phmatr_rows->ResizeAndSetAllSp (nlistblk, nlistblk, pnzblk_row[i],
                                            pnzblk_row[i]);

            int *plist_rows = phmatr_rows->GetListArr ();
            int *plist2_rows = phmatr_rows->GetList2Arr ();
            int *pia_rows = phmatr_rows->GetIaArr ();
            int *pja_rows = phmatr_rows->GetJaArr ();
            int *pja2_rows = phmatr_rows->GetJa2Arr ();

            for (j = 0; j < nlistblk; j++) {
               jblkgl = plistblk[j];
               jj2 = plist2blk[j];
               plist_rows[j] = jblkgl - _hblk2blk_ini[jj2];
               plist2_rows[j] = jj2;
            }

            for (j = 0; j <= nlistblk; j++)
               pia_rows[j] = 0;

            for (j = 0; j < pnzblk_row[i]; j++) {
               iblk = ppblknum[j * 4];
               ihblk = ppblknum[j * 4 + 1];
               iblkgl = _hblk2blk_ini[ihblk] + iblk;
               ind = pindblk[iblkgl];
               pia_rows[ind + 1]++;
            }

            for (j = 0; j < nlistblk; j++)
               pia_rows[j + 1] = pia_rows[j] + pia_rows[j + 1];

            vector < int >iptr (nlistblk + 1);
            int *piptr = &iptr[0];

            for (j = 0; j < nlistblk; j++)
               piptr[j] = pia_rows[j];

            for (j = 0; j < pnzblk_row[i]; j++) {
               iblk = ppblknum[j * 4];
               ihblk = ppblknum[j * 4 + 1];
               iblkgl = _hblk2blk_ini[ihblk] + iblk;
               ind = pindblk[iblkgl];
               k = piptr[ind];
               pja_rows[k] = ppblknum[j * 4 + 2];
               pja2_rows[k] = ppblknum[j * 4 + 3];
               pA_sub_rows[k].ReplaceFree (ppblk_arr[j]);
               piptr[ind]++;
            }
         }

      }

// Reorder rows data

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {

// Create list of column blocks

            CMatrix < int, float >*phmatr_rows = phblk_rows[ihblk].GetHMatrStr ();

            int nzja_rows = phmatr_rows->GetNzja ();
            int *pja_rows = phmatr_rows->GetJaArr ();
            int *pja2_rows = phmatr_rows->GetJa2Arr ();

            icycleblk++;

            nlistblk = 0;

            int jblk, jhblk, jblkgl;

            for (j = 0; j < nzja_rows; j++) {
               jblk = pja_rows[j];
               jhblk = pja2_rows[j];
               jblkgl = _hblk2blk_fin[jhblk] + jblk;
               if (pimaskblk[jblkgl] != icycleblk) {
                  plistblk[nlistblk] = jblkgl;
                  plist2blk[nlistblk] = jhblk;
                  nlistblk++;
                  pimaskblk[jblkgl] = icycleblk;
               }
            }

            vector < CSortInt > iiarr (nlistblk + 1);
            CSortInt *piiarr = &iiarr[0];

            for (j = 0; j < nlistblk; j++) {
               piiarr[j].ival = plistblk[j];
               piiarr[j].i2val = j;
            }

            sort (piiarr, piiarr + nlistblk);

            for (j = 0; j < nlistblk; j++) {
               plistblk[j] = piiarr[j].ival;
               ind = piiarr[j].i2val;
               pindblk[j] = plist2blk[ind];
            }

            for (j = 0; j < nlistblk; j++)
               plist2blk[j] = pindblk[j];

            for (j = 0; j < nlistblk; j++) {
               ind = plistblk[j];
               pindblk[ind] = j;
            }

            for (i = 0; i <= nlistblk; i++)
               pblksR_cnd[i] = 0;

            for (j = 0; j < nlistblk; j++) {
               ind = plistblk[j];
               pblksR_cnd[j + 1] = _blks_fin[ind + 1] - _blks_fin[ind];
            }

            for (i = 0; i < nlistblk; i++)
               pblksR_cnd[i + 1] = pblksR_cnd[i] + pblksR_cnd[i + 1];

            for (j = 0; j < nzja_rows; j++) {
               jblk = pja_rows[j];
               jhblk = pja2_rows[j];
               jblkgl = _hblk2blk_fin[jhblk] + jblk;
               ind = pindblk[jblkgl];
               pja_rows[j] = ind;
               pja2_rows[j] = 0;
            }

// Prepare blocks partitionings

            int ibegblk_ini = _hblk2blk_ini[ihblk];
            int ibegblk_fin = _hblk2blk_fin[ihblk];

            int nblksR_ini_loc = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
            int nblksR_fin_loc = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];

            for (i = ibegblk_ini; i < ibegblk_ini + nblksR_ini_loc + 1; i++)
               pblksC_ini_cnd[i - ibegblk_ini] = _blks_ini[i] - _blks_ini[ibegblk_ini];
            for (i = ibegblk_fin; i < ibegblk_fin + nblksR_fin_loc + 1; i++)
               pblksC_fin_cnd[i - ibegblk_fin] = _blks_fin[i] - _blks_fin[ibegblk_fin];

// Reorder rows

            int *porderR_loc = _order_diag[ihblk].Ptr ();

            CBMatrix < _Int, _Flt >::ReorderHMatrixRows (nlistblk, pblksR_cnd,
                                                         nblksR_ini_loc, pblksC_ini_cnd,
                                                         phblk_rows[ihblk], porderR_loc,
                                                         nblksR_fin_loc, pblksC_fin_cnd,
                                                         _hmatr_arr_fin[ihblk]);

            CMatrix < int, float >*phmatr_temp = _hmatr_arr_fin[ihblk].GetHMatrStr ();

            int nlist_hblk_temp = phmatr_temp->GetNlist ();
            int nzja_hblk_temp = phmatr_temp->GetNzja ();
            int *plist2_hblk_temp = phmatr_temp->GetList2Arr ();
            int *pja_hblk_temp = phmatr_temp->GetJaArr ();
            int *pja2_hblk_temp = phmatr_temp->GetJa2Arr ();

            for (i = 0; i < nlist_hblk_temp; i++)
               plist2_hblk_temp[i] = ihblk;
            for (i = 0; i < nzja_hblk_temp; i++) {
               jblk = pja_hblk_temp[i];
               jblkgl = plistblk[jblk];
               jhblk = plist2blk[jblk];
               pja_hblk_temp[i] = plistblk[jblk] - _hblk2blk_fin[jhblk];
               pja2_hblk_temp[i] = jhblk;
            }

         }
      }

   }

// Compute reordered hmatrix (orderings are local inside hblocks)
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ReorderHMatrixDiag_BxB (void *_comm, int _blksize, int _nhblks,
                                      int *_hblk2cpu, int *_hblk2blk_ini, int _nblks_ini,
                                      long long *_blks_ini, CBMatrix < _Int,
                                      _Flt > *_hmatr_arr_ini,
                                      CVectorData < int >*_order_diag, int *_hblk2blk_fin,
                                      int _nblks_fin, long long *_blks_fin,
                                      CBMatrix < _Int, _Flt > *_hmatr_arr_fin)
   {

      int myid = CMPIDataExchange::GetMyid (_comm);
      int nproc = CMPIDataExchange::GetNproc (_comm);

// Prepare send data

      vector < int >imaskcpu (nproc + 1);
      vector < int >listcpu (nproc + 1);

      int *pimaskcpu = &imaskcpu[0];
      int *plistcpu = &listcpu[0];

      int i;

      for (i = 0; i < nproc; i++)
         pimaskcpu[i] = -1;

      int j, jj2, jproc;

      int nlistcpu = 0;

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            CMatrix < int, float >*phmatr = _hmatr_arr_ini[i].GetHMatrStr ();
            int nzja_temp = phmatr->GetNzja ();
            int *pja2_temp = phmatr->GetJa2Arr ();
            for (j = 0; j < nzja_temp; j++) {
               jj2 = pja2_temp[j];
               jproc = _hblk2cpu[jj2];
               if (pimaskcpu[jproc] < 0) {
                  plistcpu[nlistcpu] = jproc;
                  nlistcpu++;
                  pimaskcpu[jproc] = 1;
               }
            }
         }
      }

      sort (plistcpu, plistcpu + nlistcpu);

      for (i = 0; i < nlistcpu; i++) {
         j = plistcpu[i];
         pimaskcpu[j] = i;
      }

      vector < int >nzblk_cpu (nlistcpu + 1);
      int *pnzblk_cpu = &nzblk_cpu[0];

      for (i = 0; i < nlistcpu; i++)
         pnzblk_cpu[i] = 0;

      int ind;

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            CMatrix < int, float >*phmatr = _hmatr_arr_ini[i].GetHMatrStr ();
            int nzja_temp = phmatr->GetNzja ();
            int *pja2_temp = phmatr->GetJa2Arr ();
            for (j = 0; j < nzja_temp; j++) {
               jj2 = pja2_temp[j];
               jproc = _hblk2cpu[jj2];
               ind = pimaskcpu[jproc];
               pnzblk_cpu[ind]++;
            }
         }
      }

      vector < vector < int > >blknum_arr (nlistcpu + 1);
      vector < vector < CMatrix < _Int, _Flt > > >blk_arr (nlistcpu + 1);

      vector < int >*pblknum_arr = &blknum_arr[0];
      vector < CMatrix < _Int, _Flt > >*pblk_arr = &blk_arr[0];

      for (i = 0; i < nlistcpu; i++) {
         pblknum_arr[i].resize (4 * pnzblk_cpu[i] + 1);
         pblk_arr[i].resize (pnzblk_cpu[i] + 1);
      }

      for (i = 0; i < nlistcpu; i++)
         pnzblk_cpu[i] = 0;

      int k, kkk, iblk, jj;

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            CMatrix < int, float >*phmatr = _hmatr_arr_ini[i].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub = _hmatr_arr_ini[i].GetASubArr ();
            int nlist_temp = phmatr->GetNlist ();
            int *plist_temp = phmatr->GetListArr ();
            int *pia_temp = phmatr->GetIaArr ();
            int *pja_temp = phmatr->GetJaArr ();
            int *pja2_temp = phmatr->GetJa2Arr ();
            for (j = 0; j < nlist_temp; j++) {
               iblk = plist_temp[j];
               for (k = pia_temp[j]; k < pia_temp[j + 1]; k++) {
                  jj = pja_temp[k];
                  jj2 = pja2_temp[k];
                  jproc = _hblk2cpu[jj2];
                  ind = pimaskcpu[jproc];
                  int *ppblknum = &pblknum_arr[ind][0];
                  CMatrix < _Int, _Flt > *pA_sub_temp = &pblk_arr[ind][0];
                  kkk = pnzblk_cpu[ind];
                  pA_sub_temp[kkk].ReplaceFree (pA_sub[k]);
                  ppblknum[kkk * 4] = iblk;
                  ppblknum[kkk * 4 + 1] = i;
                  ppblknum[kkk * 4 + 2] = jj;
                  ppblknum[kkk * 4 + 3] = jj2;
                  pnzblk_cpu[ind]++;
               }
            }
         }
      }

// Fill block sparsity structures

      int nblks_max = _nblks_ini;
      if (_nblks_fin > nblks_max)
         nblks_max = _nblks_fin;

      vector < int >imaskblk (nblks_max + 1);
      vector < int >listblk (nblks_max + 1);
      vector < int >list2blk (nblks_max + 1);
      vector < int >indblk (nblks_max + 1);

      int *pimaskblk = &imaskblk[0];
      int *plistblk = &listblk[0];
      int *plist2blk = &list2blk[0];
      int *pindblk = &indblk[0];

      for (i = 0; i < nblks_max; i++)
         pimaskblk[i] = -1;

      int icycleblk = -1;

      vector < CBMatrix < _Int, _Flt > >hblks_send_temp (nlistcpu + 1);
      CBMatrix < _Int, _Flt > *phblks_send_temp = &hblks_send_temp[0];

      int nlistblk, ihblk, iblkgl, jblkgl;

      for (i = 0; i < nlistcpu; i++) {

         int *ppblknum = &pblknum_arr[i][0];
         CMatrix < _Int, _Flt > *ppblk_arr = &pblk_arr[i][0];

// Compute block sparsity

         icycleblk++;

         nlistblk = 0;

         for (j = 0; j < pnzblk_cpu[i]; j++) {
            iblk = ppblknum[j * 4];
            ihblk = ppblknum[j * 4 + 1];
            iblkgl = _hblk2blk_ini[ihblk] + iblk;
            if (pimaskblk[iblkgl] != icycleblk) {
               plistblk[nlistblk] = iblkgl;
               plist2blk[nlistblk] = ihblk;
               nlistblk++;
               pimaskblk[iblkgl] = icycleblk;
            }
         }

         vector < CSortInt > iiarr (nlistblk + 1);
         CSortInt *piiarr = &iiarr[0];

         for (j = 0; j < nlistblk; j++) {
            piiarr[j].ival = plistblk[j];
            piiarr[j].i2val = j;
         }

         sort (piiarr, piiarr + nlistblk);

         for (j = 0; j < nlistblk; j++) {
            plistblk[j] = piiarr[j].ival;
            ind = piiarr[j].i2val;
            pindblk[j] = plist2blk[ind];
         }

         for (j = 0; j < nlistblk; j++)
            plist2blk[j] = pindblk[j];

         for (j = 0; j < nlistblk; j++) {
            ind = plistblk[j];
            pindblk[ind] = j;
         }

         phblks_send_temp[i].SetNzblk (pnzblk_cpu[i]);
         phblks_send_temp[i].ResizeASub (pnzblk_cpu[i]);

         CMatrix < int, float >*phmatr_send = phblks_send_temp[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub_send = phblks_send_temp[i].GetASubArr ();

         phmatr_send->ResizeAndSetAllSp (nlistblk, nlistblk, pnzblk_cpu[i],
                                         pnzblk_cpu[i]);

         int *plist_send = phmatr_send->GetListArr ();
         int *plist2_send = phmatr_send->GetList2Arr ();
         int *pia_send = phmatr_send->GetIaArr ();
         int *pja_send = phmatr_send->GetJaArr ();
         int *pja2_send = phmatr_send->GetJa2Arr ();

         for (j = 0; j < nlistblk; j++) {
            jblkgl = plistblk[j];
            jj2 = plist2blk[j];
            plist_send[j] = jblkgl - _hblk2blk_ini[jj2];
            plist2_send[j] = jj2;
         }

         for (j = 0; j <= nlistblk; j++)
            pia_send[j] = 0;

         for (j = 0; j < pnzblk_cpu[i]; j++) {
            iblk = ppblknum[j * 4];
            ihblk = ppblknum[j * 4 + 1];
            iblkgl = _hblk2blk_ini[ihblk] + iblk;
            ind = pindblk[iblkgl];
            pia_send[ind + 1]++;
         }

         for (j = 0; j < nlistblk; j++)
            pia_send[j + 1] = pia_send[j] + pia_send[j + 1];

         vector < int >iptr (nlistblk + 1);
         int *piptr = &iptr[0];

         for (j = 0; j < nlistblk; j++)
            piptr[j] = pia_send[j];

         for (j = 0; j < pnzblk_cpu[i]; j++) {
            iblk = ppblknum[j * 4];
            ihblk = ppblknum[j * 4 + 1];
            iblkgl = _hblk2blk_ini[ihblk] + iblk;
            ind = pindblk[iblkgl];
            k = piptr[ind];
            pja_send[k] = ppblknum[j * 4 + 2];
            pja2_send[k] = ppblknum[j * 4 + 3];
            pA_sub_send[k].ReplaceFree (ppblk_arr[j]);
            piptr[ind]++;
         }

      }

// Free temp data

      {

         vector < vector < int > >blknum_arr_temp;
         vector < vector < CMatrix < _Int, _Flt > > >blk_arr_temp;

         blknum_arr.swap (blknum_arr_temp);
         blk_arr.swap (blk_arr_temp);

      }


// Send outer data to another CPU's

      CBMatrix < _Int, _Flt > hblk_send_own;

      vector < CBMatrix < _Int, _Flt > >hblks_send (nlistcpu + 1);
      CBMatrix < _Int, _Flt > *phblks_send = &hblks_send[0];

      int nlistcpu_new = 0;

      for (i = 0; i < nlistcpu; i++) {
         if (plistcpu[i] == myid) {
            hblk_send_own.ReplaceFree (phblks_send_temp[i]);
         } else {
            phblks_send[nlistcpu_new].ReplaceFree (phblks_send_temp[i]);
            plistcpu[nlistcpu_new] = plistcpu[i];
            nlistcpu_new++;
         }
      }

      nlistcpu = nlistcpu_new;

// Pack send data

      vector < int >CpuIDSend (nlistcpu);
      vector < vector < char > >ObjSend (nlistcpu);

      int *pCpuIDSend = NULL;
      vector < char >*pObjSend = NULL;

      if (nlistcpu > 0) {
         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];
      }

      long long isize;
      char *pobj;

      for (i = 0; i < nlistcpu; i++) {
         pCpuIDSend[i] = plistcpu[i];
         isize = phblks_send[i].GetPackedSize ();
         pObjSend[i].resize ((size_t) isize);
         pobj = &(pObjSend[i][0]);
         phblks_send[i].FillPacked_thr (isize, pobj);
         phblks_send[i].Clean ();
      }

// Exchange

      vector < int >CpuIDRecv;
      vector < vector < char > >ObjRecv;

      CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      int nrecv = (int) CpuIDRecv.size ();

      vector < char >*pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      vector < CBMatrix < _Int, _Flt > >hblk_recv (nrecv + 2);

      CBMatrix < _Int, _Flt > *phblk_recv = &hblk_recv[0];

      for (i = 0; i < nrecv; i++) {
         isize = (long long) pObjRecv[i].size ();
         pobj = &(pObjRecv[i][0]);
         phblk_recv[i].UnPack_thr (isize, pobj);
      }

      phblk_recv[nrecv].ReplaceFree (hblk_send_own);

      nrecv++;

// Free recv data

      {
         vector < int >CpuIDRecv_temp;
         vector < vector < char > >ObjRecv_temp;
         CpuIDRecv.swap (CpuIDRecv_temp);
         ObjRecv.swap (ObjRecv_temp);
      }

// Create sets of blocks for block columns

      vector < int >nzblk_col (_nhblks + 1);
      blknum_arr.resize (_nhblks + 1);
      blk_arr.resize (_nhblks + 1);

      int *pnzblk_col = &nzblk_col[0];
      pblknum_arr = &blknum_arr[0];
      pblk_arr = &blk_arr[0];

      for (i = 0; i < _nhblks; i++)
         pnzblk_col[i] = 0;

      for (i = 0; i < nrecv; i++) {
         CMatrix < int, float >*phmatr = phblk_recv[i].GetHMatrStr ();
         int nlist_temp = phmatr->GetNlist ();
         int *plist_temp = phmatr->GetListArr ();
         int *plist2_temp = phmatr->GetList2Arr ();
         int *pia_temp = phmatr->GetIaArr ();
         int *pja_temp = phmatr->GetJaArr ();
         int *pja2_temp = phmatr->GetJa2Arr ();
         for (j = 0; j < nlist_temp; j++) {
            iblk = plist_temp[j];
            ihblk = plist2_temp[j];
            for (k = pia_temp[j]; k < pia_temp[j + 1]; k++) {
               jj = pja_temp[k];
               jj2 = pja2_temp[k];
               pnzblk_col[jj2]++;
            }
         }
      }

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            pblknum_arr[i].resize (4 * pnzblk_col[i] + 1);
            pblk_arr[i].resize (pnzblk_col[i] + 1);
         }
      }

      for (i = 0; i < _nhblks; i++)
         pnzblk_col[i] = 0;

      for (i = 0; i < nrecv; i++) {
         CMatrix < int, float >*phmatr = phblk_recv[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub = phblk_recv[i].GetASubArr ();
         int nlist_temp = phmatr->GetNlist ();
         int *plist_temp = phmatr->GetListArr ();
         int *plist2_temp = phmatr->GetList2Arr ();
         int *pia_temp = phmatr->GetIaArr ();
         int *pja_temp = phmatr->GetJaArr ();
         int *pja2_temp = phmatr->GetJa2Arr ();
         for (j = 0; j < nlist_temp; j++) {
            iblk = plist_temp[j];
            ihblk = plist2_temp[j];
            for (k = pia_temp[j]; k < pia_temp[j + 1]; k++) {
               jj = pja_temp[k];
               jj2 = pja2_temp[k];
               int *ppblknum = &pblknum_arr[jj2][0];
               CMatrix < _Int, _Flt > *pA_sub_temp = &pblk_arr[jj2][0];
               kkk = pnzblk_col[jj2];
               pA_sub_temp[kkk].ReplaceFree (pA_sub[k]);
               ppblknum[kkk * 4] = iblk;
               ppblknum[kkk * 4 + 1] = ihblk;
               ppblknum[kkk * 4 + 2] = jj;
               ppblknum[kkk * 4 + 3] = jj2;
               pnzblk_col[jj2]++;
            }
         }
      }

// Combine all received data into the set of block columns

      vector < CBMatrix < _Int, _Flt > >hblk_cols (_nhblks + 1);
      CBMatrix < _Int, _Flt > *phblk_cols = &hblk_cols[0];

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {

            int *ppblknum = &pblknum_arr[i][0];
            CMatrix < _Int, _Flt > *ppblk_arr = &pblk_arr[i][0];

// Compute block sparsity

            icycleblk++;

            nlistblk = 0;

            for (j = 0; j < pnzblk_col[i]; j++) {
               iblk = ppblknum[j * 4];
               ihblk = ppblknum[j * 4 + 1];
               iblkgl = _hblk2blk_ini[ihblk] + iblk;
               if (pimaskblk[iblkgl] != icycleblk) {
                  plistblk[nlistblk] = iblkgl;
                  plist2blk[nlistblk] = ihblk;
                  nlistblk++;
                  pimaskblk[iblkgl] = icycleblk;
               }
            }

            vector < CSortInt > iiarr (nlistblk + 1);
            CSortInt *piiarr = &iiarr[0];

            for (j = 0; j < nlistblk; j++) {
               piiarr[j].ival = plistblk[j];
               piiarr[j].i2val = j;
            }

            sort (piiarr, piiarr + nlistblk);

            for (j = 0; j < nlistblk; j++) {
               plistblk[j] = piiarr[j].ival;
               ind = piiarr[j].i2val;
               pindblk[j] = plist2blk[ind];
            }

            for (j = 0; j < nlistblk; j++)
               plist2blk[j] = pindblk[j];

            for (j = 0; j < nlistblk; j++) {
               ind = plistblk[j];
               pindblk[ind] = j;
            }

            phblk_cols[i].SetNzblk (pnzblk_col[i]);
            phblk_cols[i].ResizeASub (pnzblk_col[i]);

            CMatrix < int, float >*phmatr_cols = phblk_cols[i].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub_cols = phblk_cols[i].GetASubArr ();

            phmatr_cols->ResizeAndSetAllSp (nlistblk, nlistblk, pnzblk_col[i],
                                            pnzblk_col[i]);

            int *plist_cols = phmatr_cols->GetListArr ();
            int *plist2_cols = phmatr_cols->GetList2Arr ();
            int *pia_cols = phmatr_cols->GetIaArr ();
            int *pja_cols = phmatr_cols->GetJaArr ();
            int *pja2_cols = phmatr_cols->GetJa2Arr ();

            for (j = 0; j < nlistblk; j++) {
               jblkgl = plistblk[j];
               jj2 = plist2blk[j];
               plist_cols[j] = jblkgl - _hblk2blk_ini[jj2];
               plist2_cols[j] = jj2;
            }

            for (j = 0; j <= nlistblk; j++)
               pia_cols[j] = 0;

            for (j = 0; j < pnzblk_col[i]; j++) {
               iblk = ppblknum[j * 4];
               ihblk = ppblknum[j * 4 + 1];
               iblkgl = _hblk2blk_ini[ihblk] + iblk;
               ind = pindblk[iblkgl];
               pia_cols[ind + 1]++;
            }

            for (j = 0; j < nlistblk; j++)
               pia_cols[j + 1] = pia_cols[j] + pia_cols[j + 1];

            vector < int >iptr (nlistblk + 1);
            int *piptr = &iptr[0];

            for (j = 0; j < nlistblk; j++)
               piptr[j] = pia_cols[j];

            for (j = 0; j < pnzblk_col[i]; j++) {
               iblk = ppblknum[j * 4];
               ihblk = ppblknum[j * 4 + 1];
               iblkgl = _hblk2blk_ini[ihblk] + iblk;
               ind = pindblk[iblkgl];
               k = piptr[ind];
               pja_cols[k] = ppblknum[j * 4 + 2];
               pja2_cols[k] = ppblknum[j * 4 + 3];
               pA_sub_cols[k].ReplaceFree (ppblk_arr[j]);
               piptr[ind]++;
            }
         }

      }

// Prepare mask data

      int nimax = 0;
      int niloc = 0;

      for (i = 0; i < _nblks_ini; i++) {
         niloc = (int) (_blks_ini[i + 1] - _blks_ini[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

      vector < int >icycle_thr (n_thr + 1);
      vector < CVectorData < int > >imaskblk_thr (n_thr + 1);

      int *picycle_thr = &icycle_thr[0];
      CVectorData < int >*pimaskblk_thr = &imaskblk_thr[0];

      for (i = 0; i < n_thr; i++)
         picycle_thr[i] = -1;

// Perform columns ordering of own hblocks

      CVectorData < long long >blksR_cnd (nblks_max + 1);
      vector < CVectorData < int > >listindR (nblks_max + 1);
      CVectorData < long long >blksC_ini_cnd (nblks_max + 1);
      CVectorData < long long >blksC_fin_cnd (nblks_max + 1);

      long long *pblksR_cnd = blksR_cnd.Ptr ();
      CVectorData < int >*plistindR = &listindR[0];
      long long *pblksC_ini_cnd = blksC_ini_cnd.Ptr ();
      long long *pblksC_fin_cnd = blksC_fin_cnd.Ptr ();

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {

            CMatrix < int, float >*phmatr = phblk_cols[ihblk].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub = phblk_cols[ihblk].GetASubArr ();

            int nlist_hblk = phmatr->GetNlist ();
            int *pia_hblk = phmatr->GetIaArr ();

            for (j = 0; j <= nlist_hblk; j++)
               pblksR_cnd[j] = 0;

// Compute lists of work rows indices in all block rows

#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nlist_hblk; ipar++) {
               int my_thr = 0;
#ifdef USE_THREADS
               my_thr = omp_get_thread_num ();
#endif
               int i, j, jj, ind;

               if (picycle_thr[my_thr] == -1) {
                  pimaskblk_thr[my_thr].resize (3 * nimax + 1);
                  int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
                  for (j = 0; j < nimax; j++)
                     pimaskblk[j] = -1;
               }

               int icycleblk = picycle_thr[my_thr];
               int *pimaskblk = pimaskblk_thr[my_thr].Ptr ();
               int *plistblk = pimaskblk + nimax;
               int *pindblk = plistblk + nimax;

               icycleblk++;

               int nlistR_loc = 0;

               for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                  int nlistR_temp = pA_sub[i].GetNlist ();
                  _Int *plistR_temp = pA_sub[i].GetListArr ();
                  for (j = 0; j < nlistR_temp; j++) {
                     jj = (int) plistR_temp[j];
                     if (pimaskblk[jj] != icycleblk) {
                        plistblk[nlistR_loc] = jj;
                        nlistR_loc++;
                        pimaskblk[jj] = icycleblk;
                     }
                  }
               }

               sort (plistblk, plistblk + nlistR_loc);

               for (i = 0; i < nlistR_loc; i++) {
                  j = plistblk[i];
                  pindblk[j] = i;
               }

               pblksR_cnd[ipar + 1] = nlistR_loc;

               plistindR[ipar].resize (nlistR_loc);

               int *pplistindR = plistindR[ipar].Ptr ();

               for (i = 0; i < nlistR_loc; i++)
                  pplistindR[i] = plistblk[i];

               for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                  int nlistR_temp = pA_sub[i].GetNlist ();
                  _Int *plistR_temp = pA_sub[i].GetListArr ();
                  for (j = 0; j < nlistR_temp; j++) {
                     jj = (int) plistR_temp[j];
                     ind = pindblk[jj];
                     plistR_temp[j] = (_Int) ind;
                  }
               }

               picycle_thr[my_thr] = icycleblk;

            }

// Prepare blocks partitionings

            for (i = 0; i < nlist_hblk; i++)
               pblksR_cnd[i + 1] = pblksR_cnd[i] + pblksR_cnd[i + 1];

            int ibegblk_ini = _hblk2blk_ini[ihblk];
            int ibegblk_fin = _hblk2blk_fin[ihblk];

            int nblksC_ini_loc = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
            int nblksC_fin_loc = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];

            for (i = ibegblk_ini; i < ibegblk_ini + nblksC_ini_loc + 1; i++)
               pblksC_ini_cnd[i - ibegblk_ini] = _blks_ini[i] - _blks_ini[ibegblk_ini];
            for (i = ibegblk_fin; i < ibegblk_fin + nblksC_fin_loc + 1; i++)
               pblksC_fin_cnd[i - ibegblk_fin] = _blks_fin[i] - _blks_fin[ibegblk_fin];

// Reorder cols

            CMatrix < int, float >*phmatr_temp_0 = phblk_cols[ihblk].GetHMatrStr ();

            int nlist_hblk_temp_0 = phmatr_temp_0->GetNlist ();
            int *plist_hblk_temp_0 = phmatr_temp_0->GetListArr ();
            int *plist2_hblk_temp_0 = phmatr_temp_0->GetList2Arr ();

            for (i = 0; i < nlist_hblk_temp_0; i++)
               plistblk[i] = plist_hblk_temp_0[i];
            for (i = 0; i < nlist_hblk_temp_0; i++)
               plist2blk[i] = plist2_hblk_temp_0[i];

            for (i = 0; i < nlist_hblk_temp_0; i++)
               plist_hblk_temp_0[i] = i;
            for (i = 0; i < nlist_hblk_temp_0; i++)
               plist2_hblk_temp_0[i] = 0;

            int *porderC_loc = _order_diag[ihblk].Ptr ();

            CBMatrix < _Int, _Flt > hblk_temp;

            CBMatrix < _Int, _Flt >::ReorderHMatrixCols_BxB (_blksize, nlist_hblk,
                                                             pblksR_cnd, nblksC_ini_loc,
                                                             pblksC_ini_cnd,
                                                             phblk_cols[ihblk],
                                                             porderC_loc, nblksC_fin_loc,
                                                             pblksC_fin_cnd, hblk_temp);

            CMatrix < int, float >*phmatr_temp = hblk_temp.GetHMatrStr ();

            int nzja_hblk_temp = phmatr_temp->GetNzja ();
            int *plist_hblk_temp = phmatr_temp->GetListArr ();
            int *plist2_hblk_temp = phmatr_temp->GetList2Arr ();
            int *pja2_hblk_temp = phmatr_temp->GetJa2Arr ();

            for (i = 0; i < nlist_hblk; i++)
               plist_hblk_temp[i] = plistblk[i];
            for (i = 0; i < nlist_hblk; i++)
               plist2_hblk_temp[i] = plist2blk[i];
            for (i = 0; i < nzja_hblk_temp; i++)
               pja2_hblk_temp[i] = ihblk;

            phblk_cols[ihblk].ReplaceFree (hblk_temp);

            phmatr = phblk_cols[ihblk].GetHMatrStr ();
            pA_sub = phblk_cols[ihblk].GetASubArr ();

            nlist_hblk = phmatr->GetNlist ();
            pia_hblk = phmatr->GetIaArr ();

// Renumber back the rows lists

            {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
               for (int ipar = 0; ipar < nlist_hblk; ipar++) {

                  int *pplistindR = plistindR[ipar].Ptr ();

                  int i, j, jj, ind;

                  for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                     int nlistR_temp = pA_sub[i].GetNlist ();
                     _Int *plistR_temp = pA_sub[i].GetListArr ();
                     for (j = 0; j < nlistR_temp; j++) {
                        jj = (int) plistR_temp[j];
                        ind = pplistindR[jj];
                        plistR_temp[j] = (_Int) ind;
                     }
                  }

               }

            }

         }
      }

// Prepare exchange data again

      for (i = 0; i < nproc; i++)
         pimaskcpu[i] = -1;

      nlistcpu = 0;

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            CMatrix < int, float >*phmatr = phblk_cols[i].GetHMatrStr ();
            int nlist_temp = phmatr->GetNlist ();
            int *plist2_temp = phmatr->GetList2Arr ();
            for (j = 0; j < nlist_temp; j++) {
               jj2 = plist2_temp[j];
               jproc = _hblk2cpu[jj2];
               if (pimaskcpu[jproc] < 0) {
                  plistcpu[nlistcpu] = jproc;
                  nlistcpu++;
                  pimaskcpu[jproc] = 1;
               }
            }
         }
      }

      sort (plistcpu, plistcpu + nlistcpu);

      for (i = 0; i < nlistcpu; i++) {
         j = plistcpu[i];
         pimaskcpu[j] = i;
      }

      nzblk_cpu.resize (nlistcpu + 1);

      for (i = 0; i < nlistcpu; i++)
         pnzblk_cpu[i] = 0;

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            CMatrix < int, float >*phmatr = phblk_cols[i].GetHMatrStr ();
            int nlist_temp = phmatr->GetNlist ();
            int *plist2_temp = phmatr->GetList2Arr ();
            int *pia_temp = phmatr->GetIaArr ();
            for (j = 0; j < nlist_temp; j++) {
               jj2 = plist2_temp[j];
               jproc = _hblk2cpu[jj2];
               ind = pimaskcpu[jproc];
               pnzblk_cpu[ind] += (pia_temp[j + 1] - pia_temp[j]);
            }
         }
      }

      blknum_arr.resize (nlistcpu + 1);
      blk_arr.resize (nlistcpu + 1);

      pblknum_arr = &blknum_arr[0];
      pblk_arr = &blk_arr[0];

      for (i = 0; i < nlistcpu; i++) {
         pblknum_arr[i].resize (4 * pnzblk_cpu[i] + 1);
         pblk_arr[i].resize (pnzblk_cpu[i] + 1);
      }

      for (i = 0; i < nlistcpu; i++)
         pnzblk_cpu[i] = 0;

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            CMatrix < int, float >*phmatr = phblk_cols[i].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub = phblk_cols[i].GetASubArr ();
            int nlist_temp = phmatr->GetNlist ();
            int *plist_temp = phmatr->GetListArr ();
            int *plist2_temp = phmatr->GetList2Arr ();
            int *pia_temp = phmatr->GetIaArr ();
            int *pja_temp = phmatr->GetJaArr ();
            int *pja2_temp = phmatr->GetJa2Arr ();
            for (j = 0; j < nlist_temp; j++) {
               iblk = plist_temp[j];
               ihblk = plist2_temp[j];
               for (k = pia_temp[j]; k < pia_temp[j + 1]; k++) {
                  jj = pja_temp[k];
                  jj2 = pja2_temp[k];
                  jproc = _hblk2cpu[ihblk];
                  ind = pimaskcpu[jproc];
                  int *ppblknum = &pblknum_arr[ind][0];
                  CMatrix < _Int, _Flt > *pA_sub_temp = &pblk_arr[ind][0];
                  kkk = pnzblk_cpu[ind];
                  pA_sub_temp[kkk].ReplaceFree (pA_sub[k]);
                  ppblknum[kkk * 4] = iblk;
                  ppblknum[kkk * 4 + 1] = ihblk;
                  ppblknum[kkk * 4 + 2] = jj;
                  ppblknum[kkk * 4 + 3] = jj2;
                  pnzblk_cpu[ind]++;
               }
            }
         }
      }

      hblks_send_temp.resize (nlistcpu + 1);
      phblks_send_temp = &hblks_send_temp[0];

      for (i = 0; i < nlistcpu; i++) {

         int *ppblknum = &pblknum_arr[i][0];
         CMatrix < _Int, _Flt > *ppblk_arr = &pblk_arr[i][0];

// Compute block sparsity

         icycleblk++;

         nlistblk = 0;

         for (j = 0; j < pnzblk_cpu[i]; j++) {
            iblk = ppblknum[j * 4];
            ihblk = ppblknum[j * 4 + 1];
            iblkgl = _hblk2blk_ini[ihblk] + iblk;
            if (pimaskblk[iblkgl] != icycleblk) {
               plistblk[nlistblk] = iblkgl;
               plist2blk[nlistblk] = ihblk;
               nlistblk++;
               pimaskblk[iblkgl] = icycleblk;
            }
         }

         vector < CSortInt > iiarr (nlistblk + 1);
         CSortInt *piiarr = &iiarr[0];

         for (j = 0; j < nlistblk; j++) {
            piiarr[j].ival = plistblk[j];
            piiarr[j].i2val = j;
         }

         sort (piiarr, piiarr + nlistblk);

         for (j = 0; j < nlistblk; j++) {
            plistblk[j] = piiarr[j].ival;
            ind = piiarr[j].i2val;
            pindblk[j] = plist2blk[ind];
         }

         for (j = 0; j < nlistblk; j++)
            plist2blk[j] = pindblk[j];

         for (j = 0; j < nlistblk; j++) {
            ind = plistblk[j];
            pindblk[ind] = j;
         }

         phblks_send_temp[i].SetNzblk (pnzblk_cpu[i]);
         phblks_send_temp[i].ResizeASub (pnzblk_cpu[i]);

         CMatrix < int, float >*phmatr_send = phblks_send_temp[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub_send = phblks_send_temp[i].GetASubArr ();

         phmatr_send->ResizeAndSetAllSp (nlistblk, nlistblk, pnzblk_cpu[i],
                                         pnzblk_cpu[i]);

         int *plist_send = phmatr_send->GetListArr ();
         int *plist2_send = phmatr_send->GetList2Arr ();
         int *pia_send = phmatr_send->GetIaArr ();
         int *pja_send = phmatr_send->GetJaArr ();
         int *pja2_send = phmatr_send->GetJa2Arr ();

         for (j = 0; j < nlistblk; j++) {
            jblkgl = plistblk[j];
            jj2 = plist2blk[j];
            plist_send[j] = jblkgl - _hblk2blk_ini[jj2];
            plist2_send[j] = jj2;
         }

         for (j = 0; j <= nlistblk; j++)
            pia_send[j] = 0;

         for (j = 0; j < pnzblk_cpu[i]; j++) {
            iblk = ppblknum[j * 4];
            ihblk = ppblknum[j * 4 + 1];
            iblkgl = _hblk2blk_ini[ihblk] + iblk;
            ind = pindblk[iblkgl];
            pia_send[ind + 1]++;
         }

         for (j = 0; j < nlistblk; j++)
            pia_send[j + 1] = pia_send[j] + pia_send[j + 1];

         vector < int >iptr (nlistblk + 1);
         int *piptr = &iptr[0];

         for (j = 0; j < nlistblk; j++)
            piptr[j] = pia_send[j];

         for (j = 0; j < pnzblk_cpu[i]; j++) {
            iblk = ppblknum[j * 4];
            ihblk = ppblknum[j * 4 + 1];
            iblkgl = _hblk2blk_ini[ihblk] + iblk;
            ind = pindblk[iblkgl];
            k = piptr[ind];
            pja_send[k] = ppblknum[j * 4 + 2];
            pja2_send[k] = ppblknum[j * 4 + 3];
            pA_sub_send[k].ReplaceFree (ppblk_arr[j]);
            piptr[ind]++;
         }

      }

// Send outer data to another CPU's

      hblk_send_own.Clean ();

      hblks_send.resize (nlistcpu + 1);
      phblks_send = &hblks_send[0];

      nlistcpu_new = 0;

      for (i = 0; i < nlistcpu; i++) {
         if (plistcpu[i] == myid) {
            hblk_send_own.ReplaceFree (phblks_send_temp[i]);
         } else {
            phblks_send[nlistcpu_new].ReplaceFree (phblks_send_temp[i]);
            plistcpu[nlistcpu_new] = plistcpu[i];
            nlistcpu_new++;
         }
      }

      nlistcpu = nlistcpu_new;

// Pack send data

      CpuIDSend.resize (nlistcpu);
      ObjSend.resize (nlistcpu);

      pCpuIDSend = NULL;
      pObjSend = NULL;

      if (nlistcpu > 0) {
         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];
      }

      for (i = 0; i < nlistcpu; i++) {
         pCpuIDSend[i] = plistcpu[i];
         isize = phblks_send[i].GetPackedSize ();
         pObjSend[i].resize ((size_t) isize);
         pobj = &(pObjSend[i][0]);
         phblks_send[i].FillPacked_thr (isize, pobj);
         phblks_send[i].Clean ();
      }

// Exchange

      CpuIDRecv.resize (0);
      ObjRecv.resize (0);

      CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      nrecv = (int) CpuIDRecv.size ();

      pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      hblk_recv.resize (nrecv + 2);

      phblk_recv = &hblk_recv[0];

      for (i = 0; i < nrecv; i++) {
         isize = (long long) pObjRecv[i].size ();
         pobj = &(pObjRecv[i][0]);
         phblk_recv[i].UnPack_thr (isize, pobj);
      }

      phblk_recv[nrecv].ReplaceFree (hblk_send_own);

      nrecv++;

// Free recv data

      {
         vector < int >CpuIDRecv_temp;
         vector < vector < char > >ObjRecv_temp;
         CpuIDRecv.swap (CpuIDRecv_temp);
         ObjRecv.swap (ObjRecv_temp);
      }

// Create sets of blocks for block rows

      vector < int >nzblk_row (_nhblks + 1);
      blknum_arr.resize (_nhblks + 1);
      blk_arr.resize (_nhblks + 1);

      int *pnzblk_row = &nzblk_row[0];
      pblknum_arr = &blknum_arr[0];
      pblk_arr = &blk_arr[0];

      for (i = 0; i < _nhblks; i++)
         pnzblk_row[i] = 0;

      for (i = 0; i < nrecv; i++) {
         CMatrix < int, float >*phmatr = phblk_recv[i].GetHMatrStr ();
         int nlist_temp = phmatr->GetNlist ();
         int *plist_temp = phmatr->GetListArr ();
         int *plist2_temp = phmatr->GetList2Arr ();
         int *pia_temp = phmatr->GetIaArr ();
         for (j = 0; j < nlist_temp; j++) {
            iblk = plist_temp[j];
            ihblk = plist2_temp[j];
            pnzblk_row[ihblk] += (pia_temp[j + 1] - pia_temp[j]);
         }
      }

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {
            pblknum_arr[i].resize (4 * pnzblk_row[i] + 1);
            pblk_arr[i].resize (pnzblk_row[i] + 1);
         }
      }

      for (i = 0; i < _nhblks; i++)
         pnzblk_row[i] = 0;

      for (i = 0; i < nrecv; i++) {
         CMatrix < int, float >*phmatr = phblk_recv[i].GetHMatrStr ();
         CMatrix < _Int, _Flt > *pA_sub = phblk_recv[i].GetASubArr ();
         int nlist_temp = phmatr->GetNlist ();
         int *plist_temp = phmatr->GetListArr ();
         int *plist2_temp = phmatr->GetList2Arr ();
         int *pia_temp = phmatr->GetIaArr ();
         int *pja_temp = phmatr->GetJaArr ();
         int *pja2_temp = phmatr->GetJa2Arr ();
         for (j = 0; j < nlist_temp; j++) {
            iblk = plist_temp[j];
            ihblk = plist2_temp[j];
            for (k = pia_temp[j]; k < pia_temp[j + 1]; k++) {
               jj = pja_temp[k];
               jj2 = pja2_temp[k];
               int *ppblknum = &pblknum_arr[ihblk][0];
               CMatrix < _Int, _Flt > *pA_sub_temp = &pblk_arr[ihblk][0];
               kkk = pnzblk_row[ihblk];
               pA_sub_temp[kkk].ReplaceFree (pA_sub[k]);
               ppblknum[kkk * 4] = iblk;
               ppblknum[kkk * 4 + 1] = ihblk;
               ppblknum[kkk * 4 + 2] = jj;
               ppblknum[kkk * 4 + 3] = jj2;
               pnzblk_row[ihblk]++;
            }
         }
      }

// Combine all received data into the set of block columns

      vector < CBMatrix < _Int, _Flt > >hblk_rows (_nhblks + 1);
      CBMatrix < _Int, _Flt > *phblk_rows = &hblk_rows[0];

      for (i = 0; i < _nhblks; i++) {
         if (_hblk2cpu[i] == myid) {

            int *ppblknum = &pblknum_arr[i][0];
            CMatrix < _Int, _Flt > *ppblk_arr = &pblk_arr[i][0];

// Compute block sparsity

            icycleblk++;

            nlistblk = 0;

            for (j = 0; j < pnzblk_row[i]; j++) {
               iblk = ppblknum[j * 4];
               ihblk = ppblknum[j * 4 + 1];
               iblkgl = _hblk2blk_ini[ihblk] + iblk;
               if (pimaskblk[iblkgl] != icycleblk) {
                  plistblk[nlistblk] = iblkgl;
                  plist2blk[nlistblk] = ihblk;
                  nlistblk++;
                  pimaskblk[iblkgl] = icycleblk;
               }
            }

            vector < CSortInt > iiarr (nlistblk + 1);
            CSortInt *piiarr = &iiarr[0];

            for (j = 0; j < nlistblk; j++) {
               piiarr[j].ival = plistblk[j];
               piiarr[j].i2val = j;
            }

            sort (piiarr, piiarr + nlistblk);

            for (j = 0; j < nlistblk; j++) {
               plistblk[j] = piiarr[j].ival;
               ind = piiarr[j].i2val;
               pindblk[j] = plist2blk[ind];
            }

            for (j = 0; j < nlistblk; j++)
               plist2blk[j] = pindblk[j];

            for (j = 0; j < nlistblk; j++) {
               ind = plistblk[j];
               pindblk[ind] = j;
            }

            phblk_rows[i].SetNzblk (pnzblk_row[i]);
            phblk_rows[i].ResizeASub (pnzblk_row[i]);

            CMatrix < int, float >*phmatr_rows = phblk_rows[i].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pA_sub_rows = phblk_rows[i].GetASubArr ();

            phmatr_rows->ResizeAndSetAllSp (nlistblk, nlistblk, pnzblk_row[i],
                                            pnzblk_row[i]);

            int *plist_rows = phmatr_rows->GetListArr ();
            int *plist2_rows = phmatr_rows->GetList2Arr ();
            int *pia_rows = phmatr_rows->GetIaArr ();
            int *pja_rows = phmatr_rows->GetJaArr ();
            int *pja2_rows = phmatr_rows->GetJa2Arr ();

            for (j = 0; j < nlistblk; j++) {
               jblkgl = plistblk[j];
               jj2 = plist2blk[j];
               plist_rows[j] = jblkgl - _hblk2blk_ini[jj2];
               plist2_rows[j] = jj2;
            }

            for (j = 0; j <= nlistblk; j++)
               pia_rows[j] = 0;

            for (j = 0; j < pnzblk_row[i]; j++) {
               iblk = ppblknum[j * 4];
               ihblk = ppblknum[j * 4 + 1];
               iblkgl = _hblk2blk_ini[ihblk] + iblk;
               ind = pindblk[iblkgl];
               pia_rows[ind + 1]++;
            }

            for (j = 0; j < nlistblk; j++)
               pia_rows[j + 1] = pia_rows[j] + pia_rows[j + 1];

            vector < int >iptr (nlistblk + 1);
            int *piptr = &iptr[0];

            for (j = 0; j < nlistblk; j++)
               piptr[j] = pia_rows[j];

            for (j = 0; j < pnzblk_row[i]; j++) {
               iblk = ppblknum[j * 4];
               ihblk = ppblknum[j * 4 + 1];
               iblkgl = _hblk2blk_ini[ihblk] + iblk;
               ind = pindblk[iblkgl];
               k = piptr[ind];
               pja_rows[k] = ppblknum[j * 4 + 2];
               pja2_rows[k] = ppblknum[j * 4 + 3];
               pA_sub_rows[k].ReplaceFree (ppblk_arr[j]);
               piptr[ind]++;
            }
         }

      }

// Reorder rows data

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == myid) {

// Create list of column blocks

            CMatrix < int, float >*phmatr_rows = phblk_rows[ihblk].GetHMatrStr ();

            int nzja_rows = phmatr_rows->GetNzja ();
            int *pja_rows = phmatr_rows->GetJaArr ();
            int *pja2_rows = phmatr_rows->GetJa2Arr ();

            icycleblk++;

            nlistblk = 0;

            int jblk, jhblk, jblkgl;

            for (j = 0; j < nzja_rows; j++) {
               jblk = pja_rows[j];
               jhblk = pja2_rows[j];
               jblkgl = _hblk2blk_fin[jhblk] + jblk;
               if (pimaskblk[jblkgl] != icycleblk) {
                  plistblk[nlistblk] = jblkgl;
                  plist2blk[nlistblk] = jhblk;
                  nlistblk++;
                  pimaskblk[jblkgl] = icycleblk;
               }
            }

            vector < CSortInt > iiarr (nlistblk + 1);
            CSortInt *piiarr = &iiarr[0];

            for (j = 0; j < nlistblk; j++) {
               piiarr[j].ival = plistblk[j];
               piiarr[j].i2val = j;
            }

            sort (piiarr, piiarr + nlistblk);

            for (j = 0; j < nlistblk; j++) {
               plistblk[j] = piiarr[j].ival;
               ind = piiarr[j].i2val;
               pindblk[j] = plist2blk[ind];
            }

            for (j = 0; j < nlistblk; j++)
               plist2blk[j] = pindblk[j];

            for (j = 0; j < nlistblk; j++) {
               ind = plistblk[j];
               pindblk[ind] = j;
            }

            for (i = 0; i <= nlistblk; i++)
               pblksR_cnd[i] = 0;

            for (j = 0; j < nlistblk; j++) {
               ind = plistblk[j];
               pblksR_cnd[j + 1] = _blks_fin[ind + 1] - _blks_fin[ind];
            }

            for (i = 0; i < nlistblk; i++)
               pblksR_cnd[i + 1] = pblksR_cnd[i] + pblksR_cnd[i + 1];

            for (j = 0; j < nzja_rows; j++) {
               jblk = pja_rows[j];
               jhblk = pja2_rows[j];
               jblkgl = _hblk2blk_fin[jhblk] + jblk;
               ind = pindblk[jblkgl];
               pja_rows[j] = ind;
               pja2_rows[j] = 0;
            }

// Prepare blocks partitionings

            int ibegblk_ini = _hblk2blk_ini[ihblk];
            int ibegblk_fin = _hblk2blk_fin[ihblk];

            int nblksR_ini_loc = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
            int nblksR_fin_loc = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];

            for (i = ibegblk_ini; i < ibegblk_ini + nblksR_ini_loc + 1; i++)
               pblksC_ini_cnd[i - ibegblk_ini] = _blks_ini[i] - _blks_ini[ibegblk_ini];
            for (i = ibegblk_fin; i < ibegblk_fin + nblksR_fin_loc + 1; i++)
               pblksC_fin_cnd[i - ibegblk_fin] = _blks_fin[i] - _blks_fin[ibegblk_fin];

// Reorder rows

            int *porderR_loc = _order_diag[ihblk].Ptr ();

            CBMatrix < _Int, _Flt >::ReorderHMatrixRows_BxB (_blksize, nlistblk,
                                                             pblksR_cnd, nblksR_ini_loc,
                                                             pblksC_ini_cnd,
                                                             phblk_rows[ihblk],
                                                             porderR_loc, nblksR_fin_loc,
                                                             pblksC_fin_cnd,
                                                             _hmatr_arr_fin[ihblk]);

            CMatrix < int, float >*phmatr_temp = _hmatr_arr_fin[ihblk].GetHMatrStr ();

            int nlist_hblk_temp = phmatr_temp->GetNlist ();
            int nzja_hblk_temp = phmatr_temp->GetNzja ();
            int *plist2_hblk_temp = phmatr_temp->GetList2Arr ();
            int *pja_hblk_temp = phmatr_temp->GetJaArr ();
            int *pja2_hblk_temp = phmatr_temp->GetJa2Arr ();

            for (i = 0; i < nlist_hblk_temp; i++)
               plist2_hblk_temp[i] = ihblk;
            for (i = 0; i < nzja_hblk_temp; i++) {
               jblk = pja_hblk_temp[i];
               jblkgl = plistblk[jblk];
               jhblk = plist2blk[jblk];
               pja_hblk_temp[i] = plistblk[jblk] - _hblk2blk_fin[jhblk];
               pja2_hblk_temp[i] = jhblk;
            }

         }
      }

   }

// Compute comparison hmatrix for block hmatrix
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ComparisonHMatrix_BxB (int _blksize, CBMatrix < _Int, _Flt > &_hmatr_bxb,
                                     CBMatrix < _Int, _Flt > &_hmatr_pt)
   {

      CMatrix < int, float >*phmatr_bxb = _hmatr_bxb.GetHMatrStr ();
      CMatrix < int, float >*phmatr_pt = _hmatr_pt.GetHMatrStr ();

      *phmatr_pt = *phmatr_bxb;

      int nlist_hblk_temp = phmatr_pt->GetNlist ();
      int nzja_hblk_temp = phmatr_pt->GetNzja ();
      int *plist_hblk_temp = phmatr_pt->GetListArr ();
      int *plist2_hblk_temp = phmatr_pt->GetList2Arr ();
      int *pia_hblk_temp = phmatr_pt->GetIaArr ();
      int *pja_hblk_temp = phmatr_pt->GetJaArr ();
      int *pja2_hblk_temp = phmatr_pt->GetJa2Arr ();

      CMatrix < _Int, _Flt > *pasub_bxb = _hmatr_bxb.GetASubArr ();

      _hmatr_pt.ResizeASub (nzja_hblk_temp);
      _hmatr_pt.SetNzblk (nzja_hblk_temp);

      CMatrix < _Int, _Flt > *pasub_pt = _hmatr_pt.GetASubArr ();

      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nlist_hblk_temp; ipar++) {
            int iblk = plist_hblk_temp[ipar];
            int ihblk = plist2_hblk_temp[ipar];
            int j, jblk, jhblk;
            for (j = pia_hblk_temp[ipar]; j < pia_hblk_temp[ipar + 1]; j++) {
               jblk = pja_hblk_temp[j];
               jhblk = pja2_hblk_temp[j];
               if (iblk == jblk && ihblk == jhblk) {
                  CMatrix < _Int, _Flt >::ComparisonMatrix_BxB ('D', _blksize,
                                                                pasub_bxb[j],
                                                                pasub_pt[j]);
               } else {
                  CMatrix < _Int, _Flt >::ComparisonMatrix_BxB ('O', _blksize,
                                                                pasub_bxb[j],
                                                                pasub_pt[j]);
               }
            }
         }

      }

   }

// Compute block diagonal matrix
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::BlockDiagonalHMatrix_BxB (int _blksize, int _nblks, long long *_blks,
                                        _Flt * _diag_data, CBMatrix < _Int,
                                        _Flt > &_hmatr_diag)
   {

      int b_2 = _blksize * _blksize;

      CMatrix < int, float >*phmatr_diag = _hmatr_diag.GetHMatrStr ();

      phmatr_diag->ResizeAndSetAllSp (_nblks, _nblks, _nblks, _nblks);

      int *plist_hmatr = phmatr_diag->GetListArr ();
      int *plist2_hmatr = phmatr_diag->GetList2Arr ();
      int *pia_hmatr = phmatr_diag->GetIaArr ();
      int *pja_hmatr = phmatr_diag->GetJaArr ();
      int *pja2_hmatr = phmatr_diag->GetJa2Arr ();

      {
         int i;
         for (i = 0; i < _nblks; i++) {
            plist_hmatr[i] = i;
            plist2_hmatr[i] = 0;
            pja_hmatr[i] = i;
            pja2_hmatr[i] = 0;
         }
         for (i = 0; i <= _nblks; i++)
            pia_hmatr[i] = i;
      }

      _hmatr_diag.SetNzblk (_nblks);
      _hmatr_diag.ResizeASub (_nblks);

      CMatrix < _Int, _Flt > *pASub_diag = _hmatr_diag.GetASubArr ();

      {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < _nblks; ipar++) {
            int niloc = (int) (_blks[ipar + 1] - _blks[ipar]);
            pASub_diag[ipar].ResizeAndSetAll (niloc, 0, niloc, 0, niloc * b_2);
            _Int *plist_temp = pASub_diag[ipar].GetListArr ();
            _Int *pia_temp = pASub_diag[ipar].GetIaArr ();
            _Int *pja_temp = pASub_diag[ipar].GetJaArr ();
            _Flt *pa_temp = pASub_diag[ipar].GetAArr ();
            int i;
            for (i = 0; i < niloc; i++)
               plist_temp[i] = (_Int) i;
            for (i = 0; i <= niloc; i++)
               pia_temp[i] = (_Int) i;
            for (i = 0; i < niloc; i++)
               pja_temp[i] = (_Int) i;
            int ishift = (int) _blks[ipar];
            memcpy (pa_temp, _diag_data + ishift * b_2, sizeof (_Flt) * niloc * b_2);
         }
      }

   }

// Compute inverse order
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::InverseOrder (void *_comm, int _nhblks_ini, int *_hblk2cpu_ini,
                            int *_hblk2blk_ini, long long *_blks_ini, long long *_order,
                            int _nhblks_fin, int *_hblk2cpu_fin, int *_hblk2blk_fin,
                            long long *_blks_fin, CVectorData < long long >&_iorder)
   {

      int myid = CMPIDataExchange::GetMyid (_comm);

// Create distributed identity array as hmatrix

      vector < CBMatrix < _Int, double > >hmatr_id_arr (_nhblks_ini + 1);
      CBMatrix < _Int, double >*phmatr_id_arr = &hmatr_id_arr[0];

      {
         int i;
         for (i = 0; i < _nhblks_ini; i++) {
            if (_hblk2cpu_ini[i] == myid) {
               int nblks_loc = _hblk2blk_ini[i + 1] - _hblk2blk_ini[i];
               CMatrix < int, float >*phmatr_str = phmatr_id_arr[i].GetHMatrStr ();
               phmatr_str->ResizeAndSetAllSp (nblks_loc, nblks_loc, nblks_loc, nblks_loc);
               int *plist_hmatr = phmatr_str->GetListArr ();
               int *plist2_hmatr = phmatr_str->GetList2Arr ();
               int *pia_hmatr = phmatr_str->GetIaArr ();
               int *pja_hmatr = phmatr_str->GetJaArr ();
               int *pja2_hmatr = phmatr_str->GetJa2Arr ();
               {
                  int j;
                  for (j = 0; j < nblks_loc; j++)
                     plist_hmatr[j] = j;
                  for (j = 0; j < nblks_loc; j++)
                     plist2_hmatr[j] = i;
                  for (j = 0; j <= nblks_loc; j++)
                     pia_hmatr[j] = j;
                  for (j = 0; j < nblks_loc; j++)
                     pja_hmatr[j] = j;
                  for (j = 0; j < nblks_loc; j++)
                     pja2_hmatr[j] = i;
               }
               phmatr_id_arr[i].ResizeASub (nblks_loc);
               phmatr_id_arr[i].SetNzblk (nblks_loc);
               CMatrix < _Int, double >*pASub = phmatr_id_arr[i].GetASubArr ();

               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < nblks_loc; ipar++) {
                     int iblk = _hblk2blk_ini[i] + ipar;
                     int niloc = (int) (_blks_ini[iblk + 1] - _blks_ini[iblk]);
                     long long ishift = _blks_ini[iblk];
                     pASub[ipar].ResizeAndSetAll (niloc, 0, niloc, 0, niloc);
                     _Int *plist_temp = pASub[ipar].GetListArr ();
                     _Int *pia_temp = pASub[ipar].GetIaArr ();
                     _Int *pja_temp = pASub[ipar].GetJaArr ();
                     double *pa_temp = pASub[ipar].GetAArr ();
                     long long *pa_long = (long long *) pa_temp;
                     int k;
                     for (k = 0; k < niloc; k++)
                        plist_temp[k] = k;
                     for (k = 0; k <= niloc; k++)
                        pia_temp[k] = k;
                     for (k = 0; k < niloc; k++)
                        pja_temp[k] = k;
                     for (k = 0; k < niloc; k++)
                        pa_long[k] = ishift + k;
                  }
               }

            }
         }
      }

// Compute inverse order

      vector < CBMatrix < _Int, double > >hmatr_iorder_arr (_nhblks_fin + 1);
      CBMatrix < _Int, double >*phmatr_iorder_arr = &hmatr_iorder_arr[0];

      CBMatrix < _Int, double >::ReorderHMatrix (_comm, _nhblks_ini, _hblk2cpu_ini,
                                                 _hblk2blk_ini, _blks_ini, phmatr_id_arr,
                                                 _order, _nhblks_fin, _hblk2cpu_fin,
                                                 _hblk2blk_fin, _blks_fin,
                                                 phmatr_iorder_arr);

      long long ntot_myid = 0;

      {
         int i;
         for (i = 0; i < _nhblks_fin; i++) {
            if (_hblk2cpu_fin[i] == myid) {
               int ibegblk = _hblk2blk_fin[i];
               int iendblk = _hblk2blk_fin[i + 1] - 1;
               int ni_loc = (int) (_blks_fin[iendblk + 1] - _blks_fin[ibegblk]);
               ntot_myid += ni_loc;
            }
         }
      }

      _iorder.resize ((int) ntot_myid);
      long long *piorder = _iorder.Ptr ();

      ntot_myid = 0;

      {
         int i;
         for (i = 0; i < _nhblks_fin; i++) {
            if (_hblk2cpu_fin[i] == myid) {
               int nblks_loc = _hblk2blk_fin[i + 1] - _hblk2blk_fin[i];
               int ibegblk = _hblk2blk_fin[i];
               int iendblk = _hblk2blk_fin[i + 1] - 1;
               CMatrix < _Int, double >*pASub = phmatr_iorder_arr[i].GetASubArr ();

               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < nblks_loc; ipar++) {
                     int iblk = _hblk2blk_fin[i] + ipar;
                     int nj_loc = (int) (_blks_fin[iblk + 1] - _blks_fin[iblk]);
                     int ibs = (int) (_blks_fin[iblk] - _blks_fin[ibegblk]);
                     int k;
                     double *pa_temp = pASub[ipar].GetAArr ();
                     long long *pa_long = (long long *) pa_temp;
                     for (k = 0; k < nj_loc; k++)
                        piorder[ntot_myid + ibs + k] = pa_long[k];
                  }
               }

               int ni_loc = (int) (_blks_fin[iendblk + 1] - _blks_fin[ibegblk]);
               ntot_myid += ni_loc;
            }
         }
      }

   }

// Compute inverse order (local hblock diagonal ordering)
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::InverseOrderDiag (void *_comm, int _nhblks_ini, int *_hblk2cpu_ini,
                                int *_hblk2blk_ini, long long *_blks_ini,
                                CVectorData < int >*_order_diag, int _nhblks_fin,
                                int *_hblk2cpu_fin, int *_hblk2blk_fin,
                                long long *_blks_fin, CVectorData < long long >&_iorder)
   {

      int myid = CMPIDataExchange::GetMyid (_comm);

// Create distributed identity array as hmatrix

      vector < CBMatrix < _Int, double > >hmatr_id_arr (_nhblks_ini + 1);
      CBMatrix < _Int, double >*phmatr_id_arr = &hmatr_id_arr[0];

      {
         int i;
         for (i = 0; i < _nhblks_ini; i++) {
            if (_hblk2cpu_ini[i] == myid) {
               int nblks_loc = _hblk2blk_ini[i + 1] - _hblk2blk_ini[i];
               CMatrix < int, float >*phmatr_str = phmatr_id_arr[i].GetHMatrStr ();
               phmatr_str->ResizeAndSetAllSp (nblks_loc, nblks_loc, nblks_loc, nblks_loc);
               int *plist_hmatr = phmatr_str->GetListArr ();
               int *plist2_hmatr = phmatr_str->GetList2Arr ();
               int *pia_hmatr = phmatr_str->GetIaArr ();
               int *pja_hmatr = phmatr_str->GetJaArr ();
               int *pja2_hmatr = phmatr_str->GetJa2Arr ();
               {
                  int j;
                  for (j = 0; j < nblks_loc; j++)
                     plist_hmatr[j] = j;
                  for (j = 0; j < nblks_loc; j++)
                     plist2_hmatr[j] = i;
                  for (j = 0; j <= nblks_loc; j++)
                     pia_hmatr[j] = j;
                  for (j = 0; j < nblks_loc; j++)
                     pja_hmatr[j] = j;
                  for (j = 0; j < nblks_loc; j++)
                     pja2_hmatr[j] = i;
               }
               phmatr_id_arr[i].ResizeASub (nblks_loc);
               phmatr_id_arr[i].SetNzblk (nblks_loc);
               CMatrix < _Int, double >*pASub = phmatr_id_arr[i].GetASubArr ();

               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < nblks_loc; ipar++) {
                     int iblk = _hblk2blk_ini[i] + ipar;
                     int niloc = (int) (_blks_ini[iblk + 1] - _blks_ini[iblk]);
                     long long ishift = _blks_ini[iblk];
                     pASub[ipar].ResizeAndSetAll (niloc, 0, niloc, 0, niloc);
                     _Int *plist_temp = pASub[ipar].GetListArr ();
                     _Int *pia_temp = pASub[ipar].GetIaArr ();
                     _Int *pja_temp = pASub[ipar].GetJaArr ();
                     double *pa_temp = pASub[ipar].GetAArr ();
                     long long *pa_long = (long long *) pa_temp;
                     int k;
                     for (k = 0; k < niloc; k++)
                        plist_temp[k] = k;
                     for (k = 0; k <= niloc; k++)
                        pia_temp[k] = k;
                     for (k = 0; k < niloc; k++)
                        pja_temp[k] = k;
                     for (k = 0; k < niloc; k++)
                        pa_long[k] = ishift + k;
                  }
               }

            }
         }
      }

// Compute inverse order

      int nblks_ini = _hblk2blk_ini[_nhblks_ini];
      int nblks_fin = _hblk2blk_fin[_nhblks_fin];

      vector < CBMatrix < _Int, double > >hmatr_iorder_arr (_nhblks_fin + 1);
      CBMatrix < _Int, double >*phmatr_iorder_arr = &hmatr_iorder_arr[0];

      CBMatrix < _Int, double >::ReorderHMatrixDiag (_comm, _nhblks_ini, _hblk2cpu_ini,
                                                     _hblk2blk_ini, nblks_ini, _blks_ini,
                                                     phmatr_id_arr, _order_diag,
                                                     _hblk2blk_fin, nblks_fin, _blks_fin,
                                                     phmatr_iorder_arr);

      long long ntot_myid = 0;

      {
         int i;
         for (i = 0; i < _nhblks_fin; i++) {
            if (_hblk2cpu_fin[i] == myid) {
               int ibegblk = _hblk2blk_fin[i];
               int iendblk = _hblk2blk_fin[i + 1] - 1;
               int ni_loc = (int) (_blks_fin[iendblk + 1] - _blks_fin[ibegblk]);
               ntot_myid += ni_loc;
            }
         }
      }

      _iorder.resize ((int) ntot_myid);
      long long *piorder = _iorder.Ptr ();

      ntot_myid = 0;

      {
         int i;
         for (i = 0; i < _nhblks_fin; i++) {
            if (_hblk2cpu_fin[i] == myid) {
               int nblks_loc = _hblk2blk_fin[i + 1] - _hblk2blk_fin[i];
               int ibegblk = _hblk2blk_fin[i];
               int iendblk = _hblk2blk_fin[i + 1] - 1;
               CMatrix < _Int, double >*pASub = phmatr_iorder_arr[i].GetASubArr ();

               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < nblks_loc; ipar++) {
                     int iblk = _hblk2blk_fin[i] + ipar;
                     int nj_loc = (int) (_blks_fin[iblk + 1] - _blks_fin[iblk]);
                     int ibs = (int) (_blks_fin[iblk] - _blks_fin[ibegblk]);
                     int k;
                     double *pa_temp = pASub[ipar].GetAArr ();
                     long long *pa_long = (long long *) pa_temp;
                     for (k = 0; k < nj_loc; k++)
                        piorder[ntot_myid + ibs + k] = pa_long[k];
                  }
               }

               int ni_loc = (int) (_blks_fin[iendblk + 1] - _blks_fin[ibegblk]);
               ntot_myid += ni_loc;
            }
         }
      }

   }

// Compute reordered sparsity hmatrix
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ReorderHMatrixSp (void *_comm, int _nhblks_ini, int *_hblk2cpu_ini,
                                int *_hblk2blk_ini, long long *_blks_ini, CBMatrix < _Int,
                                _Flt > *_hmatr_arr_ini, long long *_order,
                                int _nhblks_fin, int *_hblk2cpu_fin, int *_hblk2blk_fin,
                                long long *_blks_fin, CBMatrix < _Int,
                                _Flt > *_hmatr_arr_fin)
   {

      int myid = CMPIDataExchange::GetMyid (_comm);
      int nproc = CMPIDataExchange::GetNproc (_comm);

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

// Compute new 3index for all ordering data

      CVectorData < int >ibs_hblk (_nhblks_ini);
      int *pibs_hblk = ibs_hblk.Ptr ();

      int ni_order_ini = 0;

      {
         int ihblk, ibegblk, iendblk;
         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            pibs_hblk[ihblk] = -1;
            if (_hblk2cpu_ini[ihblk] == myid) {
               pibs_hblk[ihblk] = ni_order_ini;
               ibegblk = _hblk2blk_ini[ihblk];
               iendblk = _hblk2blk_ini[ihblk + 1] - 1;
               ni_order_ini += (int) (_blks_ini[iendblk + 1] - _blks_ini[ibegblk]);
            }
         }
      }

      CVectorData < int >order_3index (ni_order_ini * 3);
      int *porder_3index = order_3index.Ptr ();

      {
         int nblks_fin = _hblk2blk_fin[_nhblks_fin];
         CVectorData < int >blk2hblk_fin (nblks_fin);
         int *pblk2hblk_fin = blk2hblk_fin.Ptr ();
         {
            int i, j;
            for (i = 0; i < _nhblks_fin; i++) {
               for (j = _hblk2blk_fin[i]; j < _hblk2blk_fin[i + 1]; j++) {
                  pblk2hblk_fin[j] = i;
               }
            }
         }
         int nparts_split = 4 * n_thr;
         int ni_part = ni_order_ini / nparts_split;
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nparts_split; ipar++) {
            int ibeg = ni_part * ipar;
            int iend = ni_part * (ipar + 1) - 1;
            if (ipar == nparts_split - 1)
               iend = ni_order_ini - 1;
            int niloc = iend - ibeg + 1;
            CVectorData < CSortInt64 > iiarr (niloc);
            CSortInt64 *piiarr = iiarr.Ptr ();
            int i;
            for (i = 0; i < niloc; i++) {
               piiarr[i].ival = _order[ibeg + i];
               piiarr[i].i2val = i;
            }
            sort (piiarr, piiarr + niloc);
            CVectorData < long long >order_sort (niloc);
            long long *porder_sort = order_sort.Ptr ();
            for (i = 0; i < niloc; i++)
               porder_sort[i] = piiarr[i].ival;
            CVectorData < long long >blknum_arr (niloc);
            CVectorData < int >hblknum_arr (niloc);
            long long *pblknum_arr = blknum_arr.Ptr ();
            long long ia_temp[2];
            ia_temp[0] = 0;
            ia_temp[1] = (_Int) niloc;
            CBMatrix < long long, float >::ComputeJa2 (nblks_fin, _blks_fin, 1, ia_temp,
                                                       porder_sort, pblknum_arr);
            long long jj;
            int jblk, jhblk, iold;
            for (i = 0; i < niloc; i++) {
               iold = (int) piiarr[i].i2val;
               jj = porder_sort[i];
               jblk = (int) pblknum_arr[i];
               jhblk = pblk2hblk_fin[jblk];
               jj = jj - _blks_fin[jblk];
               porder_3index[(ibeg + iold) * 3] = (int) jj;
               porder_3index[(ibeg + iold) * 3 + 1] = jblk - _hblk2blk_fin[jhblk];
               porder_3index[(ibeg + iold) * 3 + 2] = jhblk;
            }
         }
      }

// Compute transposed block sparsities

      CVectorData < CMatrix < int, float > >str_hblkT_arr (_nhblks_ini);
      CMatrix < int, float >*pstr_hblkT_arr = str_hblkT_arr.Ptr ();

      CVectorData < CVectorData < int > >indT2N_arr (_nhblks_ini);
      CVectorData < int >*pindT2N_arr = indT2N_arr.Ptr ();

      {

         int nblks_ini = _hblk2blk_ini[_nhblks_ini];

         CVectorData < int >blk2hblk_ini (nblks_ini);
         int *pblk2hblk_ini = blk2hblk_ini.Ptr ();

         {
            for (int i = 0; i < _nhblks_ini; i++) {
               for (int j = _hblk2blk_ini[i]; j < _hblk2blk_ini[i + 1]; j++) {
                  pblk2hblk_ini[j] = i;
               }
            }
         }

         CVectorData < int >imaskblk (nblks_ini * 5 + 1);
         int *pimaskblk = imaskblk.Ptr ();

         int ihblk;

         for (ihblk = 0; ihblk < nblks_ini; ihblk++)
            pimaskblk[ihblk] = -1;

         int icycleblk = -1;

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {

               CMatrix < int, float >*phmatr = _hmatr_arr_ini[ihblk].GetHMatrStr ();

               CMatrix < int, float >str_hblk;
               str_hblk = *phmatr;

// Transform to 1 index

               int nlist_temp = str_hblk.GetNlist ();
               int nzja_temp = str_hblk.GetNzja ();
               int *plist_temp = str_hblk.GetListArr ();
               int *plist2_temp = str_hblk.GetList2Arr ();
               int *pia_temp = str_hblk.GetIaArr ();
               int *pja_temp = str_hblk.GetJaArr ();
               int *pja2_temp = str_hblk.GetJa2Arr ();

               int i, jblk, jhblk;

               for (i = 0; i < nlist_temp; i++) {
                  jblk = plist_temp[i];
                  jhblk = plist2_temp[i];
                  plist_temp[i] = _hblk2blk_ini[jhblk] + jblk;
               }
               for (i = 0; i < nzja_temp; i++) {
                  jblk = pja_temp[i];
                  jhblk = pja2_temp[i];
                  pja_temp[i] = _hblk2blk_ini[jhblk] + jblk;
               }

               str_hblk.SetNlist2 (0);
               str_hblk.SetNzja2 (0);

// Transpose

               CMatrix < int, float >str_hblkT;

               str_hblk.TransposedSparsityListSp (icycleblk, pimaskblk,
                                                  pimaskblk + nblks_ini,
                                                  pimaskblk + nblks_ini * 2,
                                                  pimaskblk + nblks_ini * 3,
                                                  pimaskblk + nblks_ini * 4, str_hblkT);

               int nlist_tempT = str_hblkT.GetNlist ();
               int nzja_tempT = str_hblkT.GetNzja ();
               int *pia_tempT = str_hblkT.GetIaArr ();
               int *pja_tempT = str_hblkT.GetJaArr ();

// Compute transposed reference

               int ibeghblk = _hblk2blk_ini[ihblk];

               pindT2N_arr[ihblk].resize (nzja_tempT);
               int *ppindT2N_arr = pindT2N_arr[ihblk].Ptr ();

               for (i = 0; i < nlist_temp; i++) {
                  pimaskblk[nblks_ini + i] = pia_temp[i];
               }

               int j, jj, k;

               for (i = 0; i < nlist_tempT; i++) {
                  for (j = pia_tempT[i]; j < pia_tempT[i + 1]; j++) {
                     jj = pja_tempT[j] - ibeghblk;
                     k = pimaskblk[nblks_ini + jj];
                     ppindT2N_arr[j] = k;
                     pimaskblk[nblks_ini + jj]++;
                  }
               }

// Modify second index

               str_hblkT.ResizeList2 (nlist_tempT);
               str_hblkT.ResizeJa2 (nzja_tempT);
               str_hblkT.SetNlist2 (nlist_tempT);
               str_hblkT.SetNzja2 (nzja_tempT);

               plist_temp = str_hblkT.GetListArr ();
               plist2_temp = str_hblkT.GetList2Arr ();
               pja_temp = str_hblkT.GetJaArr ();
               pja2_temp = str_hblkT.GetJa2Arr ();

               for (i = 0; i < nlist_tempT; i++) {
                  jblk = plist_temp[i];
                  jhblk = pblk2hblk_ini[jblk];
                  plist_temp[i] = jblk - _hblk2blk_ini[jhblk];
                  plist2_temp[i] = jhblk;
               }
               for (i = 0; i < nzja_tempT; i++) {
                  jblk = pja_temp[i];
                  jhblk = pblk2hblk_ini[jblk];
                  pja_temp[i] = jblk - _hblk2blk_ini[jhblk];
                  pja2_temp[i] = jhblk;
               }

               pstr_hblkT_arr[ihblk].ReplaceFree (str_hblkT);

            }
         }

      }

// Compute column lists for all hblock off-diagonal blocks

      CVectorData < CBMatrix < int, float > >str_cols_arr (_nhblks_ini);
      CBMatrix < int, float >*pstr_cols_arr = str_cols_arr.Ptr ();

      {

         int nblks_ini = _hblk2blk_ini[_nhblks_ini];

         int ihblk;

         int nimax = 0;

         {
            for (int i = 0; i < nblks_ini; i++) {
               int niloc = (int) (_blks_ini[i + 1] - _blks_ini[i]);
               if (niloc > nimax)
                  nimax = niloc;
            }
         }

         CVectorData < int >imask_threads (nimax * 2 * n_thr + 1);
         CVectorData < int >icycle_threads (n_thr + 1);

         int *pimask_threads = imask_threads.Ptr ();
         int *picycle_threads = icycle_threads.Ptr ();

         for (ihblk = 0; ihblk < n_thr; ihblk++)
            picycle_threads[ihblk] = -1;

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {

// Local column sparsity

               CMatrix < _Int, _Flt > *pASub = _hmatr_arr_ini[ihblk].GetASubArr ();
               CMatrix < int, float >*phmatr = _hmatr_arr_ini[ihblk].GetHMatrStr ();

               int nzja_temp = phmatr->GetNzja ();
               int *pja2_temp = phmatr->GetJa2Arr ();

               {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < nzja_temp; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif
                     if (pja2_temp[ipar] != ihblk) {

                        int *pimask_th = pimask_threads + 2 * nimax * my_thr;
                        int icycle_th = picycle_threads[my_thr];

                        if (icycle_th == -1) {
                           for (int j = 0; j < nimax; j++)
                              pimask_th[j] = -1;
                        }

                        icycle_th++;

                        pASub[ipar].ComputeList2 (icycle_th, pimask_th,
                                                  pimask_th + nimax);

                        picycle_threads[my_thr] = icycle_th;
                     }
                  }

               }

// Add column sparsity in block columns

               int nlistT_hblk = pstr_hblkT_arr[ihblk].GetNlist ();
               int *plistT_hblk = pstr_hblkT_arr[ihblk].GetListArr ();
               int *plist2T_hblk = pstr_hblkT_arr[ihblk].GetList2Arr ();
               int *piaT_hblk = pstr_hblkT_arr[ihblk].GetIaArr ();

               int nlistblk_off = 0;

               {
                  int jhblk;
                  for (int i = 0; i < nlistT_hblk; i++) {
                     jhblk = plist2T_hblk[i];
                     if (jhblk != ihblk)
                        nlistblk_off++;
                  }
               }

               pstr_cols_arr[ihblk].SetNzblk (nlistblk_off);
               pstr_cols_arr[ihblk].ResizeASub (nlistblk_off);

               CMatrix < int, float >*pASub_cols = pstr_cols_arr[ihblk].GetASubArr ();
               CMatrix < int, float >*phmatr_cols = pstr_cols_arr[ihblk].GetHMatrStr ();

               phmatr_cols->ResizeAndSetAllSp (nlistblk_off, nlistblk_off, nlistblk_off,
                                               nlistblk_off);

               int *plist_cols = phmatr_cols->GetListArr ();
               int *plist2_cols = phmatr_cols->GetList2Arr ();
               int *pia_cols = phmatr_cols->GetIaArr ();
               int *pja_cols = phmatr_cols->GetJaArr ();
               int *pja2_cols = phmatr_cols->GetJa2Arr ();

               {
                  for (int i = 0; i <= nlistblk_off; i++)
                     pia_cols[i] = i;
               }

               CVectorData < int >indblk (nlistblk_off);
               int *pindblk = indblk.Ptr ();

               nlistblk_off = 0;

               int *ppindT2N_arr = pindT2N_arr[ihblk].Ptr ();

               {
                  int jblk, jhblk;
                  for (int i = 0; i < nlistT_hblk; i++) {
                     jblk = plistT_hblk[i];
                     jhblk = plist2T_hblk[i];
                     if (jhblk != ihblk) {
                        pindblk[nlistblk_off] = i;
                        plist_cols[nlistblk_off] = i;
                        plist2_cols[nlistblk_off] = ihblk;
                        pja_cols[nlistblk_off] = jblk;
                        pja2_cols[nlistblk_off] = jhblk;
                        nlistblk_off++;
                     }
                  }
               }

               {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < nlistblk_off; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif

                     int *pimask_th = pimask_threads + 2 * nimax * my_thr;
                     int *plist_th = pimask_th + nimax;
                     int icycle_th = picycle_threads[my_thr];

                     if (icycle_th == -1) {
                        for (int j = 0; j < nimax; j++)
                           pimask_th[j] = -1;
                     }

                     icycle_th++;

                     int ind = pindblk[ipar];

                     int i, indj, j, jj;

                     int nlistloc = 0;

                     for (i = piaT_hblk[ind]; i < piaT_hblk[ind + 1]; i++) {
                        indj = ppindT2N_arr[i];
                        int nlist2_temp = pASub[indj].GetNlist2 ();
                        _Int *plist2_temp = pASub[indj].GetList2Arr ();
                        for (j = 0; j < nlist2_temp; j++) {
                           jj = (int) plist2_temp[j];
                           if (pimask_th[jj] != icycle_th) {
                              pimask_th[jj] = icycle_th;
                              plist_th[nlistloc] = jj;
                              nlistloc++;
                           }
                        }
                     }

                     sort (plist_th, plist_th + nlistloc);

                     pASub_cols[ipar].ResizeList2 (nlistloc);
                     pASub_cols[ipar].SetNlist2 (nlistloc);

                     int *plist2_new = pASub_cols[ipar].GetList2Arr ();

                     for (i = 0; i < nlistloc; i++)
                        plist2_new[i] = plist_th[i];

                     picycle_threads[my_thr] = icycle_th;

                  }
               }

            }
         }

      }

// Prepare send data

      vector < int >listcpu (nproc + 1);
      int *plistcpu = &listcpu[0];

      int nlistcpu = 0;

      CVectorData < CBMatrix < int, float > >hblk_send;

      {

         int i;

         vector < int >imaskcpu (nproc + 1);
         int *pimaskcpu = &imaskcpu[0];

         for (i = 0; i < nproc; i++)
            pimaskcpu[i] = -1;

         int j, jj2, jproc;

         for (i = 0; i < _nhblks_ini; i++) {
            if (_hblk2cpu_ini[i] == myid) {
               CMatrix < int, float >*phmatr = pstr_cols_arr[i].GetHMatrStr ();
               int nzja_temp = phmatr->GetNzja ();
               int *pja2_temp = phmatr->GetJa2Arr ();
               for (j = 0; j < nzja_temp; j++) {
                  jj2 = pja2_temp[j];
                  jproc = _hblk2cpu_ini[jj2];
                  if (pimaskcpu[jproc] < 0) {
                     plistcpu[nlistcpu] = jproc;
                     nlistcpu++;
                     pimaskcpu[jproc] = 1;
                  }
               }
            }
         }

         sort (plistcpu, plistcpu + nlistcpu);

         for (i = 0; i < nlistcpu; i++) {
            j = plistcpu[i];
            pimaskcpu[j] = i;
         }

         vector < int >nzblk_cpu (nlistcpu + 1);
         int *pnzblk_cpu = &nzblk_cpu[0];

         for (i = 0; i < nlistcpu; i++)
            pnzblk_cpu[i] = 0;

         int ind;

         for (i = 0; i < _nhblks_ini; i++) {
            if (_hblk2cpu_ini[i] == myid) {
               CMatrix < int, float >*phmatr = pstr_cols_arr[i].GetHMatrStr ();
               int nzja_temp = phmatr->GetNzja ();
               int *pja2_temp = phmatr->GetJa2Arr ();
               for (j = 0; j < nzja_temp; j++) {
                  jj2 = pja2_temp[j];
                  jproc = _hblk2cpu_ini[jj2];
                  ind = pimaskcpu[jproc];
                  pnzblk_cpu[ind]++;
               }
            }
         }

         hblk_send.resize (nlistcpu);

         CBMatrix < int, float >*phblk_send = hblk_send.Ptr ();

         for (i = 0; i < nlistcpu; i++) {
            phblk_send[i].ResizeASub (pnzblk_cpu[i]);
            phblk_send[i].SetNzblk (pnzblk_cpu[i]);
            CMatrix < int, float >*phmatr = phblk_send[i].GetHMatrStr ();
            phmatr->ResizeAndSetAllSp (pnzblk_cpu[i], pnzblk_cpu[i], pnzblk_cpu[i],
                                       pnzblk_cpu[i]);
         }

         for (i = 0; i < nlistcpu; i++)
            pnzblk_cpu[i] = 0;

         int k, jj, ind_ini;

         for (i = 0; i < _nhblks_ini; i++) {
            if (_hblk2cpu_ini[i] == myid) {
               CMatrix < int, float >*pASub = pstr_cols_arr[i].GetASubArr ();
               CMatrix < int, float >*phmatr = pstr_cols_arr[i].GetHMatrStr ();
               int nzja_temp = phmatr->GetNzja ();
               int *plist_temp = phmatr->GetListArr ();
               int *pja_temp = phmatr->GetJaArr ();
               int *pja2_temp = phmatr->GetJa2Arr ();
               for (j = 0; j < nzja_temp; j++) {
                  ind_ini = plist_temp[j];
                  jj = pja_temp[j];
                  jj2 = pja2_temp[j];
                  jproc = _hblk2cpu_ini[jj2];
                  ind = pimaskcpu[jproc];
                  k = pnzblk_cpu[ind];
                  CMatrix < int, float >*pASub_temp = phblk_send[ind].GetASubArr ();
                  CMatrix < int, float >*phmatr_temp = phblk_send[ind].GetHMatrStr ();
                  int *plist_temp2 = phmatr_temp->GetListArr ();
                  int *plist2_temp2 = phmatr_temp->GetList2Arr ();
                  int *pja_temp2 = phmatr_temp->GetJaArr ();
                  int *pja2_temp2 = phmatr_temp->GetJa2Arr ();
                  plist_temp2[k] = ind_ini;
                  plist2_temp2[k] = i;
                  pja_temp2[k] = jj;
                  pja2_temp2[k] = jj2;
                  pASub_temp[k].ReplaceFree (pASub[j]);
                  pnzblk_cpu[ind]++;
               }
            }
         }

      }

// Pack send data

      vector < int >CpuIDSend (nlistcpu);
      vector < vector < char > >ObjSend (nlistcpu);

      int *pCpuIDSend = NULL;
      vector < char >*pObjSend = NULL;

      if (nlistcpu > 0) {
         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];
      }

      {

         CBMatrix < int, float >*phblk_send = hblk_send.Ptr ();

         long long isize;
         char *pobj;

         int i;

         for (i = 0; i < nlistcpu; i++) {
            pCpuIDSend[i] = plistcpu[i];
            isize = phblk_send[i].GetPackedSize ();
            pObjSend[i].resize ((size_t) isize);
            pobj = &(pObjSend[i][0]);
            phblk_send[i].FillPacked_thr (isize, pobj);
            phblk_send[i].Clean ();
         }

      }

// Exchange

      vector < int >CpuIDRecv;
      vector < vector < char > >ObjRecv;

      CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      int nrecv = (int) CpuIDRecv.size ();

      vector < char >*pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      vector < CBMatrix < int, float > >hblk_recv (nrecv + 1);

      CBMatrix < int, float >*phblk_recv = &hblk_recv[0];

      {

         long long isize;
         char *pobj;

         int i;

         for (i = 0; i < nrecv; i++) {
            isize = (long long) pObjRecv[i].size ();
            pobj = &(pObjRecv[i][0]);
            phblk_recv[i].UnPack_thr (isize, pobj);
         }

      }

// Free recv data

      {
         vector < vector < char > >ObjRecv_temp;
         ObjRecv.swap (ObjRecv_temp);
      }

// Fill 3index data inside blocks

      {
         int irecv;
         for (irecv = 0; irecv < nrecv; irecv++) {
            CMatrix < int, float >*pASub_recv = phblk_recv[irecv].GetASubArr ();
            CMatrix < int, float >*phmatr_recv = phblk_recv[irecv].GetHMatrStr ();
            int nzja_recv = phmatr_recv->GetNzja ();
            int *pja_recv = phmatr_recv->GetJaArr ();
            int *pja2_recv = phmatr_recv->GetJa2Arr ();
            {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
               for (int ipar = 0; ipar < nzja_recv; ipar++) {
                  int jblk = pja_recv[ipar];
                  int jhblk = pja2_recv[ipar];
                  int nlist2_temp = pASub_recv[ipar].GetNlist2 ();
                  int *plist2_temp = pASub_recv[ipar].GetList2Arr ();
                  pASub_recv[ipar].ResizeJa2 (3 * nlist2_temp);
                  pASub_recv[ipar].SetNzja2 (3 * nlist2_temp);
                  int *pja2_temp = pASub_recv[ipar].GetJa2Arr ();
                  int j, jj;
                  int ibegblk = _hblk2blk_ini[jhblk];
                  int ibs =
                     pibs_hblk[jhblk] + (int) (_blks_ini[jblk + ibegblk] -
                                               _blks_ini[ibegblk]);
                  for (j = 0; j < nlist2_temp; j++) {
                     jj = plist2_temp[j];
                     pja2_temp[j * 3] = porder_3index[(ibs + jj) * 3];
                     pja2_temp[j * 3 + 1] = porder_3index[(ibs + jj) * 3 + 1];
                     pja2_temp[j * 3 + 2] = porder_3index[(ibs + jj) * 3 + 2];
                  }
               }
            }

         }
      }

// Pack data

      ObjRecv.resize (nrecv);

      pObjSend = NULL;

      if (nrecv > 0) {
         pObjSend = &ObjRecv[0];
      }

      {

         long long isize;
         char *pobj;

         int i;

         for (i = 0; i < nrecv; i++) {
            isize = phblk_recv[i].GetPackedSize ();
            pObjSend[i].resize ((size_t) isize);
            pobj = &(pObjSend[i][0]);
            phblk_recv[i].FillPacked_thr (isize, pobj);
            phblk_recv[i].Clean ();
         }

      }

// Send data back

      CMPIDataExchange::DataExchange (_comm, CpuIDRecv, ObjRecv, CpuIDSend, ObjSend);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDRecv.swap (CpuIDSend_temp);
         ObjRecv.swap (ObjSend_temp);
      }

// Unpack receive data

      nrecv = (int) CpuIDSend.size ();

      pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjSend[0];
      }

      hblk_recv.resize (nrecv + 1);

      phblk_recv = &hblk_recv[0];

      {

         long long isize;
         char *pobj;

         int i;

         for (i = 0; i < nrecv; i++) {
            isize = (long long) pObjRecv[i].size ();
            pobj = &(pObjRecv[i][0]);
            phblk_recv[i].UnPack_thr (isize, pobj);
         }

      }

// Free recv data

      {
         vector < int >CpuIDRecv_temp;
         vector < vector < char > >ObjRecv_temp;
         CpuIDSend.swap (CpuIDRecv_temp);
         ObjSend.swap (ObjRecv_temp);
      }

// Allocate and fill ja2 for all own blocks

      {

         int ihblk;
         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               int niblk = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
               CMatrix < _Int, _Flt > *pASub = _hmatr_arr_ini[ihblk].GetASubArr ();
               CMatrix < int, float >*phmatr = _hmatr_arr_ini[ihblk].GetHMatrStr ();
               int *pia_hblk = phmatr->GetIaArr ();
               int *pja_hblk = phmatr->GetJaArr ();
               int *pja2_hblk = phmatr->GetJa2Arr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int i, j, jj, jblk, jhblk;
                     int ibegblk = _hblk2blk_ini[ihblk];
                     for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                        jblk = pja_hblk[i];
                        jhblk = pja2_hblk[i];
                        int nzja_temp = pASub[i].GetNzja ();
                        _Int *pja_temp = pASub[i].GetJaArr ();
                        pASub[i].ResizeJa2 (3 * nzja_temp);
                        pASub[i].SetNzja2 (3 * nzja_temp);
                        _Int *pja2_temp = pASub[i].GetJa2Arr ();
                        if (jhblk == ihblk) {
                           int ibs =
                              pibs_hblk[ihblk] + (int) (_blks_ini[jblk + ibegblk] -
                                                        _blks_ini[ibegblk]);
                           for (j = 0; j < nzja_temp; j++) {
                              jj = (int) pja_temp[j];
                              pja2_temp[j * 3] = porder_3index[(ibs + jj) * 3];
                              pja2_temp[j * 3 + 1] = porder_3index[(ibs + jj) * 3 + 1];
                              pja2_temp[j * 3 + 2] = porder_3index[(ibs + jj) * 3 + 2];
                           }
                        }
                     }
                  }
               }
            }
         }

      }

// Compute Ptrs to 3indices data for not own blocks and fill ja2 for off hblocks

      CVectorData < CVectorData < CMatrix < int, float >*> >ptr3indT_arr (_nhblks_ini);
      CVectorData < CMatrix < int, float >*>*pptr3indT_arr = ptr3indT_arr.Ptr ();

      {

         int ihblk;

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               int nlistT_hblk = pstr_hblkT_arr[ihblk].GetNlist ();
               pptr3indT_arr[ihblk].resize (nlistT_hblk);
               CMatrix < int, float >**ppptr3indT_arr = pptr3indT_arr[ihblk].Ptr ();
               for (int i = 0; i < nlistT_hblk; i++)
                  ppptr3indT_arr[i] = NULL;
            }
         }

         {
            int ind_ini;
            for (int i = 0; i < nrecv; i++) {
               CMatrix < int, float >*pASub = phblk_recv[i].GetASubArr ();
               CMatrix < int, float >*phmatr = phblk_recv[i].GetHMatrStr ();
               int nlist_recv = phmatr->GetNlist ();
               int *plist_recv = phmatr->GetListArr ();
               int *plist2_recv = phmatr->GetList2Arr ();
               for (int j = 0; j < nlist_recv; j++) {
                  ind_ini = plist_recv[j];
                  ihblk = plist2_recv[j];
                  CMatrix < int, float >**ppptr3indT_arr = pptr3indT_arr[ihblk].Ptr ();
                  ppptr3indT_arr[ind_ini] = pASub + j;
               }
            }
         }

         {

            int nblks_ini = _hblk2blk_ini[_nhblks_ini];

            int nimax = 0;

            {
               for (int i = 0; i < nblks_ini; i++) {
                  int niloc = (int) (_blks_ini[i + 1] - _blks_ini[i]);
                  if (niloc > nimax)
                     nimax = niloc;
               }
            }

            CVectorData < int >imask_threads (nimax * n_thr + 1);
            int *pimask_threads = imask_threads.Ptr ();

            for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
               if (_hblk2cpu_ini[ihblk] == myid) {
                  CMatrix < _Int, _Flt > *pASub = _hmatr_arr_ini[ihblk].GetASubArr ();

                  int nlistT_hblk = pstr_hblkT_arr[ihblk].GetNlist ();
                  int *plist2T_hblk = pstr_hblkT_arr[ihblk].GetList2Arr ();
                  int *piaT_hblk = pstr_hblkT_arr[ihblk].GetIaArr ();

                  int *ppindT2N_arr = pindT2N_arr[ihblk].Ptr ();

                  {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                     for (int ipar = 0; ipar < nlistT_hblk; ipar++) {
                        int my_thr = 0;
#ifdef USE_THREADS
                        my_thr = omp_get_thread_num ();
#endif

                        int *pimask_th = pimask_threads + nimax * my_thr;

                        int i, j, jj, indj, k;

                        if (plist2T_hblk[ipar] != ihblk) {
                           CMatrix < int, float >**ppptr3indT_arr =
                              pptr3indT_arr[ihblk].Ptr ();
                           CMatrix < int, float >*ptr_3index_matr = ppptr3indT_arr[ipar];
                           int nlist2_3ind = ptr_3index_matr->GetNlist2 ();
                           int *plist2_3ind = ptr_3index_matr->GetList2Arr ();
                           int *pja2_3ind = ptr_3index_matr->GetJa2Arr ();
                           for (i = 0; i < nlist2_3ind; i++) {
                              jj = plist2_3ind[i];
                              pimask_th[jj] = i;
                           }
                           for (i = piaT_hblk[ipar]; i < piaT_hblk[ipar + 1]; i++) {
                              indj = ppindT2N_arr[i];
                              int nzja_temp = pASub[indj].GetNzja ();
                              _Int *pja_temp = pASub[indj].GetJaArr ();
                              _Int *pja2_temp = pASub[indj].GetJa2Arr ();
                              for (j = 0; j < nzja_temp; j++) {
                                 jj = (int) pja_temp[j];
                                 k = pimask_th[jj];
                                 pja2_temp[3 * j] = pja2_3ind[3 * k];
                                 pja2_temp[3 * j + 1] = pja2_3ind[3 * k + 1];
                                 pja2_temp[3 * j + 2] = pja2_3ind[3 * k + 2];
                              }
                           }
                        }
                     }
                  }
               }
            }

         }

      }

// Compute block rows with 3indices as column numbers

      CVectorData < CBMatrix < _Int, _Flt > >hblk_rows (_nhblks_ini);
      CBMatrix < _Int, _Flt > *phblk_rows = hblk_rows.Ptr ();

      {
         int ihblk;
         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               int niblk = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
               phblk_rows[ihblk].SetNzblk (niblk);
               phblk_rows[ihblk].ResizeASub (niblk);
               CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
               CMatrix < _Int, _Flt > *pASub = _hmatr_arr_ini[ihblk].GetASubArr ();
               CMatrix < int, float >*phmatr = _hmatr_arr_ini[ihblk].GetHMatrStr ();
               int *pia_hblk = phmatr->GetIaArr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int iblkgl = _hblk2blk_ini[ihblk] + ipar;
                     int ibegblk = _hblk2blk_ini[ihblk];
                     int ibs =
                        pibs_hblk[ihblk] + (int) (_blks_ini[ipar + ibegblk] -
                                                  _blks_ini[ibegblk]);
                     int ni_loc = (int) (_blks_ini[iblkgl + 1] - _blks_ini[iblkgl]);
                     int nzja_loc = 0;
                     int i;
                     for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                        nzja_loc += pASub[i].GetNzja ();
                     }
                     pASub_rows[ipar].ResizeAndSetAllSp (ni_loc, ni_loc * 3, 0,
                                                         nzja_loc * 3);
                     _Int *plist_rows = pASub_rows[ipar].GetListArr ();
                     _Int *plist2_rows = pASub_rows[ipar].GetList2Arr ();
                     _Int *pia_rows = pASub_rows[ipar].GetIaArr ();
                     _Int *pja2_rows = pASub_rows[ipar].GetJa2Arr ();
                     for (i = 0; i < ni_loc; i++)
                        plist_rows[i] = (_Int) i;
                     for (i = 0; i <= ni_loc; i++)
                        pia_rows[i] = 0;
                     int j, jj, k, kind;
                     for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                        int nlist_temp = pASub[i].GetNlist ();
                        _Int *plist_temp = pASub[i].GetListArr ();
                        _Int *pia_temp = pASub[i].GetIaArr ();
                        for (j = 0; j < nlist_temp; j++) {
                           jj = (int) plist_temp[j];
                           pia_rows[jj + 1] += (pia_temp[j + 1] - pia_temp[j]);
                        }
                     }
                     for (i = 0; i < ni_loc; i++)
                        pia_rows[i + 1] += pia_rows[i];
                     CVectorData < int >iptr (ni_loc);
                     int *piptr = iptr.Ptr ();
                     for (i = 0; i < ni_loc; i++)
                        piptr[i] = (int) pia_rows[i];
                     for (i = 0; i < 3 * ni_loc; i++)
                        plist2_rows[i] = porder_3index[ibs * 3 + i];
                     for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                        int nlist_temp = pASub[i].GetNlist ();
                        _Int *plist_temp = pASub[i].GetListArr ();
                        _Int *pia_temp = pASub[i].GetIaArr ();
                        _Int *pja2_temp = pASub[i].GetJa2Arr ();
                        for (j = 0; j < nlist_temp; j++) {
                           jj = (int) plist_temp[j];
                           kind = piptr[jj];
                           for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                              pja2_rows[kind * 3] = pja2_temp[k * 3];
                              pja2_rows[kind * 3 + 1] = pja2_temp[k * 3 + 1];
                              pja2_rows[kind * 3 + 2] = pja2_temp[k * 3 + 2];
                              kind++;
                           }
                           piptr[jj] = kind;;
                        }
                     }
                     for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                        pASub[i].ResizeList2 (0);
                        pASub[i].ResizeJa2 (0);
                        pASub[i].SetNlist2 (0);
                        pASub[i].SetNzja2 (0);
                     }
                  }
               }
            }
         }

      }

// Prepare sends

      CBMatrix < _Int, _Flt > hblk_myid;

      {

         int nblks_fin = _hblk2blk_fin[_nhblks_fin];

         CVectorData < int >imaskblk_threads (nblks_fin * 12 * n_thr);
         CVectorData < int >icycleblk_threads (2 * n_thr);
         CVectorData < int >nblk_threads (n_thr);

         int *pimaskblk_threads = imaskblk_threads.Ptr ();
         int *picycleblk_threads = icycleblk_threads.Ptr ();
         int *pnblk_threads = nblk_threads.Ptr ();

         {
            int i;
            for (i = 0; i < 2 * n_thr; i++)
               picycleblk_threads[i] = -1;
            for (i = 0; i < n_thr; i++)
               pnblk_threads[i] = 0;
         }

         int ihblk;

         CVectorData < CVectorData < int > >nzblk_arr (_nhblks_ini);
         CVectorData < CVectorData < vector < int > > >listblk_arr (_nhblks_ini);

         CVectorData < int >*pnzblk_arr = nzblk_arr.Ptr ();
         CVectorData < vector < int > >*plistblk_arr = listblk_arr.Ptr ();

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
               int niblk = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
               pnzblk_arr[ihblk].resize (niblk);
               plistblk_arr[ihblk].resize (niblk);
               int *ppnzblk_arr = pnzblk_arr[ihblk].Ptr ();
               vector < int >*pplistblk_arr = plistblk_arr[ihblk].Ptr ();
               {
                  for (int i = 0; i < niblk; i++)
                     ppnzblk_arr[i] = 0;
               }
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif
                     int *pimaskblk_th = pimaskblk_threads + 12 * nblks_fin * my_thr;
                     int *pimaskblk1_th = pimaskblk_th + nblks_fin;
                     int *pindblk_th = pimaskblk_th + 2 * nblks_fin;
                     int *pindblk1_th = pindblk_th + nblks_fin;
                     int *plistblk_th = pindblk_th + 2 * nblks_fin;
                     int *plistblk1_th = plistblk_th + 4 * nblks_fin;
                     int icycleblk_th = picycleblk_threads[2 * my_thr];
                     int icycleblk1_th = picycleblk_threads[2 * my_thr + 1];
                     int nblk_th = pnblk_threads[my_thr];

                     int i;

                     if (icycleblk_th == -1) {
                        for (i = 0; i < 2 * nblks_fin; i++)
                           pimaskblk_th[i] = -1;
                        icycleblk_th = 0;
                     }

                     icycleblk1_th++;

                     int iblkgl = _hblk2blk_ini[ihblk] + ipar;
                     int ni_loc = (int) (_blks_ini[iblkgl + 1] - _blks_ini[iblkgl]);
                     _Int *plist2_temp = pASub_rows[ipar].GetList2Arr ();
                     _Int *pia_temp = pASub_rows[ipar].GetIaArr ();
                     int jblk, jhblk, jblkgl, ind;
                     int nblk1_th = 0;
                     for (i = 0; i < ni_loc; i++) {
                        jblk = (int) plist2_temp[i * 3 + 1];
                        jhblk = (int) plist2_temp[i * 3 + 2];
                        jblkgl = _hblk2blk_fin[jhblk] + jblk;
                        if (pimaskblk_th[jblkgl] != icycleblk_th) {
                           pimaskblk_th[jblkgl] = icycleblk_th;
                           pindblk_th[jblkgl] = nblk_th;
                           plistblk_th[nblk_th * 4] = jblk;
                           plistblk_th[nblk_th * 4 + 1] = jhblk;
                           plistblk_th[nblk_th * 4 + 2] = 0;
                           plistblk_th[nblk_th * 4 + 3] = 0;
                           nblk_th++;
                        }
                        if (pimaskblk1_th[jblkgl] != icycleblk1_th) {
                           pimaskblk1_th[jblkgl] = icycleblk1_th;
                           pindblk1_th[jblkgl] = nblk1_th;
                           plistblk1_th[nblk1_th * 4] = jblk;
                           plistblk1_th[nblk1_th * 4 + 1] = jhblk;
                           plistblk1_th[nblk1_th * 4 + 2] = 0;
                           plistblk1_th[nblk1_th * 4 + 3] = 0;
                           nblk1_th++;
                        }
                        ind = pindblk_th[jblkgl];
                        plistblk_th[ind * 4 + 2]++;
                        plistblk_th[ind * 4 + 3] += (int) (pia_temp[i + 1] - pia_temp[i]);
                        ind = pindblk1_th[jblkgl];
                        plistblk1_th[ind * 4 + 2]++;
                        plistblk1_th[ind * 4 + 3] +=
                           (int) (pia_temp[i + 1] - pia_temp[i]);
                     }
                     ppnzblk_arr[ipar] = nblk1_th;
                     for (i = 0; i < 4 * nblk1_th; i++) {
                        pplistblk_arr[ipar].push_back (plistblk1_th[i]);
                     }
                     picycleblk_threads[2 * my_thr] = icycleblk_th;
                     picycleblk_threads[2 * my_thr + 1] = icycleblk1_th;
                     pnblk_threads[my_thr] = nblk_th;
                  }
               }
            }
         }

         {
            int i, i_thr, jblk, jhblk, jblkgl, ind;
            for (i_thr = 1; i_thr < n_thr; i_thr++) {
               int *pimaskblk_th0 = pimaskblk_threads;
               int *pindblk_th0 = pimaskblk_th0 + 2 * nblks_fin;
               int *plistblk_th0 = pindblk_th0 + 2 * nblks_fin;
               int icycleblk_th0 = picycleblk_threads[0];
               int nblk_th0 = pnblk_threads[0];
               if (icycleblk_th0 == -1) {
                  for (i = 0; i < 2 * nblks_fin; i++)
                     pimaskblk_th0[i] = -1;
                  icycleblk_th0 = 0;
               }
               int *pimaskblk_th = pimaskblk_threads + 12 * nblks_fin * i_thr;
               int *plistblk_th = pimaskblk_th + 4 * nblks_fin;
               int nblk_th = pnblk_threads[i_thr];
               for (i = 0; i < nblk_th; i++) {
                  jblk = plistblk_th[4 * i];
                  jhblk = plistblk_th[4 * i + 1];
                  jblkgl = _hblk2blk_fin[jhblk] + jblk;
                  if (pimaskblk_th0[jblkgl] != icycleblk_th0) {
                     pimaskblk_th0[jblkgl] = icycleblk_th0;
                     pindblk_th0[jblkgl] = nblk_th0;
                     plistblk_th0[nblk_th0 * 4] = jblk;
                     plistblk_th0[nblk_th0 * 4 + 1] = jhblk;
                     plistblk_th0[nblk_th0 * 4 + 2] = 0;
                     plistblk_th0[nblk_th0 * 4 + 3] = 0;
                     nblk_th0++;
                  }
                  ind = pindblk_th0[jblkgl];
                  plistblk_th0[ind * 4 + 2] += plistblk_th[4 * i + 2];
                  plistblk_th0[ind * 4 + 3] += plistblk_th[4 * i + 3];
               }
               pnblk_threads[0] = nblk_th0;
               picycleblk_threads[0] = icycleblk_th0;
            }
         }

// Sort obtained list of blocks

         int nblks_curr = pnblk_threads[0];
         int *plist4ind_th0 = pimaskblk_threads + 4 * nblks_fin;

         CVectorData < int >list4ind_curr (nblks_curr * 4);
         int *plist4ind_curr = list4ind_curr.Ptr ();

         {
            CVectorData < CSortInt2 > ii2arr (nblks_curr);
            CSortInt2 *pii2arr = ii2arr.Ptr ();
            int i;
            for (i = 0; i < nblks_curr; i++) {
               pii2arr[i].ixval = plist4ind_th0[i * 4 + 1];
               pii2arr[i].iyval = plist4ind_th0[i * 4];
               pii2arr[i].itail = i;
            }
            sort (pii2arr, pii2arr + nblks_curr);
            int ind;
            for (i = 0; i < nblks_curr; i++) {
               ind = pii2arr[i].itail;
               plist4ind_curr[i * 4] = plist4ind_th0[ind * 4];
               plist4ind_curr[i * 4 + 1] = plist4ind_th0[ind * 4 + 1];
               plist4ind_curr[i * 4 + 2] = plist4ind_th0[ind * 4 + 2];
               plist4ind_curr[i * 4 + 3] = plist4ind_th0[ind * 4 + 3];
            }
         }

// Allocate blocks for data store

         CVectorData < int >imaskhblk (_nhblks_fin);
         CVectorData < int >listhblk (_nhblks_fin);
         CVectorData < int >ibshblk (_nhblks_fin);

         int *pimaskhblk = imaskhblk.Ptr ();
         int *plisthblk = listhblk.Ptr ();
         int *pibshblk = ibshblk.Ptr ();

         int nlisthblk_curr = 0;
         int nzblk_hblk = 0;

         {
            int i, jhblk;
            for (i = 0; i < _nhblks_fin; i++)
               pimaskhblk[i] = -1;
            for (i = 0; i < nblks_curr; i++) {
               jhblk = plist4ind_curr[i * 4 + 1];
               if (pimaskhblk[jhblk] < 0) {
                  plisthblk[nlisthblk_curr] = jhblk;
                  nlisthblk_curr++;
                  pimaskhblk[jhblk] = 1;
               }
            }
            sort (plisthblk, plisthblk + nlisthblk_curr);
            for (i = 0; i < nlisthblk_curr; i++) {
               jhblk = plisthblk[i];
               pibshblk[jhblk] = nzblk_hblk;
               nzblk_hblk += (_hblk2blk_fin[jhblk + 1] - _hblk2blk_fin[jhblk]);
            }
         }

// Compute references to blocks and allocate memory

         CVectorData < int >ind2blks (nzblk_hblk);
         int *pind2blks = ind2blks.Ptr ();

         {
            int i, jblk, jhblk, ibs;
            for (i = 0; i < nzblk_hblk; i++)
               pind2blks[i] = -1;
            for (i = 0; i < nblks_curr; i++) {
               jblk = plist4ind_curr[i * 4];
               jhblk = plist4ind_curr[i * 4 + 1];
               ibs = pibshblk[jhblk];
               pind2blks[ibs + jblk] = i;
            }
         }

         CVectorData < CMatrix < _Int, _Flt > >blkrows_new (nblks_curr);
         CMatrix < _Int, _Flt > *pblkrows_new = blkrows_new.Ptr ();

         {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nblks_curr; ipar++) {
               int nlist_temp = plist4ind_curr[ipar * 4 + 2];
               int nzja_temp = plist4ind_curr[ipar * 4 + 3];
               pblkrows_new[ipar].ResizeAndSetAllSp (nlist_temp, 3 * nlist_temp, 0,
                                                     3 * nzja_temp);
               _Int *pia_rows_new = pblkrows_new[ipar].GetIaArr ();
               pia_rows_new[0] = 0;
               plist4ind_curr[ipar * 4 + 2] = 0;
               plist4ind_curr[ipar * 4 + 3] = 0;
            }

         }

// Compute local references in terms of stored initial block row data

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               int niblk = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
               int *ppnzblk_arr = pnzblk_arr[ihblk].Ptr ();
               vector < int >*pplistblk_arr = plistblk_arr[ihblk].Ptr ();
               int i, j, nlist_temp, nzja_temp, ind, jblk, jhblk, ibs;
               for (i = 0; i < niblk; i++) {
                  int *ppplistblk_arr = NULL;
                  if (ppnzblk_arr[i] > 0)
                     ppplistblk_arr = &pplistblk_arr[i][0];
                  for (j = 0; j < ppnzblk_arr[i]; j++) {
                     jblk = ppplistblk_arr[j * 4];
                     jhblk = ppplistblk_arr[j * 4 + 1];
                     nlist_temp = ppplistblk_arr[j * 4 + 2];
                     nzja_temp = ppplistblk_arr[j * 4 + 3];
                     ibs = pibshblk[jhblk];
                     ind = pind2blks[ibs + jblk];
                     ppplistblk_arr[j * 4 + 2] = plist4ind_curr[ind * 4 + 2];
                     ppplistblk_arr[j * 4 + 3] = plist4ind_curr[ind * 4 + 3];
                     plist4ind_curr[ind * 4 + 2] += nlist_temp;
                     plist4ind_curr[ind * 4 + 3] += nzja_temp;
                  }
               }
            }
         }

// Rewrite block row data

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
               int niblk = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
               int *ppnzblk_arr = pnzblk_arr[ihblk].Ptr ();
               vector < int >*pplistblk_arr = plistblk_arr[ihblk].Ptr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif
                     int *pimaskblk_th = pimaskblk_threads + 12 * nblks_fin * my_thr;
                     int *pindblk_th = pimaskblk_th + 2 * nblks_fin;
                     int *pindblk1_th = pindblk_th + nblks_fin;

                     int *ppplistblk_arr = NULL;
                     if (ppnzblk_arr[ipar] > 0)
                        ppplistblk_arr = &pplistblk_arr[ipar][0];

                     int iblkgl = _hblk2blk_ini[ihblk] + ipar;
                     int ni_loc = (int) (_blks_ini[iblkgl + 1] - _blks_ini[iblkgl]);
                     int jblk, jhblk, jblkgl, ind, ibs, i;
                     for (i = 0; i < ppnzblk_arr[ipar]; i++) {
                        jblk = ppplistblk_arr[i * 4];
                        jhblk = ppplistblk_arr[i * 4 + 1];
                        jblkgl = _hblk2blk_fin[jhblk] + jblk;
                        ibs = pibshblk[jhblk];
                        ind = pind2blks[ibs + jblk];
                        pindblk_th[jblkgl] = ind;
                        pindblk1_th[jblkgl] = i;
                     }
                     _Int *plist2_temp = pASub_rows[ipar].GetList2Arr ();
                     _Int *pia_temp = pASub_rows[ipar].GetIaArr ();
                     _Int *pja2_temp = pASub_rows[ipar].GetJa2Arr ();
                     int indblk, indreg, ilist, nz, j;
                     for (i = 0; i < ni_loc; i++) {
                        jblk = (int) plist2_temp[i * 3 + 1];
                        jhblk = (int) plist2_temp[i * 3 + 2];
                        jblkgl = _hblk2blk_fin[jhblk] + jblk;
                        indblk = pindblk_th[jblkgl];
                        indreg = pindblk1_th[jblkgl];
                        ilist = ppplistblk_arr[4 * indreg + 2];
                        nz = ppplistblk_arr[4 * indreg + 3];
                        _Int *plist2_rows_new = pblkrows_new[indblk].GetList2Arr ();
                        _Int *pia_rows_new = pblkrows_new[indblk].GetIaArr ();
                        _Int *pja2_rows_new = pblkrows_new[indblk].GetJa2Arr ();
                        plist2_rows_new[ilist * 3] = plist2_temp[i * 3];
                        plist2_rows_new[ilist * 3 + 1] = plist2_temp[i * 3 + 1];
                        plist2_rows_new[ilist * 3 + 2] = plist2_temp[i * 3 + 2];
                        for (j = (int) pia_temp[i]; j < pia_temp[i + 1]; j++) {
                           pja2_rows_new[nz * 3] = pja2_temp[j * 3];
                           pja2_rows_new[nz * 3 + 1] = pja2_temp[j * 3 + 1];
                           pja2_rows_new[nz * 3 + 2] = pja2_temp[j * 3 + 2];
                           nz++;
                        }
                        pia_rows_new[ilist + 1] = (_Int) nz;
                        ilist++;
                        ppplistblk_arr[4 * indreg + 2] = ilist;
                        ppplistblk_arr[4 * indreg + 3] = nz;
                     }
                  }

               }

               phblk_rows[ihblk].Clean ();

            }
         }

// Finally combine blocks for send

         CVectorData < int >imaskcpu (nproc);
         CVectorData < int >listcpu (nproc);
         CVectorData < int >nzcpu (nproc);

         int *pimaskcpu = imaskcpu.Ptr ();
         int *plistcpu = listcpu.Ptr ();
         int *pnzcpu = nzcpu.Ptr ();

         int nlistcpu = 0;

         {
            int i, jhblk, jcpu;
            for (i = 0; i < nproc; i++) {
               pimaskcpu[i] = -1;
               pnzcpu[i] = 0;
            }
            pimaskcpu[myid] = 1;
            plistcpu[nlistcpu] = myid;
            nlistcpu++;
            for (i = 0; i < nblks_curr; i++) {
               jhblk = plist4ind_curr[i * 4 + 1];
               jcpu = _hblk2cpu_fin[jhblk];
               pnzcpu[jcpu]++;
               if (pimaskcpu[jcpu] < 0) {
                  pimaskcpu[jcpu] = 1;
                  plistcpu[nlistcpu] = jcpu;
                  nlistcpu++;
               }
            }
            sort (plistcpu + 1, plistcpu + nlistcpu);
            for (i = 0; i < nlistcpu; i++) {
               jcpu = plistcpu[i];
               pimaskcpu[jcpu] = i;
            }

            vector < CBMatrix < _Int, _Flt > >hblk_send_temp (nlistcpu + 1);
            CBMatrix < _Int, _Flt > *phblk_send_temp = &hblk_send_temp[0];

            int nzblk;

            for (i = 0; i < nlistcpu; i++) {
               jcpu = plistcpu[i];
               nzblk = pnzcpu[jcpu];
               phblk_send_temp[i].ResizeASub (nzblk);
               phblk_send_temp[i].SetNzblk (nzblk);
               CMatrix < int, float >*phmatr = phblk_send_temp[i].GetHMatrStr ();
               phmatr->ResizeAndSetAllSp (nzblk, nzblk, 0, 0);
               pnzcpu[jcpu] = 0;
            }

            int jblk, ind, k;

            for (i = 0; i < nblks_curr; i++) {
               jblk = plist4ind_curr[i * 4];
               jhblk = plist4ind_curr[i * 4 + 1];
               jcpu = _hblk2cpu_fin[jhblk];
               ind = pimaskcpu[jcpu];
               CMatrix < _Int, _Flt > *pASub = phblk_send_temp[ind].GetASubArr ();
               CMatrix < int, float >*phmatr = phblk_send_temp[ind].GetHMatrStr ();
               k = pnzcpu[jcpu];
               int *plist_hblk = phmatr->GetListArr ();
               int *plist2_hblk = phmatr->GetList2Arr ();
               plist_hblk[k] = jblk;
               plist2_hblk[k] = jhblk;
               pASub[k].ReplaceFree (pblkrows_new[i]);
               pnzcpu[jcpu]++;
            }

// Pack send data

            CpuIDSend.resize (nlistcpu - 1);
            ObjSend.resize (nlistcpu - 1);

            pCpuIDSend = NULL;
            pObjSend = NULL;

            if (nlistcpu > 1) {
               pCpuIDSend = &CpuIDSend[0];
               pObjSend = &ObjSend[0];
            }

            long long isize;
            char *pobj;

            {
               int i;
               for (i = 1; i < nlistcpu; i++) {
                  pCpuIDSend[i - 1] = plistcpu[i];
                  isize = phblk_send_temp[i].GetPackedSize ();
                  pObjSend[i - 1].resize ((size_t) isize);
                  pobj = &(pObjSend[i - 1][0]);
                  phblk_send_temp[i].FillPacked_thr (isize, pobj);
                  phblk_send_temp[i].Clean ();
               }
            }

            hblk_myid.ReplaceFree (phblk_send_temp[0]);

         }

      }

// Exchange

      CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      nrecv = (int) CpuIDRecv.size () + 1;

      pObjRecv = NULL;

      if (nrecv > 1) {
         pObjRecv = &ObjRecv[0];
      }

      vector < CBMatrix < _Int, _Flt > >hblk_recv_temp (nrecv + 1);

      CBMatrix < _Int, _Flt > *phblk_recv_temp = &hblk_recv_temp[0];

      phblk_recv_temp[0].ReplaceFree (hblk_myid);

      {

         long long isize;
         char *pobj;

         int i;

         for (i = 1; i < nrecv; i++) {
            isize = (long long) pObjRecv[i - 1].size ();
            pobj = &(pObjRecv[i - 1][0]);
            phblk_recv_temp[i].UnPack_thr (isize, pobj);
         }

      }

// Free recv data

      {
         vector < vector < char > >ObjRecv_temp;
         ObjRecv.swap (ObjRecv_temp);
      }

// Create set of received block rows

      hblk_rows.resize (_nhblks_fin + 1);
      phblk_rows = hblk_rows.Ptr ();

      {
         int ihblk;
         for (ihblk = 0; ihblk < _nhblks_fin; ihblk++) {
            if (_hblk2cpu_fin[ihblk] == myid) {
               int niblk = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];
               phblk_rows[ihblk].ResizeASub (niblk);
               CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int iblkgl = _hblk2blk_fin[ihblk] + ipar;
                     int ni_loc = (int) (_blks_fin[iblkgl + 1] - _blks_fin[iblkgl]);
                     pASub_rows[ipar].SetNlist (ni_loc);
                     pASub_rows[ipar].ResizeList (ni_loc);
                     pASub_rows[ipar].ResizeIa (ni_loc);
                     _Int *plist_temp = pASub_rows[ipar].GetListArr ();
                     _Int *pia_temp = pASub_rows[ipar].GetIaArr ();
                     int i;
                     for (i = 0; i < ni_loc; i++)
                        plist_temp[i] = i;
                     for (i = 0; i <= ni_loc; i++)
                        pia_temp[i] = 0;
                  }

               }

            }
         }

         for (ihblk = 0; ihblk < nrecv; ihblk++) {
            int nzblk = phblk_recv_temp[ihblk].GetNzblk ();
            CMatrix < int, float >*phmatr_recv = phblk_recv_temp[ihblk].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pASub_recv = phblk_recv_temp[ihblk].GetASubArr ();
            int *plist_hmatr = phmatr_recv->GetListArr ();
            int *plist2_hmatr = phmatr_recv->GetList2Arr ();
            {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
               for (int ipar = 0; ipar < nzblk; ipar++) {
                  int jblk = plist_hmatr[ipar];
                  int jhblk = plist2_hmatr[ipar];
                  int nlist_temp = pASub_recv[ipar].GetNlist ();
                  _Int *plist2_temp = pASub_recv[ipar].GetList2Arr ();
                  _Int *pia_temp = pASub_recv[ipar].GetIaArr ();
                  CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[jhblk].GetASubArr ();
                  _Int *pia_rows = pASub_rows[jblk].GetIaArr ();
                  int i, jj;
                  for (i = 0; i < nlist_temp; i++) {
                     jj = (int) plist2_temp[i * 3];
                     pia_rows[jj + 1] = (pia_temp[i + 1] - pia_temp[i]);
                  }
               }
            }

         }

         for (ihblk = 0; ihblk < _nhblks_fin; ihblk++) {
            if (_hblk2cpu_fin[ihblk] == myid) {
               int niblk = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];
               CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int iblkgl = _hblk2blk_fin[ihblk] + ipar;
                     int ni_loc = (int) (_blks_fin[iblkgl + 1] - _blks_fin[iblkgl]);
                     _Int *pia_temp = pASub_rows[ipar].GetIaArr ();
                     int i;
                     for (i = 0; i < ni_loc; i++)
                        pia_temp[i + 1] += pia_temp[i];
                     int nzja_temp = (int) pia_temp[ni_loc];
                     pASub_rows[ipar].ResizeJa2 (3 * nzja_temp);
                     pASub_rows[ipar].ResizeA (nzja_temp);
                     pASub_rows[ipar].SetNzja2 (nzja_temp * 3);
                  }

               }

            }
         }

         for (ihblk = 0; ihblk < nrecv; ihblk++) {
            int nzblk = phblk_recv_temp[ihblk].GetNzblk ();
            CMatrix < int, float >*phmatr_recv = phblk_recv_temp[ihblk].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pASub_recv = phblk_recv_temp[ihblk].GetASubArr ();
            int *plist_hmatr = phmatr_recv->GetListArr ();
            int *plist2_hmatr = phmatr_recv->GetList2Arr ();
            {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
               for (int ipar = 0; ipar < nzblk; ipar++) {
                  int jblk = plist_hmatr[ipar];
                  int jhblk = plist2_hmatr[ipar];
                  int nlist_temp = pASub_recv[ipar].GetNlist ();
                  _Int *plist2_temp = pASub_recv[ipar].GetList2Arr ();
                  _Int *pia_temp = pASub_recv[ipar].GetIaArr ();
                  _Int *pja2_temp = pASub_recv[ipar].GetJa2Arr ();
                  CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[jhblk].GetASubArr ();
                  _Int *pia_rows = pASub_rows[jblk].GetIaArr ();
                  _Int *pja2_rows = pASub_rows[jblk].GetJa2Arr ();
                  int i, jj, j, ibs;
                  for (i = 0; i < nlist_temp; i++) {
                     jj = (int) plist2_temp[i * 3];
                     ibs = (int) pia_rows[jj];
                     for (j = (int) pia_temp[i]; j < pia_temp[i + 1]; j++) {
                        pja2_rows[ibs * 3] = pja2_temp[j * 3];
                        pja2_rows[ibs * 3 + 1] = pja2_temp[j * 3 + 1];
                        pja2_rows[ibs * 3 + 2] = pja2_temp[j * 3 + 2];
                        ibs++;
                     }
                  }
               }
            }

            phblk_recv_temp[ihblk].Clean ();

         }

         hblk_recv_temp.resize (0);

      }

// Sort block rows data

      {
         int ihblk;
         for (ihblk = 0; ihblk < _nhblks_fin; ihblk++) {
            if (_hblk2cpu_fin[ihblk] == myid) {
               int niblk = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
                     int nlist_rows = pASub_rows[ipar].GetNlist ();
                     _Int *pia_rows = pASub_rows[ipar].GetIaArr ();
                     _Int *pja2_rows = pASub_rows[ipar].GetJa2Arr ();
                     int i, jj, j, niloc;
                     int nimax = 0;
                     for (i = 0; i < nlist_rows; i++) {
                        niloc = (int) (pia_rows[i + 1] - pia_rows[i]);
                        if (niloc > nimax)
                           nimax = niloc;
                     }
                     CVectorData < CSortInt2 > ii2arr (nimax);
                     CVectorData < _Int > i3index (3 * nimax);
                     CSortInt2 *pii2arr = ii2arr.Ptr ();
                     _Int *pi3index = i3index.Ptr ();
                     int ibeg, jext, jind, jblk, jhblk, jblkgl;
                     for (i = 0; i < nlist_rows; i++) {
                        niloc = (int) (pia_rows[i + 1] - pia_rows[i]);
                        ibeg = (int) pia_rows[i];
                        for (j = 0; j < niloc; j++) {
                           jext = j + ibeg;
                           jj = (int) pja2_rows[jext * 3];
                           jblk = (int) pja2_rows[jext * 3 + 1];
                           jhblk = (int) pja2_rows[jext * 3 + 2];
                           jblkgl = _hblk2blk_fin[jhblk] + jblk;
                           pii2arr[j].ixval = jblkgl;
                           pii2arr[j].iyval = jj;
                           pii2arr[j].itail = jext;
                        }
                        sort (pii2arr, pii2arr + niloc);
                        for (j = 0; j < niloc; j++) {
                           jind = pii2arr[j].itail;
                           pi3index[j * 3] = pja2_rows[jind * 3];
                           pi3index[j * 3 + 1] = pja2_rows[jind * 3 + 1];
                           pi3index[j * 3 + 2] = pja2_rows[jind * 3 + 2];
                        }
                        for (j = 0; j < niloc; j++) {
                           jext = j + ibeg;
                           pja2_rows[jext * 3] = pi3index[j * 3];
                           pja2_rows[jext * 3 + 1] = pi3index[j * 3 + 1];
                           pja2_rows[jext * 3 + 2] = pi3index[j * 3 + 2];
                        }
                     }
                  }
               }

            }
         }

      }

// Form final hblocks

      {
         int ihblk;

         int nblks_fin = _hblk2blk_fin[_nhblks_fin];

         CVectorData < int >imaskblk_threads (nblks_fin * 4 * n_thr);
         CVectorData < int >icycleblk_threads (n_thr);

         int *pimaskblk_threads = imaskblk_threads.Ptr ();
         int *picycleblk_threads = icycleblk_threads.Ptr ();

         {
            int i;
            for (i = 0; i < n_thr; i++)
               picycleblk_threads[i] = -1;
         }

         for (ihblk = 0; ihblk < _nhblks_fin; ihblk++) {
            if (_hblk2cpu_fin[ihblk] == myid) {
               int niblk = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];
               CVectorData < int >nzblk_arr (niblk);
               CVectorData < CVectorData < int > >list2blk_arr (niblk);
               CVectorData < CVectorData < CMatrix < _Int, _Flt > > >blks_arr (niblk);
               int *pnzblk_arr = nzblk_arr.Ptr ();
               CVectorData < int >*plist2blk_arr = list2blk_arr.Ptr ();
               CVectorData < CMatrix < _Int, _Flt > >*pblks_arr = blks_arr.Ptr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif
                     int *pimaskblk_th = pimaskblk_threads + 4 * nblks_fin * my_thr;
                     int *pindblk_th = pimaskblk_th + nblks_fin;
                     int *plistblk_th = pindblk_th + nblks_fin;
                     int *pnzblk_th = plistblk_th + nblks_fin;
                     int icycleblk_th = picycleblk_threads[my_thr];

                     int i;

                     if (icycleblk_th == -1) {
                        for (i = 0; i < nblks_fin; i++)
                           pimaskblk_th[i] = -1;
                     }

                     icycleblk_th++;

                     int iblkgl = _hblk2blk_fin[ihblk] + ipar;
                     int ni_loc = (int) (_blks_fin[iblkgl + 1] - _blks_fin[iblkgl]);
                     CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
                     int nlist_rows = pASub_rows[ipar].GetNlist ();
                     _Int *pia_rows = pASub_rows[ipar].GetIaArr ();
                     _Int *pja2_rows = pASub_rows[ipar].GetJa2Arr ();
                     int j, jj, jblk, jhblk, jblkgl;
                     int nlistblk = 0;
                     for (i = 0; i < nlist_rows; i++) {
                        for (j = (int) pia_rows[i]; j < pia_rows[i + 1]; j++) {
                           jblk = (int) pja2_rows[j * 3 + 1];
                           jhblk = (int) pja2_rows[j * 3 + 2];
                           jblkgl = _hblk2blk_fin[jhblk] + jblk;
                           if (pimaskblk_th[jblkgl] != icycleblk_th) {
                              pimaskblk_th[jblkgl] = icycleblk_th;
                              plistblk_th[nlistblk] = jblkgl;
                              nlistblk++;
                           }
                        }
                     }
                     pnzblk_arr[ipar] = nlistblk;
                     plist2blk_arr[ipar].resize (2 * nlistblk);
                     int *pplist2blk_arr = plist2blk_arr[ipar].Ptr ();
                     for (i = 0; i < 2 * nlistblk; i++)
                        pplist2blk_arr[i] = -1;
                     sort (plistblk_th, plistblk_th + nlistblk);
                     for (i = 0; i < nlistblk; i++) {
                        jblkgl = plistblk_th[i];
                        pindblk_th[jblkgl] = i;
                        pnzblk_th[jblkgl] = 0;
                     }
                     int ind;
                     for (i = 0; i < nlist_rows; i++) {
                        for (j = (int) pia_rows[i]; j < pia_rows[i + 1]; j++) {
                           jblk = (int) pja2_rows[j * 3 + 1];
                           jhblk = (int) pja2_rows[j * 3 + 2];
                           jblkgl = _hblk2blk_fin[jhblk] + jblk;
                           pnzblk_th[jblkgl]++;
                           ind = pindblk_th[jblkgl];
                           if (pplist2blk_arr[ind * 2] < 0) {
                              pplist2blk_arr[ind * 2] = jblk;
                              pplist2blk_arr[ind * 2 + 1] = jhblk;
                           }
                        }
                     }
                     CVectorData < CVectorData < _Int > >rowsarr (nlistblk);
                     CVectorData < CVectorData < _Int > >colsarr (nlistblk);
                     CVectorData < _Int > *prowsarr = rowsarr.Ptr ();
                     CVectorData < _Int > *pcolsarr = colsarr.Ptr ();
                     int nz;
                     for (i = 0; i < nlistblk; i++) {
                        jblkgl = plistblk_th[i];
                        nz = pnzblk_th[jblkgl];
                        prowsarr[i].resize (nz);
                        pcolsarr[i].resize (nz);
                        pnzblk_th[jblkgl] = 0;
                     }
                     for (i = 0; i < nlist_rows; i++) {
                        for (j = (int) pia_rows[i]; j < pia_rows[i + 1]; j++) {
                           jj = (int) pja2_rows[j * 3];
                           jblk = (int) pja2_rows[j * 3 + 1];
                           jhblk = (int) pja2_rows[j * 3 + 2];
                           jblkgl = _hblk2blk_fin[jhblk] + jblk;
                           ind = pindblk_th[jblkgl];
                           nz = pnzblk_th[jblkgl];
                           _Int *pprowsarr = prowsarr[ind].Ptr ();
                           _Int *ppcolsarr = pcolsarr[ind].Ptr ();
                           pprowsarr[nz] = i;
                           ppcolsarr[nz] = jj;
                           pnzblk_th[jblkgl]++;
                        }
                     }
                     pblks_arr[ipar].resize (nlistblk);
                     CMatrix < _Int, _Flt > *ppblks_arr = pblks_arr[ipar].Ptr ();
                     int nimax = ni_loc;
                     int nj_loc;
                     for (i = 0; i < nlistblk; i++) {
                        jblkgl = plistblk_th[i];
                        nj_loc = (int) (_blks_fin[jblkgl + 1] - _blks_fin[jblkgl]);
                        if (nj_loc > nimax)
                           nimax = nj_loc;
                     }
                     CVectorData < int >imask (5 * nimax + 1);
                     int *pimask = imask.Ptr ();
                     int *plist = pimask + nimax;
                     int *pindarr = plist + nimax;
                     int *piptr = pindarr + nimax;
                     int *pialoc = piptr + nimax;
                     for (i = 0; i < nimax; i++)
                        pimask[i] = -1;
                     int icycle = -1;
                     int indj, k;
                     for (i = 0; i < nlistblk; i++) {
                        icycle++;
                        jblkgl = plistblk_th[i];
                        ind = pindblk_th[jblkgl];
                        nz = pnzblk_th[jblkgl];
                        _Int *pprowsarr = prowsarr[ind].Ptr ();
                        _Int *ppcolsarr = pcolsarr[ind].Ptr ();
                        int nlist_temp = 0;
                        for (j = 0; j < nz; j++) {
                           jj = (int) pprowsarr[j];
                           if (pimask[jj] != icycle) {
                              pimask[jj] = icycle;
                              plist[nlist_temp] = jj;
                              nlist_temp++;
                           }
                        }
                        sort (plist, plist + nlist_temp);
                        pialoc[0] = 0;
                        for (j = 0; j < nlist_temp; j++) {
                           jj = plist[j];
                           pindarr[jj] = j;
                           pialoc[j + 1] = 0;
                        }
                        for (j = 0; j < nz; j++) {
                           jj = (int) pprowsarr[j];
                           indj = pindarr[jj];
                           pialoc[indj + 1]++;
                        }
                        for (j = 0; j < nlist_temp; j++)
                           pialoc[j + 1] += pialoc[j];
                        for (j = 0; j < nlist_temp; j++)
                           piptr[j] = pialoc[j];
                        ppblks_arr[i].ResizeAndSetAllSp (nlist_temp, 0, nz, 0);
                        _Int *plist_new = ppblks_arr[i].GetListArr ();
                        _Int *pia_new = ppblks_arr[i].GetIaArr ();
                        _Int *pja_new = ppblks_arr[i].GetJaArr ();
                        for (j = 0; j < nlist_temp; j++)
                           plist_new[j] = plist[j];
                        for (j = 0; j <= nlist_temp; j++)
                           pia_new[j] = pialoc[j];
                        for (j = 0; j < nz; j++) {
                           jj = (int) pprowsarr[j];
                           indj = pindarr[jj];
                           k = piptr[indj];
                           pja_new[k] = ppcolsarr[j];
                           piptr[indj]++;
                        }
                     }
                  }
               }

               {

                  int nzblk_tot = 0;

                  int i, j;

                  for (i = 0; i < niblk; i++)
                     nzblk_tot += pnzblk_arr[i];

                  _hmatr_arr_fin[ihblk].ResizeASub (nzblk_tot);
                  _hmatr_arr_fin[ihblk].SetNzblk (nzblk_tot);

                  CMatrix < int, float >*pHMatrStr_fin =
                     _hmatr_arr_fin[ihblk].GetHMatrStr ();
                  CMatrix < _Int, _Flt > *pASub_fin = _hmatr_arr_fin[ihblk].GetASubArr ();

                  pHMatrStr_fin->ResizeAndSetAllSp (niblk, niblk, nzblk_tot, nzblk_tot);

                  int *plist_fin = pHMatrStr_fin->GetListArr ();
                  int *plist2_fin = pHMatrStr_fin->GetList2Arr ();
                  int *pia_fin = pHMatrStr_fin->GetIaArr ();
                  int *pja_fin = pHMatrStr_fin->GetJaArr ();
                  int *pja2_fin = pHMatrStr_fin->GetJa2Arr ();

                  for (i = 0; i < niblk; i++)
                     plist_fin[i] = i;
                  for (i = 0; i < niblk; i++)
                     plist2_fin[i] = ihblk;

                  pia_fin[0] = 0;

                  nzblk_tot = 0;

                  for (i = 0; i < niblk; i++) {
                     int *pplist2blk_arr = plist2blk_arr[i].Ptr ();
                     CMatrix < _Int, _Flt > *ppblks_arr = pblks_arr[i].Ptr ();
                     for (j = 0; j < pnzblk_arr[i]; j++) {
                        pja_fin[nzblk_tot] = pplist2blk_arr[j * 2];
                        pja2_fin[nzblk_tot] = pplist2blk_arr[j * 2 + 1];
                        pASub_fin[nzblk_tot].ReplaceFree (ppblks_arr[j]);
                        nzblk_tot++;
                     }
                     pia_fin[i + 1] = nzblk_tot;
                  }
               }

               phblk_rows[ihblk].Clean ();

            }
         }

      }

   }

// Compute reordered hmatrix
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ReorderHMatrix (void *_comm, int _nhblks_ini, int *_hblk2cpu_ini,
                              int *_hblk2blk_ini, long long *_blks_ini, CBMatrix < _Int,
                              _Flt > *_hmatr_arr_ini, long long *_order, int _nhblks_fin,
                              int *_hblk2cpu_fin, int *_hblk2blk_fin,
                              long long *_blks_fin, CBMatrix < _Int,
                              _Flt > *_hmatr_arr_fin)
   {

      int myid = CMPIDataExchange::GetMyid (_comm);
      int nproc = CMPIDataExchange::GetNproc (_comm);

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

// Compute new 3index for all ordering data

      CVectorData < int >ibs_hblk (_nhblks_ini);
      int *pibs_hblk = ibs_hblk.Ptr ();

      int ni_order_ini = 0;

      {
         int ihblk, ibegblk, iendblk;
         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            pibs_hblk[ihblk] = -1;
            if (_hblk2cpu_ini[ihblk] == myid) {
               pibs_hblk[ihblk] = ni_order_ini;
               ibegblk = _hblk2blk_ini[ihblk];
               iendblk = _hblk2blk_ini[ihblk + 1] - 1;
               ni_order_ini += (int) (_blks_ini[iendblk + 1] - _blks_ini[ibegblk]);
            }
         }
      }

      CVectorData < int >order_3index (ni_order_ini * 3);
      int *porder_3index = order_3index.Ptr ();

      {
         int nblks_fin = _hblk2blk_fin[_nhblks_fin];
         CVectorData < int >blk2hblk_fin (nblks_fin);
         int *pblk2hblk_fin = blk2hblk_fin.Ptr ();
         {
            int i, j;
            for (i = 0; i < _nhblks_fin; i++) {
               for (j = _hblk2blk_fin[i]; j < _hblk2blk_fin[i + 1]; j++) {
                  pblk2hblk_fin[j] = i;
               }
            }
         }
         int nparts_split = 4 * n_thr;
         int ni_part = ni_order_ini / nparts_split;
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nparts_split; ipar++) {
            int ibeg = ni_part * ipar;
            int iend = ni_part * (ipar + 1) - 1;
            if (ipar == nparts_split - 1)
               iend = ni_order_ini - 1;
            int niloc = iend - ibeg + 1;
            CVectorData < CSortInt64 > iiarr (niloc);
            CSortInt64 *piiarr = iiarr.Ptr ();
            int i;
            for (i = 0; i < niloc; i++) {
               piiarr[i].ival = _order[ibeg + i];
               piiarr[i].i2val = i;
            }
            sort (piiarr, piiarr + niloc);
            CVectorData < long long >order_sort (niloc);
            long long *porder_sort = order_sort.Ptr ();
            for (i = 0; i < niloc; i++)
               porder_sort[i] = piiarr[i].ival;
            CVectorData < long long >blknum_arr (niloc);
            CVectorData < int >hblknum_arr (niloc);
            long long *pblknum_arr = blknum_arr.Ptr ();
            long long ia_temp[2];
            ia_temp[0] = 0;
            ia_temp[1] = (_Int) niloc;
            CBMatrix < long long, float >::ComputeJa2 (nblks_fin, _blks_fin, 1, ia_temp,
                                                       porder_sort, pblknum_arr);
            long long jj;
            int jblk, jhblk, iold;
            for (i = 0; i < niloc; i++) {
               iold = (int) piiarr[i].i2val;
               jj = porder_sort[i];
               jblk = (int) pblknum_arr[i];
               jhblk = pblk2hblk_fin[jblk];
               jj = jj - _blks_fin[jblk];
               porder_3index[(ibeg + iold) * 3] = (int) jj;
               porder_3index[(ibeg + iold) * 3 + 1] = jblk - _hblk2blk_fin[jhblk];
               porder_3index[(ibeg + iold) * 3 + 2] = jhblk;
            }
         }
      }

// Compute transposed block sparsities

      CVectorData < CMatrix < int, float > >str_hblkT_arr (_nhblks_ini);
      CMatrix < int, float >*pstr_hblkT_arr = str_hblkT_arr.Ptr ();

      CVectorData < CVectorData < int > >indT2N_arr (_nhblks_ini);
      CVectorData < int >*pindT2N_arr = indT2N_arr.Ptr ();

      {

         int nblks_ini = _hblk2blk_ini[_nhblks_ini];

         CVectorData < int >blk2hblk_ini (nblks_ini);
         int *pblk2hblk_ini = blk2hblk_ini.Ptr ();

         {
            for (int i = 0; i < _nhblks_ini; i++) {
               for (int j = _hblk2blk_ini[i]; j < _hblk2blk_ini[i + 1]; j++) {
                  pblk2hblk_ini[j] = i;
               }
            }
         }

         CVectorData < int >imaskblk (nblks_ini * 5 + 1);
         int *pimaskblk = imaskblk.Ptr ();

         int ihblk;

         for (ihblk = 0; ihblk < nblks_ini; ihblk++)
            pimaskblk[ihblk] = -1;

         int icycleblk = -1;

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {

               CMatrix < int, float >*phmatr = _hmatr_arr_ini[ihblk].GetHMatrStr ();

               CMatrix < int, float >str_hblk;
               str_hblk = *phmatr;

// Transform to 1 index

               int nlist_temp = str_hblk.GetNlist ();
               int nzja_temp = str_hblk.GetNzja ();
               int *plist_temp = str_hblk.GetListArr ();
               int *plist2_temp = str_hblk.GetList2Arr ();
               int *pia_temp = str_hblk.GetIaArr ();
               int *pja_temp = str_hblk.GetJaArr ();
               int *pja2_temp = str_hblk.GetJa2Arr ();

               int i, jblk, jhblk;

               for (i = 0; i < nlist_temp; i++) {
                  jblk = plist_temp[i];
                  jhblk = plist2_temp[i];
                  plist_temp[i] = _hblk2blk_ini[jhblk] + jblk;
               }
               for (i = 0; i < nzja_temp; i++) {
                  jblk = pja_temp[i];
                  jhblk = pja2_temp[i];
                  pja_temp[i] = _hblk2blk_ini[jhblk] + jblk;
               }

               str_hblk.SetNlist2 (0);
               str_hblk.SetNzja2 (0);

// Transpose

               CMatrix < int, float >str_hblkT;

               str_hblk.TransposedSparsityListSp (icycleblk, pimaskblk,
                                                  pimaskblk + nblks_ini,
                                                  pimaskblk + nblks_ini * 2,
                                                  pimaskblk + nblks_ini * 3,
                                                  pimaskblk + nblks_ini * 4, str_hblkT);

               int nlist_tempT = str_hblkT.GetNlist ();
               int nzja_tempT = str_hblkT.GetNzja ();
               int *pia_tempT = str_hblkT.GetIaArr ();
               int *pja_tempT = str_hblkT.GetJaArr ();

// Compute transposed reference

               int ibeghblk = _hblk2blk_ini[ihblk];

               pindT2N_arr[ihblk].resize (nzja_tempT);
               int *ppindT2N_arr = pindT2N_arr[ihblk].Ptr ();

               for (i = 0; i < nlist_temp; i++) {
                  pimaskblk[nblks_ini + i] = pia_temp[i];
               }

               int j, jj, k;

               for (i = 0; i < nlist_tempT; i++) {
                  for (j = pia_tempT[i]; j < pia_tempT[i + 1]; j++) {
                     jj = pja_tempT[j] - ibeghblk;
                     k = pimaskblk[nblks_ini + jj];
                     ppindT2N_arr[j] = k;
                     pimaskblk[nblks_ini + jj]++;
                  }
               }

// Modify second index

               str_hblkT.ResizeList2 (nlist_tempT);
               str_hblkT.ResizeJa2 (nzja_tempT);
               str_hblkT.SetNlist2 (nlist_tempT);
               str_hblkT.SetNzja2 (nzja_tempT);

               plist_temp = str_hblkT.GetListArr ();
               plist2_temp = str_hblkT.GetList2Arr ();
               pja_temp = str_hblkT.GetJaArr ();
               pja2_temp = str_hblkT.GetJa2Arr ();

               for (i = 0; i < nlist_tempT; i++) {
                  jblk = plist_temp[i];
                  jhblk = pblk2hblk_ini[jblk];
                  plist_temp[i] = jblk - _hblk2blk_ini[jhblk];
                  plist2_temp[i] = jhblk;
               }
               for (i = 0; i < nzja_tempT; i++) {
                  jblk = pja_temp[i];
                  jhblk = pblk2hblk_ini[jblk];
                  pja_temp[i] = jblk - _hblk2blk_ini[jhblk];
                  pja2_temp[i] = jhblk;
               }

               pstr_hblkT_arr[ihblk].ReplaceFree (str_hblkT);

            }
         }

      }

// Compute column lists for all hblock off-diagonal blocks

      CVectorData < CBMatrix < int, float > >str_cols_arr (_nhblks_ini);
      CBMatrix < int, float >*pstr_cols_arr = str_cols_arr.Ptr ();

      {

         int nblks_ini = _hblk2blk_ini[_nhblks_ini];

         int ihblk;

         int nimax = 0;

         {
            for (int i = 0; i < nblks_ini; i++) {
               int niloc = (int) (_blks_ini[i + 1] - _blks_ini[i]);
               if (niloc > nimax)
                  nimax = niloc;
            }
         }

         CVectorData < int >imask_threads (nimax * 2 * n_thr + 1);
         CVectorData < int >icycle_threads (n_thr + 1);

         int *pimask_threads = imask_threads.Ptr ();
         int *picycle_threads = icycle_threads.Ptr ();

         for (ihblk = 0; ihblk < n_thr; ihblk++)
            picycle_threads[ihblk] = -1;

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {

// Local column sparsity

               CMatrix < _Int, _Flt > *pASub = _hmatr_arr_ini[ihblk].GetASubArr ();
               CMatrix < int, float >*phmatr = _hmatr_arr_ini[ihblk].GetHMatrStr ();

               int nzja_temp = phmatr->GetNzja ();
               int *pja2_temp = phmatr->GetJa2Arr ();

               {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < nzja_temp; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif
                     if (pja2_temp[ipar] != ihblk) {

                        int *pimask_th = pimask_threads + 2 * nimax * my_thr;
                        int icycle_th = picycle_threads[my_thr];

                        if (icycle_th == -1) {
                           for (int j = 0; j < nimax; j++)
                              pimask_th[j] = -1;
                        }

                        icycle_th++;

                        pASub[ipar].ComputeList2 (icycle_th, pimask_th,
                                                  pimask_th + nimax);

                        picycle_threads[my_thr] = icycle_th;
                     }
                  }

               }

// Add column sparsity in block columns

               int nlistT_hblk = pstr_hblkT_arr[ihblk].GetNlist ();
               int *plistT_hblk = pstr_hblkT_arr[ihblk].GetListArr ();
               int *plist2T_hblk = pstr_hblkT_arr[ihblk].GetList2Arr ();
               int *piaT_hblk = pstr_hblkT_arr[ihblk].GetIaArr ();

               int nlistblk_off = 0;

               {
                  int jhblk;
                  for (int i = 0; i < nlistT_hblk; i++) {
                     jhblk = plist2T_hblk[i];
                     if (jhblk != ihblk)
                        nlistblk_off++;
                  }
               }

               pstr_cols_arr[ihblk].SetNzblk (nlistblk_off);
               pstr_cols_arr[ihblk].ResizeASub (nlistblk_off);

               CMatrix < int, float >*pASub_cols = pstr_cols_arr[ihblk].GetASubArr ();
               CMatrix < int, float >*phmatr_cols = pstr_cols_arr[ihblk].GetHMatrStr ();

               phmatr_cols->ResizeAndSetAllSp (nlistblk_off, nlistblk_off, nlistblk_off,
                                               nlistblk_off);

               int *plist_cols = phmatr_cols->GetListArr ();
               int *plist2_cols = phmatr_cols->GetList2Arr ();
               int *pia_cols = phmatr_cols->GetIaArr ();
               int *pja_cols = phmatr_cols->GetJaArr ();
               int *pja2_cols = phmatr_cols->GetJa2Arr ();

               {
                  for (int i = 0; i <= nlistblk_off; i++)
                     pia_cols[i] = i;
               }

               CVectorData < int >indblk (nlistblk_off);
               int *pindblk = indblk.Ptr ();

               nlistblk_off = 0;

               int *ppindT2N_arr = pindT2N_arr[ihblk].Ptr ();

               {
                  int jblk, jhblk;
                  for (int i = 0; i < nlistT_hblk; i++) {
                     jblk = plistT_hblk[i];
                     jhblk = plist2T_hblk[i];
                     if (jhblk != ihblk) {
                        pindblk[nlistblk_off] = i;
                        plist_cols[nlistblk_off] = i;
                        plist2_cols[nlistblk_off] = ihblk;
                        pja_cols[nlistblk_off] = jblk;
                        pja2_cols[nlistblk_off] = jhblk;
                        nlistblk_off++;
                     }
                  }
               }

               {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < nlistblk_off; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif

                     int *pimask_th = pimask_threads + 2 * nimax * my_thr;
                     int *plist_th = pimask_th + nimax;
                     int icycle_th = picycle_threads[my_thr];

                     if (icycle_th == -1) {
                        for (int j = 0; j < nimax; j++)
                           pimask_th[j] = -1;
                     }

                     icycle_th++;

                     int ind = pindblk[ipar];

                     int i, indj, j, jj;

                     int nlistloc = 0;

                     for (i = piaT_hblk[ind]; i < piaT_hblk[ind + 1]; i++) {
                        indj = ppindT2N_arr[i];
                        int nlist2_temp = pASub[indj].GetNlist2 ();
                        _Int *plist2_temp = pASub[indj].GetList2Arr ();
                        for (j = 0; j < nlist2_temp; j++) {
                           jj = (int) plist2_temp[j];
                           if (pimask_th[jj] != icycle_th) {
                              pimask_th[jj] = icycle_th;
                              plist_th[nlistloc] = jj;
                              nlistloc++;
                           }
                        }
                     }

                     sort (plist_th, plist_th + nlistloc);

                     pASub_cols[ipar].ResizeList2 (nlistloc);
                     pASub_cols[ipar].SetNlist2 (nlistloc);

                     int *plist2_new = pASub_cols[ipar].GetList2Arr ();

                     for (i = 0; i < nlistloc; i++)
                        plist2_new[i] = plist_th[i];

                     picycle_threads[my_thr] = icycle_th;

                  }
               }

            }
         }

      }

// Prepare send data

      vector < int >listcpu (nproc + 1);
      int *plistcpu = &listcpu[0];

      int nlistcpu = 0;

      CVectorData < CBMatrix < int, float > >hblk_send;

      {

         int i;

         vector < int >imaskcpu (nproc + 1);
         int *pimaskcpu = &imaskcpu[0];

         for (i = 0; i < nproc; i++)
            pimaskcpu[i] = -1;

         int j, jj2, jproc;

         for (i = 0; i < _nhblks_ini; i++) {
            if (_hblk2cpu_ini[i] == myid) {
               CMatrix < int, float >*phmatr = pstr_cols_arr[i].GetHMatrStr ();
               int nzja_temp = phmatr->GetNzja ();
               int *pja2_temp = phmatr->GetJa2Arr ();
               for (j = 0; j < nzja_temp; j++) {
                  jj2 = pja2_temp[j];
                  jproc = _hblk2cpu_ini[jj2];
                  if (pimaskcpu[jproc] < 0) {
                     plistcpu[nlistcpu] = jproc;
                     nlistcpu++;
                     pimaskcpu[jproc] = 1;
                  }
               }
            }
         }

         sort (plistcpu, plistcpu + nlistcpu);

         for (i = 0; i < nlistcpu; i++) {
            j = plistcpu[i];
            pimaskcpu[j] = i;
         }

         vector < int >nzblk_cpu (nlistcpu + 1);
         int *pnzblk_cpu = &nzblk_cpu[0];

         for (i = 0; i < nlistcpu; i++)
            pnzblk_cpu[i] = 0;

         int ind;

         for (i = 0; i < _nhblks_ini; i++) {
            if (_hblk2cpu_ini[i] == myid) {
               CMatrix < int, float >*phmatr = pstr_cols_arr[i].GetHMatrStr ();
               int nzja_temp = phmatr->GetNzja ();
               int *pja2_temp = phmatr->GetJa2Arr ();
               for (j = 0; j < nzja_temp; j++) {
                  jj2 = pja2_temp[j];
                  jproc = _hblk2cpu_ini[jj2];
                  ind = pimaskcpu[jproc];
                  pnzblk_cpu[ind]++;
               }
            }
         }

         hblk_send.resize (nlistcpu);

         CBMatrix < int, float >*phblk_send = hblk_send.Ptr ();

         for (i = 0; i < nlistcpu; i++) {
            phblk_send[i].ResizeASub (pnzblk_cpu[i]);
            phblk_send[i].SetNzblk (pnzblk_cpu[i]);
            CMatrix < int, float >*phmatr = phblk_send[i].GetHMatrStr ();
            phmatr->ResizeAndSetAllSp (pnzblk_cpu[i], pnzblk_cpu[i], pnzblk_cpu[i],
                                       pnzblk_cpu[i]);
         }

         for (i = 0; i < nlistcpu; i++)
            pnzblk_cpu[i] = 0;

         int k, jj, ind_ini;

         for (i = 0; i < _nhblks_ini; i++) {
            if (_hblk2cpu_ini[i] == myid) {
               CMatrix < int, float >*pASub = pstr_cols_arr[i].GetASubArr ();
               CMatrix < int, float >*phmatr = pstr_cols_arr[i].GetHMatrStr ();
               int nzja_temp = phmatr->GetNzja ();
               int *plist_temp = phmatr->GetListArr ();
               int *pja_temp = phmatr->GetJaArr ();
               int *pja2_temp = phmatr->GetJa2Arr ();
               for (j = 0; j < nzja_temp; j++) {
                  ind_ini = plist_temp[j];
                  jj = pja_temp[j];
                  jj2 = pja2_temp[j];
                  jproc = _hblk2cpu_ini[jj2];
                  ind = pimaskcpu[jproc];
                  k = pnzblk_cpu[ind];
                  CMatrix < int, float >*pASub_temp = phblk_send[ind].GetASubArr ();
                  CMatrix < int, float >*phmatr_temp = phblk_send[ind].GetHMatrStr ();
                  int *plist_temp2 = phmatr_temp->GetListArr ();
                  int *plist2_temp2 = phmatr_temp->GetList2Arr ();
                  int *pja_temp2 = phmatr_temp->GetJaArr ();
                  int *pja2_temp2 = phmatr_temp->GetJa2Arr ();
                  plist_temp2[k] = ind_ini;
                  plist2_temp2[k] = i;
                  pja_temp2[k] = jj;
                  pja2_temp2[k] = jj2;
                  pASub_temp[k].ReplaceFree (pASub[j]);
                  pnzblk_cpu[ind]++;
               }
            }
         }

      }

// Pack send data

      vector < int >CpuIDSend (nlistcpu);
      vector < vector < char > >ObjSend (nlistcpu);

      int *pCpuIDSend = NULL;
      vector < char >*pObjSend = NULL;

      if (nlistcpu > 0) {
         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];
      }

      {

         CBMatrix < int, float >*phblk_send = hblk_send.Ptr ();

         long long isize;
         char *pobj;

         int i;

         for (i = 0; i < nlistcpu; i++) {
            pCpuIDSend[i] = plistcpu[i];
            isize = phblk_send[i].GetPackedSize ();
            pObjSend[i].resize ((size_t) isize);
            pobj = &(pObjSend[i][0]);
            phblk_send[i].FillPacked_thr (isize, pobj);
            phblk_send[i].Clean ();
         }

      }

// Exchange

      vector < int >CpuIDRecv;
      vector < vector < char > >ObjRecv;

      CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      int nrecv = (int) CpuIDRecv.size ();

      vector < char >*pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      vector < CBMatrix < int, float > >hblk_recv (nrecv + 1);

      CBMatrix < int, float >*phblk_recv = &hblk_recv[0];

      {

         long long isize;
         char *pobj;

         int i;

         for (i = 0; i < nrecv; i++) {
            isize = (long long) pObjRecv[i].size ();
            pobj = &(pObjRecv[i][0]);
            phblk_recv[i].UnPack_thr (isize, pobj);
         }

      }

// Free recv data

      {
         vector < vector < char > >ObjRecv_temp;
         ObjRecv.swap (ObjRecv_temp);
      }

// Fill 3index data inside blocks

      {
         int irecv;
         for (irecv = 0; irecv < nrecv; irecv++) {
            CMatrix < int, float >*pASub_recv = phblk_recv[irecv].GetASubArr ();
            CMatrix < int, float >*phmatr_recv = phblk_recv[irecv].GetHMatrStr ();
            int nzja_recv = phmatr_recv->GetNzja ();
            int *pja_recv = phmatr_recv->GetJaArr ();
            int *pja2_recv = phmatr_recv->GetJa2Arr ();
            {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
               for (int ipar = 0; ipar < nzja_recv; ipar++) {
                  int jblk = pja_recv[ipar];
                  int jhblk = pja2_recv[ipar];
                  int nlist2_temp = pASub_recv[ipar].GetNlist2 ();
                  int *plist2_temp = pASub_recv[ipar].GetList2Arr ();
                  pASub_recv[ipar].ResizeJa2 (3 * nlist2_temp);
                  pASub_recv[ipar].SetNzja2 (3 * nlist2_temp);
                  int *pja2_temp = pASub_recv[ipar].GetJa2Arr ();
                  int j, jj;
                  int ibegblk = _hblk2blk_ini[jhblk];
                  int ibs =
                     pibs_hblk[jhblk] + (int) (_blks_ini[jblk + ibegblk] -
                                               _blks_ini[ibegblk]);
                  for (j = 0; j < nlist2_temp; j++) {
                     jj = plist2_temp[j];
                     pja2_temp[j * 3] = porder_3index[(ibs + jj) * 3];
                     pja2_temp[j * 3 + 1] = porder_3index[(ibs + jj) * 3 + 1];
                     pja2_temp[j * 3 + 2] = porder_3index[(ibs + jj) * 3 + 2];
                  }
               }
            }

         }
      }

// Pack data

      ObjRecv.resize (nrecv);

      pObjSend = NULL;

      if (nrecv > 0) {
         pObjSend = &ObjRecv[0];
      }

      {

         long long isize;
         char *pobj;

         int i;

         for (i = 0; i < nrecv; i++) {
            isize = phblk_recv[i].GetPackedSize ();
            pObjSend[i].resize ((size_t) isize);
            pobj = &(pObjSend[i][0]);
            phblk_recv[i].FillPacked_thr (isize, pobj);
            phblk_recv[i].Clean ();
         }

      }

// Send data back

      CMPIDataExchange::DataExchange (_comm, CpuIDRecv, ObjRecv, CpuIDSend, ObjSend);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDRecv.swap (CpuIDSend_temp);
         ObjRecv.swap (ObjSend_temp);
      }

// Unpack receive data

      nrecv = (int) CpuIDSend.size ();

      pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjSend[0];
      }

      hblk_recv.resize (nrecv + 1);

      phblk_recv = &hblk_recv[0];

      {

         long long isize;
         char *pobj;

         int i;

         for (i = 0; i < nrecv; i++) {
            isize = (long long) pObjRecv[i].size ();
            pobj = &(pObjRecv[i][0]);
            phblk_recv[i].UnPack_thr (isize, pobj);
         }

      }

// Free recv data

      {
         vector < int >CpuIDRecv_temp;
         vector < vector < char > >ObjRecv_temp;
         CpuIDSend.swap (CpuIDRecv_temp);
         ObjSend.swap (ObjRecv_temp);
      }

// Allocate and fill ja2 for all own blocks

      {

         int ihblk;
         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               int niblk = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
               CMatrix < _Int, _Flt > *pASub = _hmatr_arr_ini[ihblk].GetASubArr ();
               CMatrix < int, float >*phmatr = _hmatr_arr_ini[ihblk].GetHMatrStr ();
               int *pia_hblk = phmatr->GetIaArr ();
               int *pja_hblk = phmatr->GetJaArr ();
               int *pja2_hblk = phmatr->GetJa2Arr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int i, j, jj, jblk, jhblk;
                     int ibegblk = _hblk2blk_ini[ihblk];
                     for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                        jblk = pja_hblk[i];
                        jhblk = pja2_hblk[i];
                        int nzja_temp = pASub[i].GetNzja ();
                        _Int *pja_temp = pASub[i].GetJaArr ();
                        pASub[i].ResizeJa2 (3 * nzja_temp);
                        pASub[i].SetNzja2 (3 * nzja_temp);
                        _Int *pja2_temp = pASub[i].GetJa2Arr ();
                        if (jhblk == ihblk) {
                           int ibs =
                              pibs_hblk[ihblk] + (int) (_blks_ini[jblk + ibegblk] -
                                                        _blks_ini[ibegblk]);
                           for (j = 0; j < nzja_temp; j++) {
                              jj = (int) pja_temp[j];
                              pja2_temp[j * 3] = porder_3index[(ibs + jj) * 3];
                              pja2_temp[j * 3 + 1] = porder_3index[(ibs + jj) * 3 + 1];
                              pja2_temp[j * 3 + 2] = porder_3index[(ibs + jj) * 3 + 2];
                           }
                        }
                     }
                  }
               }
            }
         }

      }

// Compute Ptrs to 3indices data for not own blocks and fill ja2 for off hblocks

      CVectorData < CVectorData < CMatrix < int, float >*> >ptr3indT_arr (_nhblks_ini);
      CVectorData < CMatrix < int, float >*>*pptr3indT_arr = ptr3indT_arr.Ptr ();

      {

         int ihblk;

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               int nlistT_hblk = pstr_hblkT_arr[ihblk].GetNlist ();
               pptr3indT_arr[ihblk].resize (nlistT_hblk);
               CMatrix < int, float >**ppptr3indT_arr = pptr3indT_arr[ihblk].Ptr ();
               for (int i = 0; i < nlistT_hblk; i++)
                  ppptr3indT_arr[i] = NULL;
            }
         }

         {
            int ind_ini;
            for (int i = 0; i < nrecv; i++) {
               CMatrix < int, float >*pASub = phblk_recv[i].GetASubArr ();
               CMatrix < int, float >*phmatr = phblk_recv[i].GetHMatrStr ();
               int nlist_recv = phmatr->GetNlist ();
               int *plist_recv = phmatr->GetListArr ();
               int *plist2_recv = phmatr->GetList2Arr ();
               for (int j = 0; j < nlist_recv; j++) {
                  ind_ini = plist_recv[j];
                  ihblk = plist2_recv[j];
                  CMatrix < int, float >**ppptr3indT_arr = pptr3indT_arr[ihblk].Ptr ();
                  ppptr3indT_arr[ind_ini] = pASub + j;
               }
            }
         }

         {

            int nblks_ini = _hblk2blk_ini[_nhblks_ini];

            int nimax = 0;

            {
               for (int i = 0; i < nblks_ini; i++) {
                  int niloc = (int) (_blks_ini[i + 1] - _blks_ini[i]);
                  if (niloc > nimax)
                     nimax = niloc;
               }
            }

            CVectorData < int >imask_threads (nimax * n_thr + 1);
            int *pimask_threads = imask_threads.Ptr ();

            for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
               if (_hblk2cpu_ini[ihblk] == myid) {
                  CMatrix < _Int, _Flt > *pASub = _hmatr_arr_ini[ihblk].GetASubArr ();

                  int nlistT_hblk = pstr_hblkT_arr[ihblk].GetNlist ();
                  int *plist2T_hblk = pstr_hblkT_arr[ihblk].GetList2Arr ();
                  int *piaT_hblk = pstr_hblkT_arr[ihblk].GetIaArr ();

                  int *ppindT2N_arr = pindT2N_arr[ihblk].Ptr ();

                  {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                     for (int ipar = 0; ipar < nlistT_hblk; ipar++) {
                        int my_thr = 0;
#ifdef USE_THREADS
                        my_thr = omp_get_thread_num ();
#endif

                        int *pimask_th = pimask_threads + nimax * my_thr;

                        int i, j, jj, indj, k;

                        if (plist2T_hblk[ipar] != ihblk) {
                           CMatrix < int, float >**ppptr3indT_arr =
                              pptr3indT_arr[ihblk].Ptr ();
                           CMatrix < int, float >*ptr_3index_matr = ppptr3indT_arr[ipar];
                           int nlist2_3ind = ptr_3index_matr->GetNlist2 ();
                           int *plist2_3ind = ptr_3index_matr->GetList2Arr ();
                           int *pja2_3ind = ptr_3index_matr->GetJa2Arr ();
                           for (i = 0; i < nlist2_3ind; i++) {
                              jj = plist2_3ind[i];
                              pimask_th[jj] = i;
                           }
                           for (i = piaT_hblk[ipar]; i < piaT_hblk[ipar + 1]; i++) {
                              indj = ppindT2N_arr[i];
                              int nzja_temp = pASub[indj].GetNzja ();
                              _Int *pja_temp = pASub[indj].GetJaArr ();
                              _Int *pja2_temp = pASub[indj].GetJa2Arr ();
                              for (j = 0; j < nzja_temp; j++) {
                                 jj = (int) pja_temp[j];
                                 k = pimask_th[jj];
                                 pja2_temp[3 * j] = pja2_3ind[3 * k];
                                 pja2_temp[3 * j + 1] = pja2_3ind[3 * k + 1];
                                 pja2_temp[3 * j + 2] = pja2_3ind[3 * k + 2];
                              }
                           }
                        }
                     }
                  }
               }
            }

         }

      }

// Compute block rows with 3indices as column numbers

      CVectorData < CBMatrix < _Int, _Flt > >hblk_rows (_nhblks_ini);
      CBMatrix < _Int, _Flt > *phblk_rows = hblk_rows.Ptr ();

      {
         int ihblk;
         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               int niblk = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
               phblk_rows[ihblk].SetNzblk (niblk);
               phblk_rows[ihblk].ResizeASub (niblk);
               CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
               CMatrix < _Int, _Flt > *pASub = _hmatr_arr_ini[ihblk].GetASubArr ();
               CMatrix < int, float >*phmatr = _hmatr_arr_ini[ihblk].GetHMatrStr ();
               int *pia_hblk = phmatr->GetIaArr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int iblkgl = _hblk2blk_ini[ihblk] + ipar;
                     int ibegblk = _hblk2blk_ini[ihblk];
                     int ibs =
                        pibs_hblk[ihblk] + (int) (_blks_ini[ipar + ibegblk] -
                                                  _blks_ini[ibegblk]);
                     int ni_loc = (int) (_blks_ini[iblkgl + 1] - _blks_ini[iblkgl]);
                     int nzja_loc = 0;
                     int i;
                     for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                        nzja_loc += pASub[i].GetNzja ();
                     }
                     pASub_rows[ipar].ResizeAndSetAll (ni_loc, ni_loc * 3, 0,
                                                       nzja_loc * 3, nzja_loc);
                     _Int *plist_rows = pASub_rows[ipar].GetListArr ();
                     _Int *plist2_rows = pASub_rows[ipar].GetList2Arr ();
                     _Int *pia_rows = pASub_rows[ipar].GetIaArr ();
                     _Int *pja2_rows = pASub_rows[ipar].GetJa2Arr ();
                     _Flt *pa_rows = pASub_rows[ipar].GetAArr ();
                     for (i = 0; i < ni_loc; i++)
                        plist_rows[i] = (_Int) i;
                     for (i = 0; i <= ni_loc; i++)
                        pia_rows[i] = 0;
                     int j, jj, k, kind;
                     for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                        int nlist_temp = pASub[i].GetNlist ();
                        _Int *plist_temp = pASub[i].GetListArr ();
                        _Int *pia_temp = pASub[i].GetIaArr ();
                        for (j = 0; j < nlist_temp; j++) {
                           jj = (int) plist_temp[j];
                           pia_rows[jj + 1] += (pia_temp[j + 1] - pia_temp[j]);
                        }
                     }
                     for (i = 0; i < ni_loc; i++)
                        pia_rows[i + 1] += pia_rows[i];
                     CVectorData < int >iptr (ni_loc);
                     int *piptr = iptr.Ptr ();
                     for (i = 0; i < ni_loc; i++)
                        piptr[i] = (int) pia_rows[i];
                     for (i = 0; i < 3 * ni_loc; i++)
                        plist2_rows[i] = porder_3index[ibs * 3 + i];
                     for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                        int nlist_temp = pASub[i].GetNlist ();
                        _Int *plist_temp = pASub[i].GetListArr ();
                        _Int *pia_temp = pASub[i].GetIaArr ();
                        _Int *pja2_temp = pASub[i].GetJa2Arr ();
                        _Flt *pa_temp = pASub[i].GetAArr ();
                        for (j = 0; j < nlist_temp; j++) {
                           jj = (int) plist_temp[j];
                           kind = piptr[jj];
                           for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                              pja2_rows[kind * 3] = pja2_temp[k * 3];
                              pja2_rows[kind * 3 + 1] = pja2_temp[k * 3 + 1];
                              pja2_rows[kind * 3 + 2] = pja2_temp[k * 3 + 2];
                              pa_rows[kind] = pa_temp[k];
                              kind++;
                           }
                           piptr[jj] = kind;;
                        }
                     }
                     for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                        pASub[i].ResizeList2 (0);
                        pASub[i].ResizeJa2 (0);
                        pASub[i].SetNlist2 (0);
                        pASub[i].SetNzja2 (0);
                     }
                  }
               }
            }
         }

      }

// Prepare sends

      CBMatrix < _Int, _Flt > hblk_myid;

      {

         int nblks_fin = _hblk2blk_fin[_nhblks_fin];

         CVectorData < int >imaskblk_threads (nblks_fin * 12 * n_thr);
         CVectorData < int >icycleblk_threads (2 * n_thr);
         CVectorData < int >nblk_threads (n_thr);

         int *pimaskblk_threads = imaskblk_threads.Ptr ();
         int *picycleblk_threads = icycleblk_threads.Ptr ();
         int *pnblk_threads = nblk_threads.Ptr ();

         {
            int i;
            for (i = 0; i < 2 * n_thr; i++)
               picycleblk_threads[i] = -1;
            for (i = 0; i < n_thr; i++)
               pnblk_threads[i] = 0;
         }

         int ihblk;

         CVectorData < CVectorData < int > >nzblk_arr (_nhblks_ini);
         CVectorData < CVectorData < vector < int > > >listblk_arr (_nhblks_ini);

         CVectorData < int >*pnzblk_arr = nzblk_arr.Ptr ();
         CVectorData < vector < int > >*plistblk_arr = listblk_arr.Ptr ();

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
               int niblk = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
               pnzblk_arr[ihblk].resize (niblk);
               plistblk_arr[ihblk].resize (niblk);
               int *ppnzblk_arr = pnzblk_arr[ihblk].Ptr ();
               vector < int >*pplistblk_arr = plistblk_arr[ihblk].Ptr ();
               {
                  for (int i = 0; i < niblk; i++)
                     ppnzblk_arr[i] = 0;
               }
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif
                     int *pimaskblk_th = pimaskblk_threads + 12 * nblks_fin * my_thr;
                     int *pimaskblk1_th = pimaskblk_th + nblks_fin;
                     int *pindblk_th = pimaskblk_th + 2 * nblks_fin;
                     int *pindblk1_th = pindblk_th + nblks_fin;
                     int *plistblk_th = pindblk_th + 2 * nblks_fin;
                     int *plistblk1_th = plistblk_th + 4 * nblks_fin;
                     int icycleblk_th = picycleblk_threads[2 * my_thr];
                     int icycleblk1_th = picycleblk_threads[2 * my_thr + 1];
                     int nblk_th = pnblk_threads[my_thr];

                     int i;

                     if (icycleblk_th == -1) {
                        for (i = 0; i < 2 * nblks_fin; i++)
                           pimaskblk_th[i] = -1;
                        icycleblk_th = 0;
                     }

                     icycleblk1_th++;

                     int iblkgl = _hblk2blk_ini[ihblk] + ipar;
                     int ni_loc = (int) (_blks_ini[iblkgl + 1] - _blks_ini[iblkgl]);
                     _Int *plist2_temp = pASub_rows[ipar].GetList2Arr ();
                     _Int *pia_temp = pASub_rows[ipar].GetIaArr ();
                     int jblk, jhblk, jblkgl, ind;
                     int nblk1_th = 0;
                     for (i = 0; i < ni_loc; i++) {
                        jblk = (int) plist2_temp[i * 3 + 1];
                        jhblk = (int) plist2_temp[i * 3 + 2];
                        jblkgl = _hblk2blk_fin[jhblk] + jblk;
                        if (pimaskblk_th[jblkgl] != icycleblk_th) {
                           pimaskblk_th[jblkgl] = icycleblk_th;
                           pindblk_th[jblkgl] = nblk_th;
                           plistblk_th[nblk_th * 4] = jblk;
                           plistblk_th[nblk_th * 4 + 1] = jhblk;
                           plistblk_th[nblk_th * 4 + 2] = 0;
                           plistblk_th[nblk_th * 4 + 3] = 0;
                           nblk_th++;
                        }
                        if (pimaskblk1_th[jblkgl] != icycleblk1_th) {
                           pimaskblk1_th[jblkgl] = icycleblk1_th;
                           pindblk1_th[jblkgl] = nblk1_th;
                           plistblk1_th[nblk1_th * 4] = jblk;
                           plistblk1_th[nblk1_th * 4 + 1] = jhblk;
                           plistblk1_th[nblk1_th * 4 + 2] = 0;
                           plistblk1_th[nblk1_th * 4 + 3] = 0;
                           nblk1_th++;
                        }
                        ind = pindblk_th[jblkgl];
                        plistblk_th[ind * 4 + 2]++;
                        plistblk_th[ind * 4 + 3] += (int) (pia_temp[i + 1] - pia_temp[i]);
                        ind = pindblk1_th[jblkgl];
                        plistblk1_th[ind * 4 + 2]++;
                        plistblk1_th[ind * 4 + 3] +=
                           (int) (pia_temp[i + 1] - pia_temp[i]);
                     }
                     ppnzblk_arr[ipar] = nblk1_th;
                     for (i = 0; i < 4 * nblk1_th; i++) {
                        pplistblk_arr[ipar].push_back (plistblk1_th[i]);
                     }
                     picycleblk_threads[2 * my_thr] = icycleblk_th;
                     picycleblk_threads[2 * my_thr + 1] = icycleblk1_th;
                     pnblk_threads[my_thr] = nblk_th;
                  }
               }
            }
         }

         {
            int i, i_thr, jblk, jhblk, jblkgl, ind;
            for (i_thr = 1; i_thr < n_thr; i_thr++) {
               int *pimaskblk_th0 = pimaskblk_threads;
               int *pindblk_th0 = pimaskblk_th0 + 2 * nblks_fin;
               int *plistblk_th0 = pindblk_th0 + 2 * nblks_fin;
               int icycleblk_th0 = picycleblk_threads[0];
               int nblk_th0 = pnblk_threads[0];
               if (icycleblk_th0 == -1) {
                  for (i = 0; i < 2 * nblks_fin; i++)
                     pimaskblk_th0[i] = -1;
                  icycleblk_th0 = 0;
               }
               int *pimaskblk_th = pimaskblk_threads + 12 * nblks_fin * i_thr;
               int *plistblk_th = pimaskblk_th + 4 * nblks_fin;
               int nblk_th = pnblk_threads[i_thr];
               for (i = 0; i < nblk_th; i++) {
                  jblk = plistblk_th[4 * i];
                  jhblk = plistblk_th[4 * i + 1];
                  jblkgl = _hblk2blk_fin[jhblk] + jblk;
                  if (pimaskblk_th0[jblkgl] != icycleblk_th0) {
                     pimaskblk_th0[jblkgl] = icycleblk_th0;
                     pindblk_th0[jblkgl] = nblk_th0;
                     plistblk_th0[nblk_th0 * 4] = jblk;
                     plistblk_th0[nblk_th0 * 4 + 1] = jhblk;
                     plistblk_th0[nblk_th0 * 4 + 2] = 0;
                     plistblk_th0[nblk_th0 * 4 + 3] = 0;
                     nblk_th0++;
                  }
                  ind = pindblk_th0[jblkgl];
                  plistblk_th0[ind * 4 + 2] += plistblk_th[4 * i + 2];
                  plistblk_th0[ind * 4 + 3] += plistblk_th[4 * i + 3];
               }
               pnblk_threads[0] = nblk_th0;
               picycleblk_threads[0] = icycleblk_th0;
            }
         }

// Sort obtained list of blocks

         int nblks_curr = pnblk_threads[0];
         int *plist4ind_th0 = pimaskblk_threads + 4 * nblks_fin;

         CVectorData < int >list4ind_curr (nblks_curr * 4);
         int *plist4ind_curr = list4ind_curr.Ptr ();

         {
            CVectorData < CSortInt2 > ii2arr (nblks_curr);
            CSortInt2 *pii2arr = ii2arr.Ptr ();
            int i;
            for (i = 0; i < nblks_curr; i++) {
               pii2arr[i].ixval = plist4ind_th0[i * 4 + 1];
               pii2arr[i].iyval = plist4ind_th0[i * 4];
               pii2arr[i].itail = i;
            }
            sort (pii2arr, pii2arr + nblks_curr);
            int ind;
            for (i = 0; i < nblks_curr; i++) {
               ind = pii2arr[i].itail;
               plist4ind_curr[i * 4] = plist4ind_th0[ind * 4];
               plist4ind_curr[i * 4 + 1] = plist4ind_th0[ind * 4 + 1];
               plist4ind_curr[i * 4 + 2] = plist4ind_th0[ind * 4 + 2];
               plist4ind_curr[i * 4 + 3] = plist4ind_th0[ind * 4 + 3];
            }
         }

// Allocate blocks for data store

         CVectorData < int >imaskhblk (_nhblks_fin);
         CVectorData < int >listhblk (_nhblks_fin);
         CVectorData < int >ibshblk (_nhblks_fin);

         int *pimaskhblk = imaskhblk.Ptr ();
         int *plisthblk = listhblk.Ptr ();
         int *pibshblk = ibshblk.Ptr ();

         int nlisthblk_curr = 0;
         int nzblk_hblk = 0;

         {
            int i, jhblk;
            for (i = 0; i < _nhblks_fin; i++)
               pimaskhblk[i] = -1;
            for (i = 0; i < nblks_curr; i++) {
               jhblk = plist4ind_curr[i * 4 + 1];
               if (pimaskhblk[jhblk] < 0) {
                  plisthblk[nlisthblk_curr] = jhblk;
                  nlisthblk_curr++;
                  pimaskhblk[jhblk] = 1;
               }
            }
            sort (plisthblk, plisthblk + nlisthblk_curr);
            for (i = 0; i < nlisthblk_curr; i++) {
               jhblk = plisthblk[i];
               pibshblk[jhblk] = nzblk_hblk;
               nzblk_hblk += (_hblk2blk_fin[jhblk + 1] - _hblk2blk_fin[jhblk]);
            }
         }

// Compute references to blocks and allocate memory

         CVectorData < int >ind2blks (nzblk_hblk);
         int *pind2blks = ind2blks.Ptr ();

         {
            int i, jblk, jhblk, ibs;
            for (i = 0; i < nzblk_hblk; i++)
               pind2blks[i] = -1;
            for (i = 0; i < nblks_curr; i++) {
               jblk = plist4ind_curr[i * 4];
               jhblk = plist4ind_curr[i * 4 + 1];
               ibs = pibshblk[jhblk];
               pind2blks[ibs + jblk] = i;
            }
         }

         CVectorData < CMatrix < _Int, _Flt > >blkrows_new (nblks_curr);
         CMatrix < _Int, _Flt > *pblkrows_new = blkrows_new.Ptr ();

         {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nblks_curr; ipar++) {
               int nlist_temp = plist4ind_curr[ipar * 4 + 2];
               int nzja_temp = plist4ind_curr[ipar * 4 + 3];
               pblkrows_new[ipar].ResizeAndSetAll (nlist_temp, 3 * nlist_temp, 0,
                                                   3 * nzja_temp, nzja_temp);
               _Int *pia_rows_new = pblkrows_new[ipar].GetIaArr ();
               pia_rows_new[0] = 0;
               plist4ind_curr[ipar * 4 + 2] = 0;
               plist4ind_curr[ipar * 4 + 3] = 0;
            }

         }

// Compute local references in terms of stored initial block row data

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               int niblk = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
               int *ppnzblk_arr = pnzblk_arr[ihblk].Ptr ();
               vector < int >*pplistblk_arr = plistblk_arr[ihblk].Ptr ();
               int i, j, nlist_temp, nzja_temp, ind, jblk, jhblk, ibs;
               for (i = 0; i < niblk; i++) {
                  int *ppplistblk_arr = NULL;
                  if (ppnzblk_arr[i] > 0)
                     ppplistblk_arr = &pplistblk_arr[i][0];
                  for (j = 0; j < ppnzblk_arr[i]; j++) {
                     jblk = ppplistblk_arr[j * 4];
                     jhblk = ppplistblk_arr[j * 4 + 1];
                     nlist_temp = ppplistblk_arr[j * 4 + 2];
                     nzja_temp = ppplistblk_arr[j * 4 + 3];
                     ibs = pibshblk[jhblk];
                     ind = pind2blks[ibs + jblk];
                     ppplistblk_arr[j * 4 + 2] = plist4ind_curr[ind * 4 + 2];
                     ppplistblk_arr[j * 4 + 3] = plist4ind_curr[ind * 4 + 3];
                     plist4ind_curr[ind * 4 + 2] += nlist_temp;
                     plist4ind_curr[ind * 4 + 3] += nzja_temp;
                  }
               }
            }
         }

// Rewrite block row data

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
               int niblk = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
               int *ppnzblk_arr = pnzblk_arr[ihblk].Ptr ();
               vector < int >*pplistblk_arr = plistblk_arr[ihblk].Ptr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif
                     int *pimaskblk_th = pimaskblk_threads + 12 * nblks_fin * my_thr;
                     int *pindblk_th = pimaskblk_th + 2 * nblks_fin;
                     int *pindblk1_th = pindblk_th + nblks_fin;

                     int *ppplistblk_arr = NULL;
                     if (ppnzblk_arr[ipar] > 0)
                        ppplistblk_arr = &pplistblk_arr[ipar][0];

                     int iblkgl = _hblk2blk_ini[ihblk] + ipar;
                     int ni_loc = (int) (_blks_ini[iblkgl + 1] - _blks_ini[iblkgl]);
                     int jblk, jhblk, jblkgl, ind, ibs, i;
                     for (i = 0; i < ppnzblk_arr[ipar]; i++) {
                        jblk = ppplistblk_arr[i * 4];
                        jhblk = ppplistblk_arr[i * 4 + 1];
                        jblkgl = _hblk2blk_fin[jhblk] + jblk;
                        ibs = pibshblk[jhblk];
                        ind = pind2blks[ibs + jblk];
                        pindblk_th[jblkgl] = ind;
                        pindblk1_th[jblkgl] = i;
                     }
                     _Int *plist2_temp = pASub_rows[ipar].GetList2Arr ();
                     _Int *pia_temp = pASub_rows[ipar].GetIaArr ();
                     _Int *pja2_temp = pASub_rows[ipar].GetJa2Arr ();
                     _Flt *pa_temp = pASub_rows[ipar].GetAArr ();
                     int indblk, indreg, ilist, nz, j;
                     for (i = 0; i < ni_loc; i++) {
                        jblk = (int) plist2_temp[i * 3 + 1];
                        jhblk = (int) plist2_temp[i * 3 + 2];
                        jblkgl = _hblk2blk_fin[jhblk] + jblk;
                        indblk = pindblk_th[jblkgl];
                        indreg = pindblk1_th[jblkgl];
                        ilist = ppplistblk_arr[4 * indreg + 2];
                        nz = ppplistblk_arr[4 * indreg + 3];
                        _Int *plist2_rows_new = pblkrows_new[indblk].GetList2Arr ();
                        _Int *pia_rows_new = pblkrows_new[indblk].GetIaArr ();
                        _Int *pja2_rows_new = pblkrows_new[indblk].GetJa2Arr ();
                        _Flt *pa_rows_new = pblkrows_new[indblk].GetAArr ();
                        plist2_rows_new[ilist * 3] = plist2_temp[i * 3];
                        plist2_rows_new[ilist * 3 + 1] = plist2_temp[i * 3 + 1];
                        plist2_rows_new[ilist * 3 + 2] = plist2_temp[i * 3 + 2];
                        for (j = (int) pia_temp[i]; j < pia_temp[i + 1]; j++) {
                           pja2_rows_new[nz * 3] = pja2_temp[j * 3];
                           pja2_rows_new[nz * 3 + 1] = pja2_temp[j * 3 + 1];
                           pja2_rows_new[nz * 3 + 2] = pja2_temp[j * 3 + 2];
                           pa_rows_new[nz] = pa_temp[j];
                           nz++;
                        }
                        pia_rows_new[ilist + 1] = (_Int) nz;
                        ilist++;
                        ppplistblk_arr[4 * indreg + 2] = ilist;
                        ppplistblk_arr[4 * indreg + 3] = nz;
                     }
                  }

               }

               phblk_rows[ihblk].Clean ();

            }
         }

// Finally combine blocks for send

         CVectorData < int >imaskcpu (nproc);
         CVectorData < int >listcpu (nproc);
         CVectorData < int >nzcpu (nproc);

         int *pimaskcpu = imaskcpu.Ptr ();
         int *plistcpu = listcpu.Ptr ();
         int *pnzcpu = nzcpu.Ptr ();

         int nlistcpu = 0;

         {
            int i, jhblk, jcpu;
            for (i = 0; i < nproc; i++) {
               pimaskcpu[i] = -1;
               pnzcpu[i] = 0;
            }
            pimaskcpu[myid] = 1;
            plistcpu[nlistcpu] = myid;
            nlistcpu++;
            for (i = 0; i < nblks_curr; i++) {
               jhblk = plist4ind_curr[i * 4 + 1];
               jcpu = _hblk2cpu_fin[jhblk];
               pnzcpu[jcpu]++;
               if (pimaskcpu[jcpu] < 0) {
                  pimaskcpu[jcpu] = 1;
                  plistcpu[nlistcpu] = jcpu;
                  nlistcpu++;
               }
            }
            sort (plistcpu + 1, plistcpu + nlistcpu);
            for (i = 0; i < nlistcpu; i++) {
               jcpu = plistcpu[i];
               pimaskcpu[jcpu] = i;
            }

            vector < CBMatrix < _Int, _Flt > >hblk_send_temp (nlistcpu + 1);
            CBMatrix < _Int, _Flt > *phblk_send_temp = &hblk_send_temp[0];

            int nzblk;

            for (i = 0; i < nlistcpu; i++) {
               jcpu = plistcpu[i];
               nzblk = pnzcpu[jcpu];
               phblk_send_temp[i].ResizeASub (nzblk);
               phblk_send_temp[i].SetNzblk (nzblk);
               CMatrix < int, float >*phmatr = phblk_send_temp[i].GetHMatrStr ();
               phmatr->ResizeAndSetAllSp (nzblk, nzblk, 0, 0);
               pnzcpu[jcpu] = 0;
            }

            int jblk, ind, k;

            for (i = 0; i < nblks_curr; i++) {
               jblk = plist4ind_curr[i * 4];
               jhblk = plist4ind_curr[i * 4 + 1];
               jcpu = _hblk2cpu_fin[jhblk];
               ind = pimaskcpu[jcpu];
               CMatrix < _Int, _Flt > *pASub = phblk_send_temp[ind].GetASubArr ();
               CMatrix < int, float >*phmatr = phblk_send_temp[ind].GetHMatrStr ();
               k = pnzcpu[jcpu];
               int *plist_hblk = phmatr->GetListArr ();
               int *plist2_hblk = phmatr->GetList2Arr ();
               plist_hblk[k] = jblk;
               plist2_hblk[k] = jhblk;
               pASub[k].ReplaceFree (pblkrows_new[i]);
               pnzcpu[jcpu]++;
            }

// Pack send data

            CpuIDSend.resize (nlistcpu - 1);
            ObjSend.resize (nlistcpu - 1);

            pCpuIDSend = NULL;
            pObjSend = NULL;

            if (nlistcpu > 1) {
               pCpuIDSend = &CpuIDSend[0];
               pObjSend = &ObjSend[0];
            }

            long long isize;
            char *pobj;

            {
               int i;
               for (i = 1; i < nlistcpu; i++) {
                  pCpuIDSend[i - 1] = plistcpu[i];
                  isize = phblk_send_temp[i].GetPackedSize ();
                  pObjSend[i - 1].resize ((size_t) isize);
                  pobj = &(pObjSend[i - 1][0]);
                  phblk_send_temp[i].FillPacked_thr (isize, pobj);
                  phblk_send_temp[i].Clean ();
               }
            }

            hblk_myid.ReplaceFree (phblk_send_temp[0]);

         }

      }

// Exchange

      CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      nrecv = (int) CpuIDRecv.size () + 1;

      pObjRecv = NULL;

      if (nrecv > 1) {
         pObjRecv = &ObjRecv[0];
      }

      vector < CBMatrix < _Int, _Flt > >hblk_recv_temp (nrecv + 1);

      CBMatrix < _Int, _Flt > *phblk_recv_temp = &hblk_recv_temp[0];

      phblk_recv_temp[0].ReplaceFree (hblk_myid);

      {

         long long isize;
         char *pobj;

         int i;

         for (i = 1; i < nrecv; i++) {
            isize = (long long) pObjRecv[i - 1].size ();
            pobj = &(pObjRecv[i - 1][0]);
            phblk_recv_temp[i].UnPack_thr (isize, pobj);
         }

      }

// Free recv data

      {
         vector < vector < char > >ObjRecv_temp;
         ObjRecv.swap (ObjRecv_temp);
      }

// Create set of received block rows

      hblk_rows.resize (_nhblks_fin + 1);
      phblk_rows = hblk_rows.Ptr ();

      {
         int ihblk;
         for (ihblk = 0; ihblk < _nhblks_fin; ihblk++) {
            if (_hblk2cpu_fin[ihblk] == myid) {
               int niblk = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];
               phblk_rows[ihblk].ResizeASub (niblk);
               CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int iblkgl = _hblk2blk_fin[ihblk] + ipar;
                     int ni_loc = (int) (_blks_fin[iblkgl + 1] - _blks_fin[iblkgl]);
                     pASub_rows[ipar].SetNlist (ni_loc);
                     pASub_rows[ipar].ResizeList (ni_loc);
                     pASub_rows[ipar].ResizeIa (ni_loc);
                     _Int *plist_temp = pASub_rows[ipar].GetListArr ();
                     _Int *pia_temp = pASub_rows[ipar].GetIaArr ();
                     int i;
                     for (i = 0; i < ni_loc; i++)
                        plist_temp[i] = i;
                     for (i = 0; i <= ni_loc; i++)
                        pia_temp[i] = 0;
                  }

               }

            }
         }

         for (ihblk = 0; ihblk < nrecv; ihblk++) {
            int nzblk = phblk_recv_temp[ihblk].GetNzblk ();
            CMatrix < int, float >*phmatr_recv = phblk_recv_temp[ihblk].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pASub_recv = phblk_recv_temp[ihblk].GetASubArr ();
            int *plist_hmatr = phmatr_recv->GetListArr ();
            int *plist2_hmatr = phmatr_recv->GetList2Arr ();
            {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
               for (int ipar = 0; ipar < nzblk; ipar++) {
                  int jblk = plist_hmatr[ipar];
                  int jhblk = plist2_hmatr[ipar];
                  int nlist_temp = pASub_recv[ipar].GetNlist ();
                  _Int *plist2_temp = pASub_recv[ipar].GetList2Arr ();
                  _Int *pia_temp = pASub_recv[ipar].GetIaArr ();
                  CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[jhblk].GetASubArr ();
                  _Int *pia_rows = pASub_rows[jblk].GetIaArr ();
                  int i, jj;
                  for (i = 0; i < nlist_temp; i++) {
                     jj = (int) plist2_temp[i * 3];
                     pia_rows[jj + 1] = (pia_temp[i + 1] - pia_temp[i]);
                  }
               }
            }

         }

         for (ihblk = 0; ihblk < _nhblks_fin; ihblk++) {
            if (_hblk2cpu_fin[ihblk] == myid) {
               int niblk = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];
               CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int iblkgl = _hblk2blk_fin[ihblk] + ipar;
                     int ni_loc = (int) (_blks_fin[iblkgl + 1] - _blks_fin[iblkgl]);
                     _Int *pia_temp = pASub_rows[ipar].GetIaArr ();
                     int i;
                     for (i = 0; i < ni_loc; i++)
                        pia_temp[i + 1] += pia_temp[i];
                     int nzja_temp = (int) pia_temp[ni_loc];
                     pASub_rows[ipar].ResizeJa2 (3 * nzja_temp);
                     pASub_rows[ipar].ResizeA (nzja_temp);
                     pASub_rows[ipar].SetNzja2 (nzja_temp * 3);
                     pASub_rows[ipar].SetNza (nzja_temp);
                  }

               }

            }
         }

         for (ihblk = 0; ihblk < nrecv; ihblk++) {
            int nzblk = phblk_recv_temp[ihblk].GetNzblk ();
            CMatrix < int, float >*phmatr_recv = phblk_recv_temp[ihblk].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pASub_recv = phblk_recv_temp[ihblk].GetASubArr ();
            int *plist_hmatr = phmatr_recv->GetListArr ();
            int *plist2_hmatr = phmatr_recv->GetList2Arr ();
            {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
               for (int ipar = 0; ipar < nzblk; ipar++) {
                  int jblk = plist_hmatr[ipar];
                  int jhblk = plist2_hmatr[ipar];
                  int nlist_temp = pASub_recv[ipar].GetNlist ();
                  _Int *plist2_temp = pASub_recv[ipar].GetList2Arr ();
                  _Int *pia_temp = pASub_recv[ipar].GetIaArr ();
                  _Int *pja2_temp = pASub_recv[ipar].GetJa2Arr ();
                  _Flt *pa_temp = pASub_recv[ipar].GetAArr ();
                  CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[jhblk].GetASubArr ();
                  _Int *pia_rows = pASub_rows[jblk].GetIaArr ();
                  _Int *pja2_rows = pASub_rows[jblk].GetJa2Arr ();
                  _Flt *pa_rows = pASub_rows[jblk].GetAArr ();
                  int i, jj, j, ibs;
                  for (i = 0; i < nlist_temp; i++) {
                     jj = (int) plist2_temp[i * 3];
                     ibs = (int) pia_rows[jj];
                     for (j = (int) pia_temp[i]; j < pia_temp[i + 1]; j++) {
                        pja2_rows[ibs * 3] = pja2_temp[j * 3];
                        pja2_rows[ibs * 3 + 1] = pja2_temp[j * 3 + 1];
                        pja2_rows[ibs * 3 + 2] = pja2_temp[j * 3 + 2];
                        pa_rows[ibs] = pa_temp[j];
                        ibs++;
                     }
                  }
               }
            }

            phblk_recv_temp[ihblk].Clean ();

         }

         hblk_recv_temp.resize (0);

      }

// Sort block rows data

      {
         int ihblk;
         for (ihblk = 0; ihblk < _nhblks_fin; ihblk++) {
            if (_hblk2cpu_fin[ihblk] == myid) {
               int niblk = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
                     int nlist_rows = pASub_rows[ipar].GetNlist ();
                     _Int *pia_rows = pASub_rows[ipar].GetIaArr ();
                     _Int *pja2_rows = pASub_rows[ipar].GetJa2Arr ();
                     _Flt *pa_rows = pASub_rows[ipar].GetAArr ();
                     int i, jj, j, niloc;
                     int nimax = 0;
                     for (i = 0; i < nlist_rows; i++) {
                        niloc = (int) (pia_rows[i + 1] - pia_rows[i]);
                        if (niloc > nimax)
                           nimax = niloc;
                     }
                     CVectorData < CSortInt2 > ii2arr (nimax);
                     CVectorData < _Int > i3index (3 * nimax);
                     CVectorData < _Flt > elems (nimax);
                     CSortInt2 *pii2arr = ii2arr.Ptr ();
                     _Int *pi3index = i3index.Ptr ();
                     _Flt *pelems = elems.Ptr ();
                     int ibeg, jext, jind, jblk, jhblk, jblkgl;
                     for (i = 0; i < nlist_rows; i++) {
                        niloc = (int) (pia_rows[i + 1] - pia_rows[i]);
                        ibeg = (int) pia_rows[i];
                        for (j = 0; j < niloc; j++) {
                           jext = j + ibeg;
                           jj = (int) pja2_rows[jext * 3];
                           jblk = (int) pja2_rows[jext * 3 + 1];
                           jhblk = (int) pja2_rows[jext * 3 + 2];
                           jblkgl = _hblk2blk_fin[jhblk] + jblk;
                           pii2arr[j].ixval = jblkgl;
                           pii2arr[j].iyval = jj;
                           pii2arr[j].itail = jext;
                        }
                        sort (pii2arr, pii2arr + niloc);
                        for (j = 0; j < niloc; j++) {
                           jind = pii2arr[j].itail;
                           pi3index[j * 3] = pja2_rows[jind * 3];
                           pi3index[j * 3 + 1] = pja2_rows[jind * 3 + 1];
                           pi3index[j * 3 + 2] = pja2_rows[jind * 3 + 2];
                           pelems[j] = pa_rows[jind];
                        }
                        for (j = 0; j < niloc; j++) {
                           jext = j + ibeg;
                           pja2_rows[jext * 3] = pi3index[j * 3];
                           pja2_rows[jext * 3 + 1] = pi3index[j * 3 + 1];
                           pja2_rows[jext * 3 + 2] = pi3index[j * 3 + 2];
                           pa_rows[jext] = pelems[j];
                        }
                     }
                  }
               }

            }
         }

      }

// Form final hblocks

      {
         int ihblk;

         int nblks_fin = _hblk2blk_fin[_nhblks_fin];

         CVectorData < int >imaskblk_threads (nblks_fin * 4 * n_thr);
         CVectorData < int >icycleblk_threads (n_thr);

         int *pimaskblk_threads = imaskblk_threads.Ptr ();
         int *picycleblk_threads = icycleblk_threads.Ptr ();

         {
            int i;
            for (i = 0; i < n_thr; i++)
               picycleblk_threads[i] = -1;
         }

         for (ihblk = 0; ihblk < _nhblks_fin; ihblk++) {
            if (_hblk2cpu_fin[ihblk] == myid) {
               int niblk = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];
               CVectorData < int >nzblk_arr (niblk);
               CVectorData < CVectorData < int > >list2blk_arr (niblk);
               CVectorData < CVectorData < CMatrix < _Int, _Flt > > >blks_arr (niblk);
               int *pnzblk_arr = nzblk_arr.Ptr ();
               CVectorData < int >*plist2blk_arr = list2blk_arr.Ptr ();
               CVectorData < CMatrix < _Int, _Flt > >*pblks_arr = blks_arr.Ptr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif
                     int *pimaskblk_th = pimaskblk_threads + 4 * nblks_fin * my_thr;
                     int *pindblk_th = pimaskblk_th + nblks_fin;
                     int *plistblk_th = pindblk_th + nblks_fin;
                     int *pnzblk_th = plistblk_th + nblks_fin;
                     int icycleblk_th = picycleblk_threads[my_thr];

                     int i;

                     if (icycleblk_th == -1) {
                        for (i = 0; i < nblks_fin; i++)
                           pimaskblk_th[i] = -1;
                     }

                     icycleblk_th++;

                     int iblkgl = _hblk2blk_fin[ihblk] + ipar;
                     int ni_loc = (int) (_blks_fin[iblkgl + 1] - _blks_fin[iblkgl]);
                     CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
                     int nlist_rows = pASub_rows[ipar].GetNlist ();
                     _Int *pia_rows = pASub_rows[ipar].GetIaArr ();
                     _Int *pja2_rows = pASub_rows[ipar].GetJa2Arr ();
                     _Flt *pa_rows = pASub_rows[ipar].GetAArr ();
                     int j, jj, jblk, jhblk, jblkgl;
                     int nlistblk = 0;
                     for (i = 0; i < nlist_rows; i++) {
                        for (j = (int) pia_rows[i]; j < pia_rows[i + 1]; j++) {
                           jblk = (int) pja2_rows[j * 3 + 1];
                           jhblk = (int) pja2_rows[j * 3 + 2];
                           jblkgl = _hblk2blk_fin[jhblk] + jblk;
                           if (pimaskblk_th[jblkgl] != icycleblk_th) {
                              pimaskblk_th[jblkgl] = icycleblk_th;
                              plistblk_th[nlistblk] = jblkgl;
                              nlistblk++;
                           }
                        }
                     }
                     pnzblk_arr[ipar] = nlistblk;
                     plist2blk_arr[ipar].resize (2 * nlistblk);
                     int *pplist2blk_arr = plist2blk_arr[ipar].Ptr ();
                     for (i = 0; i < 2 * nlistblk; i++)
                        pplist2blk_arr[i] = -1;
                     sort (plistblk_th, plistblk_th + nlistblk);
                     for (i = 0; i < nlistblk; i++) {
                        jblkgl = plistblk_th[i];
                        pindblk_th[jblkgl] = i;
                        pnzblk_th[jblkgl] = 0;
                     }
                     int ind;
                     for (i = 0; i < nlist_rows; i++) {
                        for (j = (int) pia_rows[i]; j < pia_rows[i + 1]; j++) {
                           jblk = (int) pja2_rows[j * 3 + 1];
                           jhblk = (int) pja2_rows[j * 3 + 2];
                           jblkgl = _hblk2blk_fin[jhblk] + jblk;
                           pnzblk_th[jblkgl]++;
                           ind = pindblk_th[jblkgl];
                           if (pplist2blk_arr[ind * 2] < 0) {
                              pplist2blk_arr[ind * 2] = jblk;
                              pplist2blk_arr[ind * 2 + 1] = jhblk;
                           }
                        }
                     }
                     CVectorData < CVectorData < _Int > >rowsarr (nlistblk);
                     CVectorData < CVectorData < _Int > >colsarr (nlistblk);
                     CVectorData < CVectorData < _Flt > >elemsarr (nlistblk);
                     CVectorData < _Int > *prowsarr = rowsarr.Ptr ();
                     CVectorData < _Int > *pcolsarr = colsarr.Ptr ();
                     CVectorData < _Flt > *pelemsarr = elemsarr.Ptr ();
                     int nz;
                     for (i = 0; i < nlistblk; i++) {
                        jblkgl = plistblk_th[i];
                        nz = pnzblk_th[jblkgl];
                        prowsarr[i].resize (nz);
                        pcolsarr[i].resize (nz);
                        pelemsarr[i].resize (nz);
                        pnzblk_th[jblkgl] = 0;
                     }
                     for (i = 0; i < nlist_rows; i++) {
                        for (j = (int) pia_rows[i]; j < pia_rows[i + 1]; j++) {
                           jj = (int) pja2_rows[j * 3];
                           jblk = (int) pja2_rows[j * 3 + 1];
                           jhblk = (int) pja2_rows[j * 3 + 2];
                           jblkgl = _hblk2blk_fin[jhblk] + jblk;
                           ind = pindblk_th[jblkgl];
                           nz = pnzblk_th[jblkgl];
                           _Int *pprowsarr = prowsarr[ind].Ptr ();
                           _Int *ppcolsarr = pcolsarr[ind].Ptr ();
                           _Flt *ppelemsarr = pelemsarr[ind].Ptr ();
                           pprowsarr[nz] = i;
                           ppcolsarr[nz] = jj;
                           ppelemsarr[nz] = pa_rows[j];
                           pnzblk_th[jblkgl]++;
                        }
                     }
                     pblks_arr[ipar].resize (nlistblk);
                     CMatrix < _Int, _Flt > *ppblks_arr = pblks_arr[ipar].Ptr ();
                     int nimax = ni_loc;
                     int nj_loc;
                     for (i = 0; i < nlistblk; i++) {
                        jblkgl = plistblk_th[i];
                        nj_loc = (int) (_blks_fin[jblkgl + 1] - _blks_fin[jblkgl]);
                        if (nj_loc > nimax)
                           nimax = nj_loc;
                     }
                     CVectorData < int >imask (5 * nimax + 1);
                     int *pimask = imask.Ptr ();
                     int *plist = pimask + nimax;
                     int *pindarr = plist + nimax;
                     int *piptr = pindarr + nimax;
                     int *pialoc = piptr + nimax;
                     for (i = 0; i < nimax; i++)
                        pimask[i] = -1;
                     int icycle = -1;
                     int indj, k;
                     for (i = 0; i < nlistblk; i++) {
                        icycle++;
                        jblkgl = plistblk_th[i];
                        ind = pindblk_th[jblkgl];
                        nz = pnzblk_th[jblkgl];
                        _Int *pprowsarr = prowsarr[ind].Ptr ();
                        _Int *ppcolsarr = pcolsarr[ind].Ptr ();
                        _Flt *ppelemsarr = pelemsarr[ind].Ptr ();
                        int nlist_temp = 0;
                        for (j = 0; j < nz; j++) {
                           jj = (int) pprowsarr[j];
                           if (pimask[jj] != icycle) {
                              pimask[jj] = icycle;
                              plist[nlist_temp] = jj;
                              nlist_temp++;
                           }
                        }
                        sort (plist, plist + nlist_temp);
                        pialoc[0] = 0;
                        for (j = 0; j < nlist_temp; j++) {
                           jj = plist[j];
                           pindarr[jj] = j;
                           pialoc[j + 1] = 0;
                        }
                        for (j = 0; j < nz; j++) {
                           jj = (int) pprowsarr[j];
                           indj = pindarr[jj];
                           pialoc[indj + 1]++;
                        }
                        for (j = 0; j < nlist_temp; j++)
                           pialoc[j + 1] += pialoc[j];
                        for (j = 0; j < nlist_temp; j++)
                           piptr[j] = pialoc[j];
                        ppblks_arr[i].ResizeAndSetAll (nlist_temp, 0, nz, 0, nz);
                        _Int *plist_new = ppblks_arr[i].GetListArr ();
                        _Int *pia_new = ppblks_arr[i].GetIaArr ();
                        _Int *pja_new = ppblks_arr[i].GetJaArr ();
                        _Flt *pa_new = ppblks_arr[i].GetAArr ();
                        for (j = 0; j < nlist_temp; j++)
                           plist_new[j] = plist[j];
                        for (j = 0; j <= nlist_temp; j++)
                           pia_new[j] = pialoc[j];
                        for (j = 0; j < nz; j++) {
                           jj = (int) pprowsarr[j];
                           indj = pindarr[jj];
                           k = piptr[indj];
                           pja_new[k] = ppcolsarr[j];
                           pa_new[k] = ppelemsarr[j];
                           piptr[indj]++;
                        }
                     }
                  }
               }

               {

                  int nzblk_tot = 0;

                  int i, j;

                  for (i = 0; i < niblk; i++)
                     nzblk_tot += pnzblk_arr[i];

                  _hmatr_arr_fin[ihblk].ResizeASub (nzblk_tot);
                  _hmatr_arr_fin[ihblk].SetNzblk (nzblk_tot);

                  CMatrix < int, float >*pHMatrStr_fin =
                     _hmatr_arr_fin[ihblk].GetHMatrStr ();
                  CMatrix < _Int, _Flt > *pASub_fin = _hmatr_arr_fin[ihblk].GetASubArr ();

                  pHMatrStr_fin->ResizeAndSetAllSp (niblk, niblk, nzblk_tot, nzblk_tot);

                  int *plist_fin = pHMatrStr_fin->GetListArr ();
                  int *plist2_fin = pHMatrStr_fin->GetList2Arr ();
                  int *pia_fin = pHMatrStr_fin->GetIaArr ();
                  int *pja_fin = pHMatrStr_fin->GetJaArr ();
                  int *pja2_fin = pHMatrStr_fin->GetJa2Arr ();

                  for (i = 0; i < niblk; i++)
                     plist_fin[i] = i;
                  for (i = 0; i < niblk; i++)
                     plist2_fin[i] = ihblk;

                  pia_fin[0] = 0;

                  nzblk_tot = 0;

                  for (i = 0; i < niblk; i++) {
                     int *pplist2blk_arr = plist2blk_arr[i].Ptr ();
                     CMatrix < _Int, _Flt > *ppblks_arr = pblks_arr[i].Ptr ();
                     for (j = 0; j < pnzblk_arr[i]; j++) {
                        pja_fin[nzblk_tot] = pplist2blk_arr[j * 2];
                        pja2_fin[nzblk_tot] = pplist2blk_arr[j * 2 + 1];
                        pASub_fin[nzblk_tot].ReplaceFree (ppblks_arr[j]);
                        nzblk_tot++;
                     }
                     pia_fin[i + 1] = nzblk_tot;
                  }
               }

               phblk_rows[ihblk].Clean ();

            }
         }

      }

   }

// Compute reordered hmatrix
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ReorderHMatrix_BxB (void *_comm, int _blksize, int _nhblks_ini,
                                  int *_hblk2cpu_ini, int *_hblk2blk_ini,
                                  long long *_blks_ini, CBMatrix < _Int,
                                  _Flt > *_hmatr_arr_ini, long long *_order,
                                  int _nhblks_fin, int *_hblk2cpu_fin, int *_hblk2blk_fin,
                                  long long *_blks_fin, CBMatrix < _Int,
                                  _Flt > *_hmatr_arr_fin)
   {

      int myid = CMPIDataExchange::GetMyid (_comm);
      int nproc = CMPIDataExchange::GetNproc (_comm);

      int n_thr = 1;

#ifdef USE_THREADS
      n_thr = omp_get_max_threads ();
#endif

// Compute new 3index for all ordering data

      int b_2 = _blksize * _blksize;

      CVectorData < int >ibs_hblk (_nhblks_ini);
      int *pibs_hblk = ibs_hblk.Ptr ();

      int ni_order_ini = 0;

      {
         int ihblk, ibegblk, iendblk;
         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            pibs_hblk[ihblk] = -1;
            if (_hblk2cpu_ini[ihblk] == myid) {
               pibs_hblk[ihblk] = ni_order_ini;
               ibegblk = _hblk2blk_ini[ihblk];
               iendblk = _hblk2blk_ini[ihblk + 1] - 1;
               ni_order_ini += (int) (_blks_ini[iendblk + 1] - _blks_ini[ibegblk]);
            }
         }
      }

      CVectorData < int >order_3index (ni_order_ini * 3);
      int *porder_3index = order_3index.Ptr ();

      {
         int nblks_fin = _hblk2blk_fin[_nhblks_fin];
         CVectorData < int >blk2hblk_fin (nblks_fin);
         int *pblk2hblk_fin = blk2hblk_fin.Ptr ();
         {
            int i, j;
            for (i = 0; i < _nhblks_fin; i++) {
               for (j = _hblk2blk_fin[i]; j < _hblk2blk_fin[i + 1]; j++) {
                  pblk2hblk_fin[j] = i;
               }
            }
         }
         int nparts_split = 4 * n_thr;
         int ni_part = ni_order_ini / nparts_split;
#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < nparts_split; ipar++) {
            int ibeg = ni_part * ipar;
            int iend = ni_part * (ipar + 1) - 1;
            if (ipar == nparts_split - 1)
               iend = ni_order_ini - 1;
            int niloc = iend - ibeg + 1;
            CVectorData < CSortInt64 > iiarr (niloc);
            CSortInt64 *piiarr = iiarr.Ptr ();
            int i;
            for (i = 0; i < niloc; i++) {
               piiarr[i].ival = _order[ibeg + i];
               piiarr[i].i2val = i;
            }
            sort (piiarr, piiarr + niloc);
            CVectorData < long long >order_sort (niloc);
            long long *porder_sort = order_sort.Ptr ();
            for (i = 0; i < niloc; i++)
               porder_sort[i] = piiarr[i].ival;
            CVectorData < long long >blknum_arr (niloc);
            CVectorData < int >hblknum_arr (niloc);
            long long *pblknum_arr = blknum_arr.Ptr ();
            long long ia_temp[2];
            ia_temp[0] = 0;
            ia_temp[1] = (_Int) niloc;
            CBMatrix < long long, float >::ComputeJa2 (nblks_fin, _blks_fin, 1, ia_temp,
                                                       porder_sort, pblknum_arr);
            long long jj;
            int jblk, jhblk, iold;
            for (i = 0; i < niloc; i++) {
               iold = (int) piiarr[i].i2val;
               jj = porder_sort[i];
               jblk = (int) pblknum_arr[i];
               jhblk = pblk2hblk_fin[jblk];
               jj = jj - _blks_fin[jblk];
               porder_3index[(ibeg + iold) * 3] = (int) jj;
               porder_3index[(ibeg + iold) * 3 + 1] = jblk - _hblk2blk_fin[jhblk];
               porder_3index[(ibeg + iold) * 3 + 2] = jhblk;
            }
         }
      }

// Compute transposed block sparsities

      CVectorData < CMatrix < int, float > >str_hblkT_arr (_nhblks_ini);
      CMatrix < int, float >*pstr_hblkT_arr = str_hblkT_arr.Ptr ();

      CVectorData < CVectorData < int > >indT2N_arr (_nhblks_ini);
      CVectorData < int >*pindT2N_arr = indT2N_arr.Ptr ();

      {

         int nblks_ini = _hblk2blk_ini[_nhblks_ini];

         CVectorData < int >blk2hblk_ini (nblks_ini);
         int *pblk2hblk_ini = blk2hblk_ini.Ptr ();

         {
            for (int i = 0; i < _nhblks_ini; i++) {
               for (int j = _hblk2blk_ini[i]; j < _hblk2blk_ini[i + 1]; j++) {
                  pblk2hblk_ini[j] = i;
               }
            }
         }

         CVectorData < int >imaskblk (nblks_ini * 5 + 1);
         int *pimaskblk = imaskblk.Ptr ();

         int ihblk;

         for (ihblk = 0; ihblk < nblks_ini; ihblk++)
            pimaskblk[ihblk] = -1;

         int icycleblk = -1;

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {

               CMatrix < int, float >*phmatr = _hmatr_arr_ini[ihblk].GetHMatrStr ();

               CMatrix < int, float >str_hblk;
               str_hblk = *phmatr;

// Transform to 1 index

               int nlist_temp = str_hblk.GetNlist ();
               int nzja_temp = str_hblk.GetNzja ();
               int *plist_temp = str_hblk.GetListArr ();
               int *plist2_temp = str_hblk.GetList2Arr ();
               int *pia_temp = str_hblk.GetIaArr ();
               int *pja_temp = str_hblk.GetJaArr ();
               int *pja2_temp = str_hblk.GetJa2Arr ();

               int i, jblk, jhblk;

               for (i = 0; i < nlist_temp; i++) {
                  jblk = plist_temp[i];
                  jhblk = plist2_temp[i];
                  plist_temp[i] = _hblk2blk_ini[jhblk] + jblk;
               }
               for (i = 0; i < nzja_temp; i++) {
                  jblk = pja_temp[i];
                  jhblk = pja2_temp[i];
                  pja_temp[i] = _hblk2blk_ini[jhblk] + jblk;
               }

               str_hblk.SetNlist2 (0);
               str_hblk.SetNzja2 (0);

// Transpose

               CMatrix < int, float >str_hblkT;

               str_hblk.TransposedSparsityListSp (icycleblk, pimaskblk,
                                                  pimaskblk + nblks_ini,
                                                  pimaskblk + nblks_ini * 2,
                                                  pimaskblk + nblks_ini * 3,
                                                  pimaskblk + nblks_ini * 4, str_hblkT);

               int nlist_tempT = str_hblkT.GetNlist ();
               int nzja_tempT = str_hblkT.GetNzja ();
               int *pia_tempT = str_hblkT.GetIaArr ();
               int *pja_tempT = str_hblkT.GetJaArr ();

// Compute transposed reference

               int ibeghblk = _hblk2blk_ini[ihblk];

               pindT2N_arr[ihblk].resize (nzja_tempT);
               int *ppindT2N_arr = pindT2N_arr[ihblk].Ptr ();

               for (i = 0; i < nlist_temp; i++) {
                  pimaskblk[nblks_ini + i] = pia_temp[i];
               }

               int j, jj, k;

               for (i = 0; i < nlist_tempT; i++) {
                  for (j = pia_tempT[i]; j < pia_tempT[i + 1]; j++) {
                     jj = pja_tempT[j] - ibeghblk;
                     k = pimaskblk[nblks_ini + jj];
                     ppindT2N_arr[j] = k;
                     pimaskblk[nblks_ini + jj]++;
                  }
               }

// Modify second index

               str_hblkT.ResizeList2 (nlist_tempT);
               str_hblkT.ResizeJa2 (nzja_tempT);
               str_hblkT.SetNlist2 (nlist_tempT);
               str_hblkT.SetNzja2 (nzja_tempT);

               plist_temp = str_hblkT.GetListArr ();
               plist2_temp = str_hblkT.GetList2Arr ();
               pja_temp = str_hblkT.GetJaArr ();
               pja2_temp = str_hblkT.GetJa2Arr ();

               for (i = 0; i < nlist_tempT; i++) {
                  jblk = plist_temp[i];
                  jhblk = pblk2hblk_ini[jblk];
                  plist_temp[i] = jblk - _hblk2blk_ini[jhblk];
                  plist2_temp[i] = jhblk;
               }
               for (i = 0; i < nzja_tempT; i++) {
                  jblk = pja_temp[i];
                  jhblk = pblk2hblk_ini[jblk];
                  pja_temp[i] = jblk - _hblk2blk_ini[jhblk];
                  pja2_temp[i] = jhblk;
               }

               pstr_hblkT_arr[ihblk].ReplaceFree (str_hblkT);

            }
         }

      }

// Compute column lists for all hblock off-diagonal blocks

      CVectorData < CBMatrix < int, float > >str_cols_arr (_nhblks_ini);
      CBMatrix < int, float >*pstr_cols_arr = str_cols_arr.Ptr ();

      {

         int nblks_ini = _hblk2blk_ini[_nhblks_ini];

         int ihblk;

         int nimax = 0;

         {
            for (int i = 0; i < nblks_ini; i++) {
               int niloc = (int) (_blks_ini[i + 1] - _blks_ini[i]);
               if (niloc > nimax)
                  nimax = niloc;
            }
         }

         CVectorData < int >imask_threads (nimax * 2 * n_thr + 1);
         CVectorData < int >icycle_threads (n_thr + 1);

         int *pimask_threads = imask_threads.Ptr ();
         int *picycle_threads = icycle_threads.Ptr ();

         for (ihblk = 0; ihblk < n_thr; ihblk++)
            picycle_threads[ihblk] = -1;

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {

// Local column sparsity

               CMatrix < _Int, _Flt > *pASub = _hmatr_arr_ini[ihblk].GetASubArr ();
               CMatrix < int, float >*phmatr = _hmatr_arr_ini[ihblk].GetHMatrStr ();

               int nzja_temp = phmatr->GetNzja ();
               int *pja2_temp = phmatr->GetJa2Arr ();

               {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < nzja_temp; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif
                     if (pja2_temp[ipar] != ihblk) {

                        int *pimask_th = pimask_threads + 2 * nimax * my_thr;
                        int icycle_th = picycle_threads[my_thr];

                        if (icycle_th == -1) {
                           for (int j = 0; j < nimax; j++)
                              pimask_th[j] = -1;
                        }

                        icycle_th++;

                        pASub[ipar].ComputeList2 (icycle_th, pimask_th,
                                                  pimask_th + nimax);

                        picycle_threads[my_thr] = icycle_th;
                     }
                  }

               }

// Add column sparsity in block columns

               int nlistT_hblk = pstr_hblkT_arr[ihblk].GetNlist ();
               int *plistT_hblk = pstr_hblkT_arr[ihblk].GetListArr ();
               int *plist2T_hblk = pstr_hblkT_arr[ihblk].GetList2Arr ();
               int *piaT_hblk = pstr_hblkT_arr[ihblk].GetIaArr ();

               int nlistblk_off = 0;

               {
                  int jhblk;
                  for (int i = 0; i < nlistT_hblk; i++) {
                     jhblk = plist2T_hblk[i];
                     if (jhblk != ihblk)
                        nlistblk_off++;
                  }
               }

               pstr_cols_arr[ihblk].SetNzblk (nlistblk_off);
               pstr_cols_arr[ihblk].ResizeASub (nlistblk_off);

               CMatrix < int, float >*pASub_cols = pstr_cols_arr[ihblk].GetASubArr ();
               CMatrix < int, float >*phmatr_cols = pstr_cols_arr[ihblk].GetHMatrStr ();

               phmatr_cols->ResizeAndSetAllSp (nlistblk_off, nlistblk_off, nlistblk_off,
                                               nlistblk_off);

               int *plist_cols = phmatr_cols->GetListArr ();
               int *plist2_cols = phmatr_cols->GetList2Arr ();
               int *pia_cols = phmatr_cols->GetIaArr ();
               int *pja_cols = phmatr_cols->GetJaArr ();
               int *pja2_cols = phmatr_cols->GetJa2Arr ();

               {
                  for (int i = 0; i <= nlistblk_off; i++)
                     pia_cols[i] = i;
               }

               CVectorData < int >indblk (nlistblk_off);
               int *pindblk = indblk.Ptr ();

               nlistblk_off = 0;

               int *ppindT2N_arr = pindT2N_arr[ihblk].Ptr ();

               {
                  int jblk, jhblk;
                  for (int i = 0; i < nlistT_hblk; i++) {
                     jblk = plistT_hblk[i];
                     jhblk = plist2T_hblk[i];
                     if (jhblk != ihblk) {
                        pindblk[nlistblk_off] = i;
                        plist_cols[nlistblk_off] = i;
                        plist2_cols[nlistblk_off] = ihblk;
                        pja_cols[nlistblk_off] = jblk;
                        pja2_cols[nlistblk_off] = jhblk;
                        nlistblk_off++;
                     }
                  }
               }

               {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < nlistblk_off; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif

                     int *pimask_th = pimask_threads + 2 * nimax * my_thr;
                     int *plist_th = pimask_th + nimax;
                     int icycle_th = picycle_threads[my_thr];

                     if (icycle_th == -1) {
                        for (int j = 0; j < nimax; j++)
                           pimask_th[j] = -1;
                     }

                     icycle_th++;

                     int ind = pindblk[ipar];

                     int i, indj, j, jj;

                     int nlistloc = 0;

                     for (i = piaT_hblk[ind]; i < piaT_hblk[ind + 1]; i++) {
                        indj = ppindT2N_arr[i];
                        int nlist2_temp = pASub[indj].GetNlist2 ();
                        _Int *plist2_temp = pASub[indj].GetList2Arr ();
                        for (j = 0; j < nlist2_temp; j++) {
                           jj = (int) plist2_temp[j];
                           if (pimask_th[jj] != icycle_th) {
                              pimask_th[jj] = icycle_th;
                              plist_th[nlistloc] = jj;
                              nlistloc++;
                           }
                        }
                     }

                     sort (plist_th, plist_th + nlistloc);

                     pASub_cols[ipar].ResizeList2 (nlistloc);
                     pASub_cols[ipar].SetNlist2 (nlistloc);

                     int *plist2_new = pASub_cols[ipar].GetList2Arr ();

                     for (i = 0; i < nlistloc; i++)
                        plist2_new[i] = plist_th[i];

                     picycle_threads[my_thr] = icycle_th;

                  }
               }

            }
         }

      }

// Prepare send data

      vector < int >listcpu (nproc + 1);
      int *plistcpu = &listcpu[0];

      int nlistcpu = 0;

      CVectorData < CBMatrix < int, float > >hblk_send;

      {

         int i;

         vector < int >imaskcpu (nproc + 1);
         int *pimaskcpu = &imaskcpu[0];

         for (i = 0; i < nproc; i++)
            pimaskcpu[i] = -1;

         int j, jj2, jproc;

         for (i = 0; i < _nhblks_ini; i++) {
            if (_hblk2cpu_ini[i] == myid) {
               CMatrix < int, float >*phmatr = pstr_cols_arr[i].GetHMatrStr ();
               int nzja_temp = phmatr->GetNzja ();
               int *pja2_temp = phmatr->GetJa2Arr ();
               for (j = 0; j < nzja_temp; j++) {
                  jj2 = pja2_temp[j];
                  jproc = _hblk2cpu_ini[jj2];
                  if (pimaskcpu[jproc] < 0) {
                     plistcpu[nlistcpu] = jproc;
                     nlistcpu++;
                     pimaskcpu[jproc] = 1;
                  }
               }
            }
         }

         sort (plistcpu, plistcpu + nlistcpu);

         for (i = 0; i < nlistcpu; i++) {
            j = plistcpu[i];
            pimaskcpu[j] = i;
         }

         vector < int >nzblk_cpu (nlistcpu + 1);
         int *pnzblk_cpu = &nzblk_cpu[0];

         for (i = 0; i < nlistcpu; i++)
            pnzblk_cpu[i] = 0;

         int ind;

         for (i = 0; i < _nhblks_ini; i++) {
            if (_hblk2cpu_ini[i] == myid) {
               CMatrix < int, float >*phmatr = pstr_cols_arr[i].GetHMatrStr ();
               int nzja_temp = phmatr->GetNzja ();
               int *pja2_temp = phmatr->GetJa2Arr ();
               for (j = 0; j < nzja_temp; j++) {
                  jj2 = pja2_temp[j];
                  jproc = _hblk2cpu_ini[jj2];
                  ind = pimaskcpu[jproc];
                  pnzblk_cpu[ind]++;
               }
            }
         }

         hblk_send.resize (nlistcpu);

         CBMatrix < int, float >*phblk_send = hblk_send.Ptr ();

         for (i = 0; i < nlistcpu; i++) {
            phblk_send[i].ResizeASub (pnzblk_cpu[i]);
            phblk_send[i].SetNzblk (pnzblk_cpu[i]);
            CMatrix < int, float >*phmatr = phblk_send[i].GetHMatrStr ();
            phmatr->ResizeAndSetAllSp (pnzblk_cpu[i], pnzblk_cpu[i], pnzblk_cpu[i],
                                       pnzblk_cpu[i]);
         }

         for (i = 0; i < nlistcpu; i++)
            pnzblk_cpu[i] = 0;

         int k, jj, ind_ini;

         for (i = 0; i < _nhblks_ini; i++) {
            if (_hblk2cpu_ini[i] == myid) {
               CMatrix < int, float >*pASub = pstr_cols_arr[i].GetASubArr ();
               CMatrix < int, float >*phmatr = pstr_cols_arr[i].GetHMatrStr ();
               int nzja_temp = phmatr->GetNzja ();
               int *plist_temp = phmatr->GetListArr ();
               int *pja_temp = phmatr->GetJaArr ();
               int *pja2_temp = phmatr->GetJa2Arr ();
               for (j = 0; j < nzja_temp; j++) {
                  ind_ini = plist_temp[j];
                  jj = pja_temp[j];
                  jj2 = pja2_temp[j];
                  jproc = _hblk2cpu_ini[jj2];
                  ind = pimaskcpu[jproc];
                  k = pnzblk_cpu[ind];
                  CMatrix < int, float >*pASub_temp = phblk_send[ind].GetASubArr ();
                  CMatrix < int, float >*phmatr_temp = phblk_send[ind].GetHMatrStr ();
                  int *plist_temp2 = phmatr_temp->GetListArr ();
                  int *plist2_temp2 = phmatr_temp->GetList2Arr ();
                  int *pja_temp2 = phmatr_temp->GetJaArr ();
                  int *pja2_temp2 = phmatr_temp->GetJa2Arr ();
                  plist_temp2[k] = ind_ini;
                  plist2_temp2[k] = i;
                  pja_temp2[k] = jj;
                  pja2_temp2[k] = jj2;
                  pASub_temp[k].ReplaceFree (pASub[j]);
                  pnzblk_cpu[ind]++;
               }
            }
         }

      }

// Pack send data

      vector < int >CpuIDSend (nlistcpu);
      vector < vector < char > >ObjSend (nlistcpu);

      int *pCpuIDSend = NULL;
      vector < char >*pObjSend = NULL;

      if (nlistcpu > 0) {
         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];
      }

      {

         CBMatrix < int, float >*phblk_send = hblk_send.Ptr ();

         long long isize;
         char *pobj;

         int i;

         for (i = 0; i < nlistcpu; i++) {
            pCpuIDSend[i] = plistcpu[i];
            isize = phblk_send[i].GetPackedSize ();
            pObjSend[i].resize ((size_t) isize);
            pobj = &(pObjSend[i][0]);
            phblk_send[i].FillPacked_thr (isize, pobj);
            phblk_send[i].Clean ();
         }

      }

// Exchange

      vector < int >CpuIDRecv;
      vector < vector < char > >ObjRecv;

      CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      int nrecv = (int) CpuIDRecv.size ();

      vector < char >*pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjRecv[0];
      }

      vector < CBMatrix < int, float > >hblk_recv (nrecv + 1);

      CBMatrix < int, float >*phblk_recv = &hblk_recv[0];

      {

         long long isize;
         char *pobj;

         int i;

         for (i = 0; i < nrecv; i++) {
            isize = (long long) pObjRecv[i].size ();
            pobj = &(pObjRecv[i][0]);
            phblk_recv[i].UnPack_thr (isize, pobj);
         }

      }

// Free recv data

      {
         vector < vector < char > >ObjRecv_temp;
         ObjRecv.swap (ObjRecv_temp);
      }

// Fill 3index data inside blocks

      {
         int irecv;
         for (irecv = 0; irecv < nrecv; irecv++) {
            CMatrix < int, float >*pASub_recv = phblk_recv[irecv].GetASubArr ();
            CMatrix < int, float >*phmatr_recv = phblk_recv[irecv].GetHMatrStr ();
            int nzja_recv = phmatr_recv->GetNzja ();
            int *pja_recv = phmatr_recv->GetJaArr ();
            int *pja2_recv = phmatr_recv->GetJa2Arr ();
            {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
               for (int ipar = 0; ipar < nzja_recv; ipar++) {
                  int jblk = pja_recv[ipar];
                  int jhblk = pja2_recv[ipar];
                  int nlist2_temp = pASub_recv[ipar].GetNlist2 ();
                  int *plist2_temp = pASub_recv[ipar].GetList2Arr ();
                  pASub_recv[ipar].ResizeJa2 (3 * nlist2_temp);
                  pASub_recv[ipar].SetNzja2 (3 * nlist2_temp);
                  int *pja2_temp = pASub_recv[ipar].GetJa2Arr ();
                  int j, jj;
                  int ibegblk = _hblk2blk_ini[jhblk];
                  int ibs =
                     pibs_hblk[jhblk] + (int) (_blks_ini[jblk + ibegblk] -
                                               _blks_ini[ibegblk]);
                  for (j = 0; j < nlist2_temp; j++) {
                     jj = plist2_temp[j];
                     pja2_temp[j * 3] = porder_3index[(ibs + jj) * 3];
                     pja2_temp[j * 3 + 1] = porder_3index[(ibs + jj) * 3 + 1];
                     pja2_temp[j * 3 + 2] = porder_3index[(ibs + jj) * 3 + 2];
                  }
               }
            }

         }
      }

// Pack data

      ObjRecv.resize (nrecv);

      pObjSend = NULL;

      if (nrecv > 0) {
         pObjSend = &ObjRecv[0];
      }

      {

         long long isize;
         char *pobj;

         int i;

         for (i = 0; i < nrecv; i++) {
            isize = phblk_recv[i].GetPackedSize ();
            pObjSend[i].resize ((size_t) isize);
            pobj = &(pObjSend[i][0]);
            phblk_recv[i].FillPacked_thr (isize, pobj);
            phblk_recv[i].Clean ();
         }

      }

// Send data back

      CMPIDataExchange::DataExchange (_comm, CpuIDRecv, ObjRecv, CpuIDSend, ObjSend);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDRecv.swap (CpuIDSend_temp);
         ObjRecv.swap (ObjSend_temp);
      }

// Unpack receive data

      nrecv = (int) CpuIDSend.size ();

      pObjRecv = NULL;

      if (nrecv > 0) {
         pObjRecv = &ObjSend[0];
      }

      hblk_recv.resize (nrecv + 1);

      phblk_recv = &hblk_recv[0];

      {

         long long isize;
         char *pobj;

         int i;

         for (i = 0; i < nrecv; i++) {
            isize = (long long) pObjRecv[i].size ();
            pobj = &(pObjRecv[i][0]);
            phblk_recv[i].UnPack_thr (isize, pobj);
         }

      }

// Free recv data

      {
         vector < int >CpuIDRecv_temp;
         vector < vector < char > >ObjRecv_temp;
         CpuIDSend.swap (CpuIDRecv_temp);
         ObjSend.swap (ObjRecv_temp);
      }

// Allocate and fill ja2 for all own blocks

      {

         int ihblk;
         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               int niblk = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
               CMatrix < _Int, _Flt > *pASub = _hmatr_arr_ini[ihblk].GetASubArr ();
               CMatrix < int, float >*phmatr = _hmatr_arr_ini[ihblk].GetHMatrStr ();
               int *pia_hblk = phmatr->GetIaArr ();
               int *pja_hblk = phmatr->GetJaArr ();
               int *pja2_hblk = phmatr->GetJa2Arr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int i, j, jj, jblk, jhblk;
                     int ibegblk = _hblk2blk_ini[ihblk];
                     for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                        jblk = pja_hblk[i];
                        jhblk = pja2_hblk[i];
                        int nzja_temp = pASub[i].GetNzja ();
                        _Int *pja_temp = pASub[i].GetJaArr ();
                        pASub[i].ResizeJa2 (3 * nzja_temp);
                        pASub[i].SetNzja2 (3 * nzja_temp);
                        _Int *pja2_temp = pASub[i].GetJa2Arr ();
                        if (jhblk == ihblk) {
                           int ibs =
                              pibs_hblk[ihblk] + (int) (_blks_ini[jblk + ibegblk] -
                                                        _blks_ini[ibegblk]);
                           for (j = 0; j < nzja_temp; j++) {
                              jj = (int) pja_temp[j];
                              pja2_temp[j * 3] = porder_3index[(ibs + jj) * 3];
                              pja2_temp[j * 3 + 1] = porder_3index[(ibs + jj) * 3 + 1];
                              pja2_temp[j * 3 + 2] = porder_3index[(ibs + jj) * 3 + 2];
                           }
                        }
                     }
                  }
               }
            }
         }

      }

// Compute Ptrs to 3indices data for not own blocks and fill ja2 for off hblocks

      CVectorData < CVectorData < CMatrix < int, float >*> >ptr3indT_arr (_nhblks_ini);
      CVectorData < CMatrix < int, float >*>*pptr3indT_arr = ptr3indT_arr.Ptr ();

      {

         int ihblk;

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               int nlistT_hblk = pstr_hblkT_arr[ihblk].GetNlist ();
               pptr3indT_arr[ihblk].resize (nlistT_hblk);
               CMatrix < int, float >**ppptr3indT_arr = pptr3indT_arr[ihblk].Ptr ();
               for (int i = 0; i < nlistT_hblk; i++)
                  ppptr3indT_arr[i] = NULL;
            }
         }

         {
            int ind_ini;
            for (int i = 0; i < nrecv; i++) {
               CMatrix < int, float >*pASub = phblk_recv[i].GetASubArr ();
               CMatrix < int, float >*phmatr = phblk_recv[i].GetHMatrStr ();
               int nlist_recv = phmatr->GetNlist ();
               int *plist_recv = phmatr->GetListArr ();
               int *plist2_recv = phmatr->GetList2Arr ();
               for (int j = 0; j < nlist_recv; j++) {
                  ind_ini = plist_recv[j];
                  ihblk = plist2_recv[j];
                  CMatrix < int, float >**ppptr3indT_arr = pptr3indT_arr[ihblk].Ptr ();
                  ppptr3indT_arr[ind_ini] = pASub + j;
               }
            }
         }

         {

            int nblks_ini = _hblk2blk_ini[_nhblks_ini];

            int nimax = 0;

            {
               for (int i = 0; i < nblks_ini; i++) {
                  int niloc = (int) (_blks_ini[i + 1] - _blks_ini[i]);
                  if (niloc > nimax)
                     nimax = niloc;
               }
            }

            CVectorData < int >imask_threads (nimax * n_thr + 1);
            int *pimask_threads = imask_threads.Ptr ();

            for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
               if (_hblk2cpu_ini[ihblk] == myid) {
                  CMatrix < _Int, _Flt > *pASub = _hmatr_arr_ini[ihblk].GetASubArr ();

                  int nlistT_hblk = pstr_hblkT_arr[ihblk].GetNlist ();
                  int *plist2T_hblk = pstr_hblkT_arr[ihblk].GetList2Arr ();
                  int *piaT_hblk = pstr_hblkT_arr[ihblk].GetIaArr ();

                  int *ppindT2N_arr = pindT2N_arr[ihblk].Ptr ();

                  {

#ifdef USE_THREADS
#pragma omp parallel for
#endif
                     for (int ipar = 0; ipar < nlistT_hblk; ipar++) {
                        int my_thr = 0;
#ifdef USE_THREADS
                        my_thr = omp_get_thread_num ();
#endif

                        int *pimask_th = pimask_threads + nimax * my_thr;

                        int i, j, jj, indj, k;

                        if (plist2T_hblk[ipar] != ihblk) {
                           CMatrix < int, float >**ppptr3indT_arr =
                              pptr3indT_arr[ihblk].Ptr ();
                           CMatrix < int, float >*ptr_3index_matr = ppptr3indT_arr[ipar];
                           int nlist2_3ind = ptr_3index_matr->GetNlist2 ();
                           int *plist2_3ind = ptr_3index_matr->GetList2Arr ();
                           int *pja2_3ind = ptr_3index_matr->GetJa2Arr ();
                           for (i = 0; i < nlist2_3ind; i++) {
                              jj = plist2_3ind[i];
                              pimask_th[jj] = i;
                           }
                           for (i = piaT_hblk[ipar]; i < piaT_hblk[ipar + 1]; i++) {
                              indj = ppindT2N_arr[i];
                              int nzja_temp = pASub[indj].GetNzja ();
                              _Int *pja_temp = pASub[indj].GetJaArr ();
                              _Int *pja2_temp = pASub[indj].GetJa2Arr ();
                              for (j = 0; j < nzja_temp; j++) {
                                 jj = (int) pja_temp[j];
                                 k = pimask_th[jj];
                                 pja2_temp[3 * j] = pja2_3ind[3 * k];
                                 pja2_temp[3 * j + 1] = pja2_3ind[3 * k + 1];
                                 pja2_temp[3 * j + 2] = pja2_3ind[3 * k + 2];
                              }
                           }
                        }
                     }
                  }
               }
            }

         }

      }

// Compute block rows with 3indices as column numbers

      CVectorData < CBMatrix < _Int, _Flt > >hblk_rows (_nhblks_ini);
      CBMatrix < _Int, _Flt > *phblk_rows = hblk_rows.Ptr ();

      {
         int ihblk;
         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               int niblk = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
               phblk_rows[ihblk].SetNzblk (niblk);
               phblk_rows[ihblk].ResizeASub (niblk);
               CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
               CMatrix < _Int, _Flt > *pASub = _hmatr_arr_ini[ihblk].GetASubArr ();
               CMatrix < int, float >*phmatr = _hmatr_arr_ini[ihblk].GetHMatrStr ();
               int *pia_hblk = phmatr->GetIaArr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int iblkgl = _hblk2blk_ini[ihblk] + ipar;
                     int ibegblk = _hblk2blk_ini[ihblk];
                     int ibs =
                        pibs_hblk[ihblk] + (int) (_blks_ini[ipar + ibegblk] -
                                                  _blks_ini[ibegblk]);
                     int ni_loc = (int) (_blks_ini[iblkgl + 1] - _blks_ini[iblkgl]);
                     int nzja_loc = 0;
                     int i;
                     for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                        nzja_loc += pASub[i].GetNzja ();
                     }
                     pASub_rows[ipar].ResizeAndSetAll (ni_loc, ni_loc * 3, 0,
                                                       nzja_loc * 3, nzja_loc * b_2);
                     _Int *plist_rows = pASub_rows[ipar].GetListArr ();
                     _Int *plist2_rows = pASub_rows[ipar].GetList2Arr ();
                     _Int *pia_rows = pASub_rows[ipar].GetIaArr ();
                     _Int *pja2_rows = pASub_rows[ipar].GetJa2Arr ();
                     _Flt *pa_rows = pASub_rows[ipar].GetAArr ();
                     for (i = 0; i < ni_loc; i++)
                        plist_rows[i] = (_Int) i;
                     for (i = 0; i <= ni_loc; i++)
                        pia_rows[i] = 0;
                     int j, jj, k, kind;
                     for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                        int nlist_temp = pASub[i].GetNlist ();
                        _Int *plist_temp = pASub[i].GetListArr ();
                        _Int *pia_temp = pASub[i].GetIaArr ();
                        for (j = 0; j < nlist_temp; j++) {
                           jj = (int) plist_temp[j];
                           pia_rows[jj + 1] += (pia_temp[j + 1] - pia_temp[j]);
                        }
                     }
                     for (i = 0; i < ni_loc; i++)
                        pia_rows[i + 1] += pia_rows[i];
                     CVectorData < int >iptr (ni_loc);
                     int *piptr = iptr.Ptr ();
                     for (i = 0; i < ni_loc; i++)
                        piptr[i] = (int) pia_rows[i];
                     for (i = 0; i < 3 * ni_loc; i++)
                        plist2_rows[i] = porder_3index[ibs * 3 + i];
                     for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                        int nlist_temp = pASub[i].GetNlist ();
                        _Int *plist_temp = pASub[i].GetListArr ();
                        _Int *pia_temp = pASub[i].GetIaArr ();
                        _Int *pja2_temp = pASub[i].GetJa2Arr ();
                        _Flt *pa_temp = pASub[i].GetAArr ();
                        for (j = 0; j < nlist_temp; j++) {
                           jj = (int) plist_temp[j];
                           kind = piptr[jj];
                           for (k = (int) pia_temp[j]; k < pia_temp[j + 1]; k++) {
                              pja2_rows[kind * 3] = pja2_temp[k * 3];
                              pja2_rows[kind * 3 + 1] = pja2_temp[k * 3 + 1];
                              pja2_rows[kind * 3 + 2] = pja2_temp[k * 3 + 2];
                              CVector < _Flt >::CopyVector (b_2, pa_temp + k * b_2,
                                                            pa_rows + kind * b_2);
                              kind++;
                           }
                           piptr[jj] = kind;;
                        }
                     }
                     for (i = pia_hblk[ipar]; i < pia_hblk[ipar + 1]; i++) {
                        pASub[i].ResizeList2 (0);
                        pASub[i].ResizeJa2 (0);
                        pASub[i].SetNlist2 (0);
                        pASub[i].SetNzja2 (0);
                     }
                  }
               }
            }
         }

      }

// Prepare sends

      CBMatrix < _Int, _Flt > hblk_myid;

      {

         int nblks_fin = _hblk2blk_fin[_nhblks_fin];

         CVectorData < int >imaskblk_threads (nblks_fin * 12 * n_thr);
         CVectorData < int >icycleblk_threads (2 * n_thr);
         CVectorData < int >nblk_threads (n_thr);

         int *pimaskblk_threads = imaskblk_threads.Ptr ();
         int *picycleblk_threads = icycleblk_threads.Ptr ();
         int *pnblk_threads = nblk_threads.Ptr ();

         {
            int i;
            for (i = 0; i < 2 * n_thr; i++)
               picycleblk_threads[i] = -1;
            for (i = 0; i < n_thr; i++)
               pnblk_threads[i] = 0;
         }

         int ihblk;

         CVectorData < CVectorData < int > >nzblk_arr (_nhblks_ini);
         CVectorData < CVectorData < vector < int > > >listblk_arr (_nhblks_ini);

         CVectorData < int >*pnzblk_arr = nzblk_arr.Ptr ();
         CVectorData < vector < int > >*plistblk_arr = listblk_arr.Ptr ();

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
               int niblk = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
               pnzblk_arr[ihblk].resize (niblk);
               plistblk_arr[ihblk].resize (niblk);
               int *ppnzblk_arr = pnzblk_arr[ihblk].Ptr ();
               vector < int >*pplistblk_arr = plistblk_arr[ihblk].Ptr ();
               {
                  for (int i = 0; i < niblk; i++)
                     ppnzblk_arr[i] = 0;
               }
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif
                     int *pimaskblk_th = pimaskblk_threads + 12 * nblks_fin * my_thr;
                     int *pimaskblk1_th = pimaskblk_th + nblks_fin;
                     int *pindblk_th = pimaskblk_th + 2 * nblks_fin;
                     int *pindblk1_th = pindblk_th + nblks_fin;
                     int *plistblk_th = pindblk_th + 2 * nblks_fin;
                     int *plistblk1_th = plistblk_th + 4 * nblks_fin;
                     int icycleblk_th = picycleblk_threads[2 * my_thr];
                     int icycleblk1_th = picycleblk_threads[2 * my_thr + 1];
                     int nblk_th = pnblk_threads[my_thr];

                     int i;

                     if (icycleblk_th == -1) {
                        for (i = 0; i < 2 * nblks_fin; i++)
                           pimaskblk_th[i] = -1;
                        icycleblk_th = 0;
                     }

                     icycleblk1_th++;

                     int iblkgl = _hblk2blk_ini[ihblk] + ipar;
                     int ni_loc = (int) (_blks_ini[iblkgl + 1] - _blks_ini[iblkgl]);
                     _Int *plist2_temp = pASub_rows[ipar].GetList2Arr ();
                     _Int *pia_temp = pASub_rows[ipar].GetIaArr ();
                     int jblk, jhblk, jblkgl, ind;
                     int nblk1_th = 0;
                     for (i = 0; i < ni_loc; i++) {
                        jblk = (int) plist2_temp[i * 3 + 1];
                        jhblk = (int) plist2_temp[i * 3 + 2];
                        jblkgl = _hblk2blk_fin[jhblk] + jblk;
                        if (pimaskblk_th[jblkgl] != icycleblk_th) {
                           pimaskblk_th[jblkgl] = icycleblk_th;
                           pindblk_th[jblkgl] = nblk_th;
                           plistblk_th[nblk_th * 4] = jblk;
                           plistblk_th[nblk_th * 4 + 1] = jhblk;
                           plistblk_th[nblk_th * 4 + 2] = 0;
                           plistblk_th[nblk_th * 4 + 3] = 0;
                           nblk_th++;
                        }
                        if (pimaskblk1_th[jblkgl] != icycleblk1_th) {
                           pimaskblk1_th[jblkgl] = icycleblk1_th;
                           pindblk1_th[jblkgl] = nblk1_th;
                           plistblk1_th[nblk1_th * 4] = jblk;
                           plistblk1_th[nblk1_th * 4 + 1] = jhblk;
                           plistblk1_th[nblk1_th * 4 + 2] = 0;
                           plistblk1_th[nblk1_th * 4 + 3] = 0;
                           nblk1_th++;
                        }
                        ind = pindblk_th[jblkgl];
                        plistblk_th[ind * 4 + 2]++;
                        plistblk_th[ind * 4 + 3] += (int) (pia_temp[i + 1] - pia_temp[i]);
                        ind = pindblk1_th[jblkgl];
                        plistblk1_th[ind * 4 + 2]++;
                        plistblk1_th[ind * 4 + 3] +=
                           (int) (pia_temp[i + 1] - pia_temp[i]);
                     }
                     ppnzblk_arr[ipar] = nblk1_th;
                     for (i = 0; i < 4 * nblk1_th; i++) {
                        pplistblk_arr[ipar].push_back (plistblk1_th[i]);
                     }
                     picycleblk_threads[2 * my_thr] = icycleblk_th;
                     picycleblk_threads[2 * my_thr + 1] = icycleblk1_th;
                     pnblk_threads[my_thr] = nblk_th;
                  }
               }
            }
         }

         {
            int i, i_thr, jblk, jhblk, jblkgl, ind;
            for (i_thr = 1; i_thr < n_thr; i_thr++) {
               int *pimaskblk_th0 = pimaskblk_threads;
               int *pindblk_th0 = pimaskblk_th0 + 2 * nblks_fin;
               int *plistblk_th0 = pindblk_th0 + 2 * nblks_fin;
               int icycleblk_th0 = picycleblk_threads[0];
               int nblk_th0 = pnblk_threads[0];
               if (icycleblk_th0 == -1) {
                  for (i = 0; i < 2 * nblks_fin; i++)
                     pimaskblk_th0[i] = -1;
                  icycleblk_th0 = 0;
               }
               int *pimaskblk_th = pimaskblk_threads + 12 * nblks_fin * i_thr;
               int *plistblk_th = pimaskblk_th + 4 * nblks_fin;
               int nblk_th = pnblk_threads[i_thr];
               for (i = 0; i < nblk_th; i++) {
                  jblk = plistblk_th[4 * i];
                  jhblk = plistblk_th[4 * i + 1];
                  jblkgl = _hblk2blk_fin[jhblk] + jblk;
                  if (pimaskblk_th0[jblkgl] != icycleblk_th0) {
                     pimaskblk_th0[jblkgl] = icycleblk_th0;
                     pindblk_th0[jblkgl] = nblk_th0;
                     plistblk_th0[nblk_th0 * 4] = jblk;
                     plistblk_th0[nblk_th0 * 4 + 1] = jhblk;
                     plistblk_th0[nblk_th0 * 4 + 2] = 0;
                     plistblk_th0[nblk_th0 * 4 + 3] = 0;
                     nblk_th0++;
                  }
                  ind = pindblk_th0[jblkgl];
                  plistblk_th0[ind * 4 + 2] += plistblk_th[4 * i + 2];
                  plistblk_th0[ind * 4 + 3] += plistblk_th[4 * i + 3];
               }
               pnblk_threads[0] = nblk_th0;
               picycleblk_threads[0] = icycleblk_th0;
            }
         }

// Sort obtained list of blocks

         int nblks_curr = pnblk_threads[0];
         int *plist4ind_th0 = pimaskblk_threads + 4 * nblks_fin;

         CVectorData < int >list4ind_curr (nblks_curr * 4);
         int *plist4ind_curr = list4ind_curr.Ptr ();

         {
            CVectorData < CSortInt2 > ii2arr (nblks_curr);
            CSortInt2 *pii2arr = ii2arr.Ptr ();
            int i;
            for (i = 0; i < nblks_curr; i++) {
               pii2arr[i].ixval = plist4ind_th0[i * 4 + 1];
               pii2arr[i].iyval = plist4ind_th0[i * 4];
               pii2arr[i].itail = i;
            }
            sort (pii2arr, pii2arr + nblks_curr);
            int ind;
            for (i = 0; i < nblks_curr; i++) {
               ind = pii2arr[i].itail;
               plist4ind_curr[i * 4] = plist4ind_th0[ind * 4];
               plist4ind_curr[i * 4 + 1] = plist4ind_th0[ind * 4 + 1];
               plist4ind_curr[i * 4 + 2] = plist4ind_th0[ind * 4 + 2];
               plist4ind_curr[i * 4 + 3] = plist4ind_th0[ind * 4 + 3];
            }
         }

// Allocate blocks for data store

         CVectorData < int >imaskhblk (_nhblks_fin);
         CVectorData < int >listhblk (_nhblks_fin);
         CVectorData < int >ibshblk (_nhblks_fin);

         int *pimaskhblk = imaskhblk.Ptr ();
         int *plisthblk = listhblk.Ptr ();
         int *pibshblk = ibshblk.Ptr ();

         int nlisthblk_curr = 0;
         int nzblk_hblk = 0;

         {
            int i, jhblk;
            for (i = 0; i < _nhblks_fin; i++)
               pimaskhblk[i] = -1;
            for (i = 0; i < nblks_curr; i++) {
               jhblk = plist4ind_curr[i * 4 + 1];
               if (pimaskhblk[jhblk] < 0) {
                  plisthblk[nlisthblk_curr] = jhblk;
                  nlisthblk_curr++;
                  pimaskhblk[jhblk] = 1;
               }
            }
            sort (plisthblk, plisthblk + nlisthblk_curr);
            for (i = 0; i < nlisthblk_curr; i++) {
               jhblk = plisthblk[i];
               pibshblk[jhblk] = nzblk_hblk;
               nzblk_hblk += (_hblk2blk_fin[jhblk + 1] - _hblk2blk_fin[jhblk]);
            }
         }

// Compute references to blocks and allocate memory

         CVectorData < int >ind2blks (nzblk_hblk);
         int *pind2blks = ind2blks.Ptr ();

         {
            int i, jblk, jhblk, ibs;
            for (i = 0; i < nzblk_hblk; i++)
               pind2blks[i] = -1;
            for (i = 0; i < nblks_curr; i++) {
               jblk = plist4ind_curr[i * 4];
               jhblk = plist4ind_curr[i * 4 + 1];
               ibs = pibshblk[jhblk];
               pind2blks[ibs + jblk] = i;
            }
         }

         CVectorData < CMatrix < _Int, _Flt > >blkrows_new (nblks_curr);
         CMatrix < _Int, _Flt > *pblkrows_new = blkrows_new.Ptr ();

         {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
            for (int ipar = 0; ipar < nblks_curr; ipar++) {
               int nlist_temp = plist4ind_curr[ipar * 4 + 2];
               int nzja_temp = plist4ind_curr[ipar * 4 + 3];
               pblkrows_new[ipar].ResizeAndSetAll (nlist_temp, 3 * nlist_temp, 0,
                                                   3 * nzja_temp, nzja_temp * b_2);
               _Int *pia_rows_new = pblkrows_new[ipar].GetIaArr ();
               pia_rows_new[0] = 0;
               plist4ind_curr[ipar * 4 + 2] = 0;
               plist4ind_curr[ipar * 4 + 3] = 0;
            }

         }

// Compute local references in terms of stored initial block row data

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               int niblk = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
               int *ppnzblk_arr = pnzblk_arr[ihblk].Ptr ();
               vector < int >*pplistblk_arr = plistblk_arr[ihblk].Ptr ();
               int i, j, nlist_temp, nzja_temp, ind, jblk, jhblk, ibs;
               for (i = 0; i < niblk; i++) {
                  int *ppplistblk_arr = NULL;
                  if (ppnzblk_arr[i] > 0)
                     ppplistblk_arr = &pplistblk_arr[i][0];
                  for (j = 0; j < ppnzblk_arr[i]; j++) {
                     jblk = ppplistblk_arr[j * 4];
                     jhblk = ppplistblk_arr[j * 4 + 1];
                     nlist_temp = ppplistblk_arr[j * 4 + 2];
                     nzja_temp = ppplistblk_arr[j * 4 + 3];
                     ibs = pibshblk[jhblk];
                     ind = pind2blks[ibs + jblk];
                     ppplistblk_arr[j * 4 + 2] = plist4ind_curr[ind * 4 + 2];
                     ppplistblk_arr[j * 4 + 3] = plist4ind_curr[ind * 4 + 3];
                     plist4ind_curr[ind * 4 + 2] += nlist_temp;
                     plist4ind_curr[ind * 4 + 3] += nzja_temp;
                  }
               }
            }
         }

// Rewrite block row data

         for (ihblk = 0; ihblk < _nhblks_ini; ihblk++) {
            if (_hblk2cpu_ini[ihblk] == myid) {
               CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
               int niblk = _hblk2blk_ini[ihblk + 1] - _hblk2blk_ini[ihblk];
               int *ppnzblk_arr = pnzblk_arr[ihblk].Ptr ();
               vector < int >*pplistblk_arr = plistblk_arr[ihblk].Ptr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif
                     int *pimaskblk_th = pimaskblk_threads + 12 * nblks_fin * my_thr;
                     int *pindblk_th = pimaskblk_th + 2 * nblks_fin;
                     int *pindblk1_th = pindblk_th + nblks_fin;

                     int *ppplistblk_arr = NULL;
                     if (ppnzblk_arr[ipar] > 0)
                        ppplistblk_arr = &pplistblk_arr[ipar][0];

                     int iblkgl = _hblk2blk_ini[ihblk] + ipar;
                     int ni_loc = (int) (_blks_ini[iblkgl + 1] - _blks_ini[iblkgl]);
                     int jblk, jhblk, jblkgl, ind, ibs, i;
                     for (i = 0; i < ppnzblk_arr[ipar]; i++) {
                        jblk = ppplistblk_arr[i * 4];
                        jhblk = ppplistblk_arr[i * 4 + 1];
                        jblkgl = _hblk2blk_fin[jhblk] + jblk;
                        ibs = pibshblk[jhblk];
                        ind = pind2blks[ibs + jblk];
                        pindblk_th[jblkgl] = ind;
                        pindblk1_th[jblkgl] = i;
                     }
                     _Int *plist2_temp = pASub_rows[ipar].GetList2Arr ();
                     _Int *pia_temp = pASub_rows[ipar].GetIaArr ();
                     _Int *pja2_temp = pASub_rows[ipar].GetJa2Arr ();
                     _Flt *pa_temp = pASub_rows[ipar].GetAArr ();
                     int indblk, indreg, ilist, nz, j;
                     for (i = 0; i < ni_loc; i++) {
                        jblk = (int) plist2_temp[i * 3 + 1];
                        jhblk = (int) plist2_temp[i * 3 + 2];
                        jblkgl = _hblk2blk_fin[jhblk] + jblk;
                        indblk = pindblk_th[jblkgl];
                        indreg = pindblk1_th[jblkgl];
                        ilist = ppplistblk_arr[4 * indreg + 2];
                        nz = ppplistblk_arr[4 * indreg + 3];
                        _Int *plist2_rows_new = pblkrows_new[indblk].GetList2Arr ();
                        _Int *pia_rows_new = pblkrows_new[indblk].GetIaArr ();
                        _Int *pja2_rows_new = pblkrows_new[indblk].GetJa2Arr ();
                        _Flt *pa_rows_new = pblkrows_new[indblk].GetAArr ();
                        plist2_rows_new[ilist * 3] = plist2_temp[i * 3];
                        plist2_rows_new[ilist * 3 + 1] = plist2_temp[i * 3 + 1];
                        plist2_rows_new[ilist * 3 + 2] = plist2_temp[i * 3 + 2];
                        for (j = (int) pia_temp[i]; j < pia_temp[i + 1]; j++) {
                           pja2_rows_new[nz * 3] = pja2_temp[j * 3];
                           pja2_rows_new[nz * 3 + 1] = pja2_temp[j * 3 + 1];
                           pja2_rows_new[nz * 3 + 2] = pja2_temp[j * 3 + 2];
                           CVector < _Flt >::CopyVector (b_2, pa_temp + j * b_2,
                                                         pa_rows_new + nz * b_2);
                           nz++;
                        }
                        pia_rows_new[ilist + 1] = (_Int) nz;
                        ilist++;
                        ppplistblk_arr[4 * indreg + 2] = ilist;
                        ppplistblk_arr[4 * indreg + 3] = nz;
                     }
                  }

               }

               phblk_rows[ihblk].Clean ();

            }
         }

// Finally combine blocks for send

         CVectorData < int >imaskcpu (nproc);
         CVectorData < int >listcpu (nproc);
         CVectorData < int >nzcpu (nproc);

         int *pimaskcpu = imaskcpu.Ptr ();
         int *plistcpu = listcpu.Ptr ();
         int *pnzcpu = nzcpu.Ptr ();

         int nlistcpu = 0;

         {
            int i, jhblk, jcpu;
            for (i = 0; i < nproc; i++) {
               pimaskcpu[i] = -1;
               pnzcpu[i] = 0;
            }
            pimaskcpu[myid] = 1;
            plistcpu[nlistcpu] = myid;
            nlistcpu++;
            for (i = 0; i < nblks_curr; i++) {
               jhblk = plist4ind_curr[i * 4 + 1];
               jcpu = _hblk2cpu_fin[jhblk];
               pnzcpu[jcpu]++;
               if (pimaskcpu[jcpu] < 0) {
                  pimaskcpu[jcpu] = 1;
                  plistcpu[nlistcpu] = jcpu;
                  nlistcpu++;
               }
            }
            sort (plistcpu + 1, plistcpu + nlistcpu);
            for (i = 0; i < nlistcpu; i++) {
               jcpu = plistcpu[i];
               pimaskcpu[jcpu] = i;
            }

            vector < CBMatrix < _Int, _Flt > >hblk_send_temp (nlistcpu + 1);
            CBMatrix < _Int, _Flt > *phblk_send_temp = &hblk_send_temp[0];

            int nzblk;

            for (i = 0; i < nlistcpu; i++) {
               jcpu = plistcpu[i];
               nzblk = pnzcpu[jcpu];
               phblk_send_temp[i].ResizeASub (nzblk);
               phblk_send_temp[i].SetNzblk (nzblk);
               CMatrix < int, float >*phmatr = phblk_send_temp[i].GetHMatrStr ();
               phmatr->ResizeAndSetAllSp (nzblk, nzblk, 0, 0);
               pnzcpu[jcpu] = 0;
            }

            int jblk, ind, k;

            for (i = 0; i < nblks_curr; i++) {
               jblk = plist4ind_curr[i * 4];
               jhblk = plist4ind_curr[i * 4 + 1];
               jcpu = _hblk2cpu_fin[jhblk];
               ind = pimaskcpu[jcpu];
               CMatrix < _Int, _Flt > *pASub = phblk_send_temp[ind].GetASubArr ();
               CMatrix < int, float >*phmatr = phblk_send_temp[ind].GetHMatrStr ();
               k = pnzcpu[jcpu];
               int *plist_hblk = phmatr->GetListArr ();
               int *plist2_hblk = phmatr->GetList2Arr ();
               plist_hblk[k] = jblk;
               plist2_hblk[k] = jhblk;
               pASub[k].ReplaceFree (pblkrows_new[i]);
               pnzcpu[jcpu]++;
            }

// Pack send data

            CpuIDSend.resize (nlistcpu - 1);
            ObjSend.resize (nlistcpu - 1);

            pCpuIDSend = NULL;
            pObjSend = NULL;

            if (nlistcpu > 1) {
               pCpuIDSend = &CpuIDSend[0];
               pObjSend = &ObjSend[0];
            }

            long long isize;
            char *pobj;

            {
               int i;
               for (i = 1; i < nlistcpu; i++) {
                  pCpuIDSend[i - 1] = plistcpu[i];
                  isize = phblk_send_temp[i].GetPackedSize ();
                  pObjSend[i - 1].resize ((size_t) isize);
                  pobj = &(pObjSend[i - 1][0]);
                  phblk_send_temp[i].FillPacked_thr (isize, pobj);
                  phblk_send_temp[i].Clean ();
               }
            }

            hblk_myid.ReplaceFree (phblk_send_temp[0]);

         }

      }

// Exchange

      CMPIDataExchange::DataExchange (_comm, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      nrecv = (int) CpuIDRecv.size () + 1;

      pObjRecv = NULL;

      if (nrecv > 1) {
         pObjRecv = &ObjRecv[0];
      }

      vector < CBMatrix < _Int, _Flt > >hblk_recv_temp (nrecv + 1);

      CBMatrix < _Int, _Flt > *phblk_recv_temp = &hblk_recv_temp[0];

      phblk_recv_temp[0].ReplaceFree (hblk_myid);

      {

         long long isize;
         char *pobj;

         int i;

         for (i = 1; i < nrecv; i++) {
            isize = (long long) pObjRecv[i - 1].size ();
            pobj = &(pObjRecv[i - 1][0]);
            phblk_recv_temp[i].UnPack_thr (isize, pobj);
         }

      }

// Free recv data

      {
         vector < vector < char > >ObjRecv_temp;
         ObjRecv.swap (ObjRecv_temp);
      }

// Create set of received block rows

      hblk_rows.resize (_nhblks_fin + 1);
      phblk_rows = hblk_rows.Ptr ();

      {
         int ihblk;
         for (ihblk = 0; ihblk < _nhblks_fin; ihblk++) {
            if (_hblk2cpu_fin[ihblk] == myid) {
               int niblk = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];
               phblk_rows[ihblk].ResizeASub (niblk);
               CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int iblkgl = _hblk2blk_fin[ihblk] + ipar;
                     int ni_loc = (int) (_blks_fin[iblkgl + 1] - _blks_fin[iblkgl]);
                     pASub_rows[ipar].SetNlist (ni_loc);
                     pASub_rows[ipar].ResizeList (ni_loc);
                     pASub_rows[ipar].ResizeIa (ni_loc);
                     _Int *plist_temp = pASub_rows[ipar].GetListArr ();
                     _Int *pia_temp = pASub_rows[ipar].GetIaArr ();
                     int i;
                     for (i = 0; i < ni_loc; i++)
                        plist_temp[i] = i;
                     for (i = 0; i <= ni_loc; i++)
                        pia_temp[i] = 0;
                  }

               }

            }
         }

         for (ihblk = 0; ihblk < nrecv; ihblk++) {
            int nzblk = phblk_recv_temp[ihblk].GetNzblk ();
            CMatrix < int, float >*phmatr_recv = phblk_recv_temp[ihblk].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pASub_recv = phblk_recv_temp[ihblk].GetASubArr ();
            int *plist_hmatr = phmatr_recv->GetListArr ();
            int *plist2_hmatr = phmatr_recv->GetList2Arr ();
            {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
               for (int ipar = 0; ipar < nzblk; ipar++) {
                  int jblk = plist_hmatr[ipar];
                  int jhblk = plist2_hmatr[ipar];
                  int nlist_temp = pASub_recv[ipar].GetNlist ();
                  _Int *plist2_temp = pASub_recv[ipar].GetList2Arr ();
                  _Int *pia_temp = pASub_recv[ipar].GetIaArr ();
                  CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[jhblk].GetASubArr ();
                  _Int *pia_rows = pASub_rows[jblk].GetIaArr ();
                  int i, jj;
                  for (i = 0; i < nlist_temp; i++) {
                     jj = (int) plist2_temp[i * 3];
                     pia_rows[jj + 1] = (pia_temp[i + 1] - pia_temp[i]);
                  }
               }
            }

         }

         for (ihblk = 0; ihblk < _nhblks_fin; ihblk++) {
            if (_hblk2cpu_fin[ihblk] == myid) {
               int niblk = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];
               CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int iblkgl = _hblk2blk_fin[ihblk] + ipar;
                     int ni_loc = (int) (_blks_fin[iblkgl + 1] - _blks_fin[iblkgl]);
                     _Int *pia_temp = pASub_rows[ipar].GetIaArr ();
                     int i;
                     for (i = 0; i < ni_loc; i++)
                        pia_temp[i + 1] += pia_temp[i];
                     int nzja_temp = (int) pia_temp[ni_loc];
                     pASub_rows[ipar].ResizeJa2 (3 * nzja_temp);
                     pASub_rows[ipar].ResizeA (nzja_temp * b_2);
                     pASub_rows[ipar].SetNzja2 (nzja_temp * 3);
                     pASub_rows[ipar].SetNza (nzja_temp * b_2);
                  }

               }

            }
         }

         for (ihblk = 0; ihblk < nrecv; ihblk++) {
            int nzblk = phblk_recv_temp[ihblk].GetNzblk ();
            CMatrix < int, float >*phmatr_recv = phblk_recv_temp[ihblk].GetHMatrStr ();
            CMatrix < _Int, _Flt > *pASub_recv = phblk_recv_temp[ihblk].GetASubArr ();
            int *plist_hmatr = phmatr_recv->GetListArr ();
            int *plist2_hmatr = phmatr_recv->GetList2Arr ();
            {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
               for (int ipar = 0; ipar < nzblk; ipar++) {
                  int jblk = plist_hmatr[ipar];
                  int jhblk = plist2_hmatr[ipar];
                  int nlist_temp = pASub_recv[ipar].GetNlist ();
                  _Int *plist2_temp = pASub_recv[ipar].GetList2Arr ();
                  _Int *pia_temp = pASub_recv[ipar].GetIaArr ();
                  _Int *pja2_temp = pASub_recv[ipar].GetJa2Arr ();
                  _Flt *pa_temp = pASub_recv[ipar].GetAArr ();
                  CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[jhblk].GetASubArr ();
                  _Int *pia_rows = pASub_rows[jblk].GetIaArr ();
                  _Int *pja2_rows = pASub_rows[jblk].GetJa2Arr ();
                  _Flt *pa_rows = pASub_rows[jblk].GetAArr ();
                  int i, jj, j, ibs;
                  for (i = 0; i < nlist_temp; i++) {
                     jj = (int) plist2_temp[i * 3];
                     ibs = (int) pia_rows[jj];
                     for (j = (int) pia_temp[i]; j < pia_temp[i + 1]; j++) {
                        pja2_rows[ibs * 3] = pja2_temp[j * 3];
                        pja2_rows[ibs * 3 + 1] = pja2_temp[j * 3 + 1];
                        pja2_rows[ibs * 3 + 2] = pja2_temp[j * 3 + 2];
                        CVector < _Flt >::CopyVector (b_2, pa_temp + j * b_2,
                                                      pa_rows + ibs * b_2);
                        ibs++;
                     }
                  }
               }
            }

            phblk_recv_temp[ihblk].Clean ();

         }

         hblk_recv_temp.resize (0);

      }

// Sort block rows data

      {
         int ihblk;
         for (ihblk = 0; ihblk < _nhblks_fin; ihblk++) {
            if (_hblk2cpu_fin[ihblk] == myid) {
               int niblk = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
                     int nlist_rows = pASub_rows[ipar].GetNlist ();
                     _Int *pia_rows = pASub_rows[ipar].GetIaArr ();
                     _Int *pja2_rows = pASub_rows[ipar].GetJa2Arr ();
                     _Flt *pa_rows = pASub_rows[ipar].GetAArr ();
                     int i, jj, j, niloc;
                     int nimax = 0;
                     for (i = 0; i < nlist_rows; i++) {
                        niloc = (int) (pia_rows[i + 1] - pia_rows[i]);
                        if (niloc > nimax)
                           nimax = niloc;
                     }
                     CVectorData < CSortInt2 > ii2arr (nimax);
                     CVectorData < _Int > i3index (3 * nimax);
                     CVectorData < _Flt > elems (nimax * b_2);
                     CSortInt2 *pii2arr = ii2arr.Ptr ();
                     _Int *pi3index = i3index.Ptr ();
                     _Flt *pelems = elems.Ptr ();
                     int ibeg, jext, jind, jblk, jhblk, jblkgl;
                     for (i = 0; i < nlist_rows; i++) {
                        niloc = (int) (pia_rows[i + 1] - pia_rows[i]);
                        ibeg = (int) pia_rows[i];
                        for (j = 0; j < niloc; j++) {
                           jext = j + ibeg;
                           jj = (int) pja2_rows[jext * 3];
                           jblk = (int) pja2_rows[jext * 3 + 1];
                           jhblk = (int) pja2_rows[jext * 3 + 2];
                           jblkgl = _hblk2blk_fin[jhblk] + jblk;
                           pii2arr[j].ixval = jblkgl;
                           pii2arr[j].iyval = jj;
                           pii2arr[j].itail = jext;
                        }
                        sort (pii2arr, pii2arr + niloc);
                        for (j = 0; j < niloc; j++) {
                           jind = pii2arr[j].itail;
                           pi3index[j * 3] = pja2_rows[jind * 3];
                           pi3index[j * 3 + 1] = pja2_rows[jind * 3 + 1];
                           pi3index[j * 3 + 2] = pja2_rows[jind * 3 + 2];
                           CVector < _Flt >::CopyVector (b_2, pa_rows + jind * b_2,
                                                         pelems + j * b_2);
                        }
                        for (j = 0; j < niloc; j++) {
                           jext = j + ibeg;
                           pja2_rows[jext * 3] = pi3index[j * 3];
                           pja2_rows[jext * 3 + 1] = pi3index[j * 3 + 1];
                           pja2_rows[jext * 3 + 2] = pi3index[j * 3 + 2];
                           CVector < _Flt >::CopyVector (b_2, pelems + j * b_2,
                                                         pa_rows + jext * b_2);
                        }
                     }
                  }
               }

            }
         }

      }

// Form final hblocks

      {
         int ihblk;

         int nblks_fin = _hblk2blk_fin[_nhblks_fin];

         CVectorData < int >imaskblk_threads (nblks_fin * 4 * n_thr);
         CVectorData < int >icycleblk_threads (n_thr);

         int *pimaskblk_threads = imaskblk_threads.Ptr ();
         int *picycleblk_threads = icycleblk_threads.Ptr ();

         {
            int i;
            for (i = 0; i < n_thr; i++)
               picycleblk_threads[i] = -1;
         }

         for (ihblk = 0; ihblk < _nhblks_fin; ihblk++) {
            if (_hblk2cpu_fin[ihblk] == myid) {
               int niblk = _hblk2blk_fin[ihblk + 1] - _hblk2blk_fin[ihblk];
               CVectorData < int >nzblk_arr (niblk);
               CVectorData < CVectorData < int > >list2blk_arr (niblk);
               CVectorData < CVectorData < CMatrix < _Int, _Flt > > >blks_arr (niblk);
               int *pnzblk_arr = nzblk_arr.Ptr ();
               CVectorData < int >*plist2blk_arr = list2blk_arr.Ptr ();
               CVectorData < CMatrix < _Int, _Flt > >*pblks_arr = blks_arr.Ptr ();
               {
#ifdef USE_THREADS
#pragma omp parallel for
#endif
                  for (int ipar = 0; ipar < niblk; ipar++) {
                     int my_thr = 0;
#ifdef USE_THREADS
                     my_thr = omp_get_thread_num ();
#endif
                     int *pimaskblk_th = pimaskblk_threads + 4 * nblks_fin * my_thr;
                     int *pindblk_th = pimaskblk_th + nblks_fin;
                     int *plistblk_th = pindblk_th + nblks_fin;
                     int *pnzblk_th = plistblk_th + nblks_fin;
                     int icycleblk_th = picycleblk_threads[my_thr];

                     int i;

                     if (icycleblk_th == -1) {
                        for (i = 0; i < nblks_fin; i++)
                           pimaskblk_th[i] = -1;
                     }

                     icycleblk_th++;

                     int iblkgl = _hblk2blk_fin[ihblk] + ipar;
                     int ni_loc = (int) (_blks_fin[iblkgl + 1] - _blks_fin[iblkgl]);
                     CMatrix < _Int, _Flt > *pASub_rows = phblk_rows[ihblk].GetASubArr ();
                     int nlist_rows = pASub_rows[ipar].GetNlist ();
                     _Int *pia_rows = pASub_rows[ipar].GetIaArr ();
                     _Int *pja2_rows = pASub_rows[ipar].GetJa2Arr ();
                     _Flt *pa_rows = pASub_rows[ipar].GetAArr ();
                     int j, jj, jblk, jhblk, jblkgl;
                     int nlistblk = 0;
                     for (i = 0; i < nlist_rows; i++) {
                        for (j = (int) pia_rows[i]; j < pia_rows[i + 1]; j++) {
                           jblk = (int) pja2_rows[j * 3 + 1];
                           jhblk = (int) pja2_rows[j * 3 + 2];
                           jblkgl = _hblk2blk_fin[jhblk] + jblk;
                           if (pimaskblk_th[jblkgl] != icycleblk_th) {
                              pimaskblk_th[jblkgl] = icycleblk_th;
                              plistblk_th[nlistblk] = jblkgl;
                              nlistblk++;
                           }
                        }
                     }
                     pnzblk_arr[ipar] = nlistblk;
                     plist2blk_arr[ipar].resize (2 * nlistblk);
                     int *pplist2blk_arr = plist2blk_arr[ipar].Ptr ();
                     for (i = 0; i < 2 * nlistblk; i++)
                        pplist2blk_arr[i] = -1;
                     sort (plistblk_th, plistblk_th + nlistblk);
                     for (i = 0; i < nlistblk; i++) {
                        jblkgl = plistblk_th[i];
                        pindblk_th[jblkgl] = i;
                        pnzblk_th[jblkgl] = 0;
                     }
                     int ind;
                     for (i = 0; i < nlist_rows; i++) {
                        for (j = (int) pia_rows[i]; j < pia_rows[i + 1]; j++) {
                           jblk = (int) pja2_rows[j * 3 + 1];
                           jhblk = (int) pja2_rows[j * 3 + 2];
                           jblkgl = _hblk2blk_fin[jhblk] + jblk;
                           pnzblk_th[jblkgl]++;
                           ind = pindblk_th[jblkgl];
                           if (pplist2blk_arr[ind * 2] < 0) {
                              pplist2blk_arr[ind * 2] = jblk;
                              pplist2blk_arr[ind * 2 + 1] = jhblk;
                           }
                        }
                     }
                     CVectorData < CVectorData < _Int > >rowsarr (nlistblk);
                     CVectorData < CVectorData < _Int > >colsarr (nlistblk);
                     CVectorData < CVectorData < _Flt > >elemsarr (nlistblk);
                     CVectorData < _Int > *prowsarr = rowsarr.Ptr ();
                     CVectorData < _Int > *pcolsarr = colsarr.Ptr ();
                     CVectorData < _Flt > *pelemsarr = elemsarr.Ptr ();
                     int nz;
                     for (i = 0; i < nlistblk; i++) {
                        jblkgl = plistblk_th[i];
                        nz = pnzblk_th[jblkgl];
                        prowsarr[i].resize (nz);
                        pcolsarr[i].resize (nz);
                        pelemsarr[i].resize (nz * b_2);
                        pnzblk_th[jblkgl] = 0;
                     }
                     for (i = 0; i < nlist_rows; i++) {
                        for (j = (int) pia_rows[i]; j < pia_rows[i + 1]; j++) {
                           jj = (int) pja2_rows[j * 3];
                           jblk = (int) pja2_rows[j * 3 + 1];
                           jhblk = (int) pja2_rows[j * 3 + 2];
                           jblkgl = _hblk2blk_fin[jhblk] + jblk;
                           ind = pindblk_th[jblkgl];
                           nz = pnzblk_th[jblkgl];
                           _Int *pprowsarr = prowsarr[ind].Ptr ();
                           _Int *ppcolsarr = pcolsarr[ind].Ptr ();
                           _Flt *ppelemsarr = pelemsarr[ind].Ptr ();
                           pprowsarr[nz] = i;
                           ppcolsarr[nz] = jj;
                           CVector < _Flt >::CopyVector (b_2, pa_rows + j * b_2,
                                                         ppelemsarr + nz * b_2);
                           pnzblk_th[jblkgl]++;
                        }
                     }
                     pblks_arr[ipar].resize (nlistblk);
                     CMatrix < _Int, _Flt > *ppblks_arr = pblks_arr[ipar].Ptr ();
                     int nimax = ni_loc;
                     int nj_loc;
                     for (i = 0; i < nlistblk; i++) {
                        jblkgl = plistblk_th[i];
                        nj_loc = (int) (_blks_fin[jblkgl + 1] - _blks_fin[jblkgl]);
                        if (nj_loc > nimax)
                           nimax = nj_loc;
                     }
                     CVectorData < int >imask (5 * nimax + 1);
                     int *pimask = imask.Ptr ();
                     int *plist = pimask + nimax;
                     int *pindarr = plist + nimax;
                     int *piptr = pindarr + nimax;
                     int *pialoc = piptr + nimax;
                     for (i = 0; i < nimax; i++)
                        pimask[i] = -1;
                     int icycle = -1;
                     int indj, k;
                     for (i = 0; i < nlistblk; i++) {
                        icycle++;
                        jblkgl = plistblk_th[i];
                        ind = pindblk_th[jblkgl];
                        nz = pnzblk_th[jblkgl];
                        _Int *pprowsarr = prowsarr[ind].Ptr ();
                        _Int *ppcolsarr = pcolsarr[ind].Ptr ();
                        _Flt *ppelemsarr = pelemsarr[ind].Ptr ();
                        int nlist_temp = 0;
                        for (j = 0; j < nz; j++) {
                           jj = (int) pprowsarr[j];
                           if (pimask[jj] != icycle) {
                              pimask[jj] = icycle;
                              plist[nlist_temp] = jj;
                              nlist_temp++;
                           }
                        }
                        sort (plist, plist + nlist_temp);
                        pialoc[0] = 0;
                        for (j = 0; j < nlist_temp; j++) {
                           jj = plist[j];
                           pindarr[jj] = j;
                           pialoc[j + 1] = 0;
                        }
                        for (j = 0; j < nz; j++) {
                           jj = (int) pprowsarr[j];
                           indj = pindarr[jj];
                           pialoc[indj + 1]++;
                        }
                        for (j = 0; j < nlist_temp; j++)
                           pialoc[j + 1] += pialoc[j];
                        for (j = 0; j < nlist_temp; j++)
                           piptr[j] = pialoc[j];
                        ppblks_arr[i].ResizeAndSetAll (nlist_temp, 0, nz, 0, nz * b_2);
                        _Int *plist_new = ppblks_arr[i].GetListArr ();
                        _Int *pia_new = ppblks_arr[i].GetIaArr ();
                        _Int *pja_new = ppblks_arr[i].GetJaArr ();
                        _Flt *pa_new = ppblks_arr[i].GetAArr ();
                        for (j = 0; j < nlist_temp; j++)
                           plist_new[j] = plist[j];
                        for (j = 0; j <= nlist_temp; j++)
                           pia_new[j] = pialoc[j];
                        for (j = 0; j < nz; j++) {
                           jj = (int) pprowsarr[j];
                           indj = pindarr[jj];
                           k = piptr[indj];
                           pja_new[k] = ppcolsarr[j];
                           CVector < _Flt >::CopyVector (b_2, ppelemsarr + j * b_2,
                                                         pa_new + k * b_2);
                           piptr[indj]++;
                        }
                     }
                  }
               }

               {

                  int nzblk_tot = 0;

                  int i, j;

                  for (i = 0; i < niblk; i++)
                     nzblk_tot += pnzblk_arr[i];

                  _hmatr_arr_fin[ihblk].ResizeASub (nzblk_tot);
                  _hmatr_arr_fin[ihblk].SetNzblk (nzblk_tot);

                  CMatrix < int, float >*pHMatrStr_fin =
                     _hmatr_arr_fin[ihblk].GetHMatrStr ();
                  CMatrix < _Int, _Flt > *pASub_fin = _hmatr_arr_fin[ihblk].GetASubArr ();

                  pHMatrStr_fin->ResizeAndSetAllSp (niblk, niblk, nzblk_tot, nzblk_tot);

                  int *plist_fin = pHMatrStr_fin->GetListArr ();
                  int *plist2_fin = pHMatrStr_fin->GetList2Arr ();
                  int *pia_fin = pHMatrStr_fin->GetIaArr ();
                  int *pja_fin = pHMatrStr_fin->GetJaArr ();
                  int *pja2_fin = pHMatrStr_fin->GetJa2Arr ();

                  for (i = 0; i < niblk; i++)
                     plist_fin[i] = i;
                  for (i = 0; i < niblk; i++)
                     plist2_fin[i] = ihblk;

                  pia_fin[0] = 0;

                  nzblk_tot = 0;

                  for (i = 0; i < niblk; i++) {
                     int *pplist2blk_arr = plist2blk_arr[i].Ptr ();
                     CMatrix < _Int, _Flt > *ppblks_arr = pblks_arr[i].Ptr ();
                     for (j = 0; j < pnzblk_arr[i]; j++) {
                        pja_fin[nzblk_tot] = pplist2blk_arr[j * 2];
                        pja2_fin[nzblk_tot] = pplist2blk_arr[j * 2 + 1];
                        pASub_fin[nzblk_tot].ReplaceFree (ppblks_arr[j]);
                        nzblk_tot++;
                     }
                     pia_fin[i + 1] = nzblk_tot;
                  }
               }

               phblk_rows[ihblk].Clean ();

            }
         }

      }

   }

// Compute the packed size
//========================================================================================
   template < typename _Int, typename _Flt > long long CBMatrix < _Int,
      _Flt >::GetPackedSize () const
   {

      long long length = sizeof (int);

        length += (this->nzblk + 2) * sizeof (long long);

        length += this->hmatr_str.GetPackedSize ();

      if (this->nzblk > 0)
      {

         const CMatrix < _Int, _Flt > *pABlocks = &(this->asub_arr[0]);

         int i;

         for (i = 0; i < this->nzblk; i++)
         {
            length += pABlocks[i].GetPackedSize ();
         }

      }

      return length;

   }

// Fill by packed data
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::FillPacked (long long _length, char *_obj) const
   {

      char *pLoc;

        pLoc = _obj;

      int *pHead;
      long long *pibsblk;

        pHead = (int *) pLoc;
        pLoc += sizeof (int);

        pibsblk = (long long *) pLoc;
        pLoc += (this->nzblk + 2) * sizeof (long long);

      int sizeloc = this->hmatr_str.GetPackedSize ();

        pibsblk[0] = pLoc - _obj;
        pLoc += sizeloc;

        pibsblk[1] = pLoc - _obj;

      int i;

      if (this->nzblk > 0)
      {

         const CMatrix < _Int, _Flt > *pABlocks = &(this->asub_arr[0]);

         for (i = 0; i < this->nzblk; i++)
         {

            sizeloc = pABlocks[i].GetPackedSize ();

            pibsblk[i + 1] = pLoc - _obj;
            pLoc += sizeloc;

         }

         pibsblk[this->nzblk + 1] = pLoc - _obj;

      }

      pHead[0] = nzblk;

      if (pLoc - _obj != _length) {
         throw " CBMatrix<_Int,_Flt>::FillPacked: incorrect length on entry ";
      }
// Pack sparsity block

      sizeloc = (int) (pibsblk[1] - pibsblk[0]);

      this->hmatr_str.FillPacked (sizeloc, _obj + pibsblk[0]);

// Pack blocks

      if (this->nzblk > 0) {

         const CMatrix < _Int, _Flt > *pABlocks = &(this->asub_arr[0]);

         for (i = 0; i < this->nzblk; i++) {
            sizeloc = (int) (pibsblk[i + 2] - pibsblk[i + 1]);
            pABlocks[i].FillPacked (sizeloc, _obj + pibsblk[i + 1]);
         }

      }

   }

// Fill by packed data
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::FillPacked_thr (long long _length, char *_obj) const
   {

      char *pLoc;

        pLoc = _obj;

      int *pHead;
      long long *pibsblk;

        pHead = (int *) pLoc;
        pLoc += sizeof (int);

        pibsblk = (long long *) pLoc;
        pLoc += (this->nzblk + 2) * sizeof (long long);

      int sizeloc = this->hmatr_str.GetPackedSize ();

        pibsblk[0] = pLoc - _obj;
        pLoc += sizeloc;

        pibsblk[1] = pLoc - _obj;

      int i;

      if (this->nzblk > 0)
      {

         const CMatrix < _Int, _Flt > *pABlocks = &(this->asub_arr[0]);

         for (i = 0; i < this->nzblk; i++)
         {

            sizeloc = pABlocks[i].GetPackedSize ();

            pibsblk[i + 1] = pLoc - _obj;
            pLoc += sizeloc;

         }

         pibsblk[this->nzblk + 1] = pLoc - _obj;

      }

      pHead[0] = nzblk;

      if (pLoc - _obj != _length) {
         throw " CBMatrix<_Int,_Flt>::FillPacked: incorrect length on entry ";
      }
// Pack sparsity block

      sizeloc = (int) (pibsblk[1] - pibsblk[0]);

      this->hmatr_str.FillPacked (sizeloc, _obj + pibsblk[0]);

// Pack blocks

      if (this->nzblk > 0) {

         const CMatrix < _Int, _Flt > *pABlocks = &(this->asub_arr[0]);

#ifdef USE_THREADS
#pragma omp parallel for
#endif
         for (int ipar = 0; ipar < this->nzblk; ipar++) {
            int sizeloc = (int) (pibsblk[ipar + 2] - pibsblk[ipar + 1]);
            pABlocks[ipar].FillPacked (sizeloc, _obj + pibsblk[ipar + 1]);
         }

      }

   }

// Fill by packed data
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::UnPack (long long _length, char *_obj)
   {

// Get head data

      char *pLoc;

      pLoc = _obj;

      int *pHead;

      pHead = (int *) pLoc;
      pLoc += sizeof (int);

      int nzblk_loc = pHead[0];

      long long *pibsblk;

      pibsblk = (long long *) pLoc;
      pLoc += (nzblk_loc + 2) * sizeof (long long);

      this->nzblk = nzblk_loc;

// Unpack sparsity

      int sizeloc = (int) (pibsblk[1] - pibsblk[0]);

      this->hmatr_str.UnPack (sizeloc, pLoc);

      pLoc += sizeloc;

// Pack blocks

      this->asub_arr.resize (nzblk_loc + 1);

      CMatrix < _Int, _Flt > *pABlocks = &(this->asub_arr[0]);

      int i;

      for (i = 0; i < nzblk; i++) {

         sizeloc = (int) (pibsblk[i + 2] - pibsblk[i + 1]);
         pABlocks[i].UnPack (sizeloc, pLoc);
         pLoc += sizeloc;

      }

   }

// Fill by packed data
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::UnPack_thr (long long _length, char *_obj)
   {

// Get head data

      char *pLoc;

      pLoc = _obj;

      int *pHead;

      pHead = (int *) pLoc;
      pLoc += sizeof (int);

      int nzblk_loc = pHead[0];

      long long *pibsblk;

      pibsblk = (long long *) pLoc;
      pLoc += (nzblk_loc + 2) * sizeof (long long);

      this->nzblk = nzblk_loc;

// Unpack sparsity

      int sizeloc = (int) (pibsblk[1] - pibsblk[0]);

      this->hmatr_str.UnPack (sizeloc, pLoc);

      pLoc += sizeloc;

// Pack blocks

      this->asub_arr.resize (nzblk_loc + 1);

      CMatrix < _Int, _Flt > *pABlocks = &(this->asub_arr[0]);

#ifdef USE_THREADS
#pragma omp parallel for
#endif
      for (int ipar = 0; ipar < nzblk; ipar++) {

         char *pLoc = _obj + pibsblk[ipar + 1];
         int sizeloc = (int) (pibsblk[ipar + 2] - pibsblk[ipar + 1]);
         pABlocks[ipar].UnPack (sizeloc, pLoc);

      }

   }

// Filter the extended lists for backward only extention
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::FilterListsBack (int _myid, int _nblks, int *_blk2cpu, int *_nlist_ext_arr,
                               vector < int >*_list_ext_arr)
   {

      int iblk, i, jj, jj2;

      for (iblk = 0; iblk < _nblks; iblk++) {
         if (_blk2cpu[iblk] == _myid) {
            int *plist_ext = &(_list_ext_arr[iblk][0]);
            vector < int >list_flt (2 * _nlist_ext_arr[iblk] + 1);
            int *plist_flt = &list_flt[0];
            int nlistflt = 0;
            for (i = 0; i < _nlist_ext_arr[iblk]; i++) {
               jj = plist_ext[2 * i];
               jj2 = plist_ext[2 * i + 1];
               if (jj2 < iblk) {
                  plist_flt[nlistflt * 2] = jj;
                  plist_flt[nlistflt * 2 + 1] = jj2;
                  nlistflt++;
               }
            }
            _nlist_ext_arr[iblk] = nlistflt;
            _list_ext_arr[iblk].swap (list_flt);
         }
      }

   }

//
// Filter the extended lists for backward only extention
//========================================================================================
   template < typename _TInt, typename _TFloat > void CBMatrix < _TInt,
      _TFloat >::FilterListsBack (int _myid, int _nhblks, int *_hblk2cpu, int *_blk2hblks,
                                  int *_nlist_ext_arr, std::vector < int >*_list_ext_arr)
   {

      int ihblk, i, jj, jj2, jhblk;

      for (ihblk = 0; ihblk < _nhblks; ihblk++) {
         if (_hblk2cpu[ihblk] == _myid) {
            int *plist_ext = NULL;
            if (_nlist_ext_arr[ihblk] > 0)
               plist_ext = &(_list_ext_arr[ihblk][0]);
            std::vector < int >list_flt (2 * _nlist_ext_arr[ihblk] + 1);
            int *plist_flt = &list_flt[0];
            int nlistflt = 0;
            for (i = 0; i < _nlist_ext_arr[ihblk]; i++) {
               jj = plist_ext[2 * i];
               jj2 = plist_ext[2 * i + 1];
               jhblk = _blk2hblks[jj2];
               if (jhblk < ihblk) {
                  plist_flt[nlistflt * 2] = jj;
                  plist_flt[nlistflt * 2 + 1] = jj2;
                  nlistflt++;
               }
            }
            _nlist_ext_arr[ihblk] = nlistflt;
            _list_ext_arr[ihblk].swap (list_flt);
         }
      }

   }

// Compute Ja2 array by binary search
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::ComputeJa2 (int _nblks, long long *_blks, int _nlist, const _Int * _ia,
                          const _Int * _ja, _Int * _ja2)
   {
      int nzja = (int) _ia[_nlist];

      int i;
      int iblk, iblkprev;
      long long jj;

      iblkprev = -1;

      for (i = 0; i < nzja; i++) {
         jj = _ja[i];
         if (iblkprev >= 0 && iblkprev < _nblks) {
            if (jj >= _blks[iblkprev] && jj < _blks[iblkprev + 1]) {
               iblk = iblkprev;
            } else {
               iblk = BinarySearch (jj, _nblks, _blks, iblkprev);
            }
         } else {
            iblk = BinarySearch (jj, _nblks, _blks, iblkprev);
         }

         _ja2[i] = iblk;
         iblkprev = iblk;

      }
   }

/// @brief Split structural matrix into the set of matrices
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::SplitMatrSpIntoHMatrSp (int _nblks, long long *_blks, const CMatrix < _Int,
                                      _Flt > &_amatr, CBMatrix < _Int, _Flt > &_ahmatr)
   {

// Open sparsity

      const int nlistloc_ablk = _amatr.GetNlist ();
      const int nzjaloc_ablk = _amatr.GetNzja ();
      const _Int *pialoc_ablk = _amatr.GetIaArr ();
      const _Int *pjaloc_ablk = _amatr.GetJaArr ();

      if (nlistloc_ablk != _blks[_nblks])
         throw " CBMatrix<_Int,_Flt>::SplitMatrSpIntoHMatrSp: incorrect matrix on entry ";

// Compute block indices

      vector < _Int > ja2loc (nzjaloc_ablk + 1);

      _Int *pja2loc = &ja2loc[0];

      CBMatrix < _Int, _Flt >::ComputeJa2 (_nblks, _blks, nlistloc_ablk, pialoc_ablk,
                                           pjaloc_ablk, pja2loc);

// Compute block sparsity

      vector < int >imaskblk (_nblks);
      vector < int >listblk (_nblks);

      int *pimaskblk = imaskblk.data ();
      int *plistblk = listblk.data ();

      int i;

      for (i = 0; i < _nblks; i++)
         pimaskblk[i] = -1;

      int icycle = -1;

      vector < int >ia_blk (_nblks + 1);

      int *pia_blk = &ia_blk[0];

      for (i = 0; i <= _nblks; i++)
         pia_blk[i] = 0;

      int ihblk, nlistloc, j, jhblk;

      for (ihblk = 0; ihblk < _nblks; ihblk++) {
         icycle++;
         nlistloc = 0;
         for (i = (int) _blks[ihblk]; i < _blks[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jhblk = (int) pja2loc[j];
               if (pimaskblk[jhblk] != icycle) {
                  nlistloc++;
                  pimaskblk[jhblk] = icycle;
               }
            }
         }
         pia_blk[ihblk + 1] = nlistloc;
      }

      for (i = 0; i < _nblks; i++)
         pia_blk[i + 1] = pia_blk[i] + pia_blk[i + 1];

      int nzjablk = pia_blk[_nblks];

      vector < int >ja_blk (nzjablk + 1);

      int *pja_blk = &ja_blk[0];

      int ibeg;

      for (ihblk = 0; ihblk < _nblks; ihblk++) {
         icycle++;
         nlistloc = 0;
         for (i = (int) _blks[ihblk]; i < _blks[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jhblk = (int) pja2loc[j];
               if (pimaskblk[jhblk] != icycle) {
                  plistblk[nlistloc] = jhblk;
                  nlistloc++;
                  pimaskblk[jhblk] = icycle;
               }
            }
         }
         sort (plistblk, plistblk + nlistloc);
         ibeg = pia_blk[ihblk];
         for (i = 0; i < nlistloc; i++)
            pja_blk[ibeg + i] = plistblk[i];
      }

// Count numbers of elements in each block

      vector < int >nz_blk (nzjablk + 1);

      int *pnz_blk = &nz_blk[0];

      for (i = 0; i < nzjablk; i++)
         pnz_blk[i] = 0;

      int ind;

      for (ihblk = 0; ihblk < _nblks; ihblk++) {
         for (i = pia_blk[ihblk]; i < pia_blk[ihblk + 1]; i++) {
            jhblk = pja_blk[i];
            plistblk[jhblk] = i;
         }
         for (i = (int) _blks[ihblk]; i < _blks[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jhblk = (int) pja2loc[j];
               ind = plistblk[jhblk];
               pnz_blk[ind]++;
            }
         }
      }

// Rewrite data block by block

      vector < int >iptr (nzjablk + 1);
      vector < vector < _Int > >iindarr (nzjablk + 1);
      vector < vector < _Int > >jindarr (nzjablk + 1);
      vector < vector < _Int > >j2indarr (nzjablk + 1);

      int *piptr = &iptr[0];
      vector < _Int > *piindarr = &iindarr[0];
      vector < _Int > *pjindarr = &jindarr[0];

      for (i = 0; i < nzjablk; i++)
         piptr[i] = 0;

      int nzjmax = 0;

      for (i = 0; i < nzjablk; i++) {
         piindarr[i].resize (pnz_blk[i] + 1);
         pjindarr[i].resize (pnz_blk[i] + 1);
         if (pnz_blk[i] > nzjmax)
            nzjmax = pnz_blk[i];
      }

      vector < CSortInt > iiarr (nzjmax + 1);

      CSortInt *piiarr = &iiarr[0];

      _ahmatr.ResizeASub (nzjablk);
      _ahmatr.SetNzblk (nzjablk);

      CMatrix < _Int, _Flt > *pABlocks = _ahmatr.GetASubArr ();

      int jj, k, iloc, jloc, niloc;

      for (ihblk = 0; ihblk < _nblks; ihblk++) {
         for (i = pia_blk[ihblk]; i < pia_blk[ihblk + 1]; i++) {
            jhblk = pja_blk[i];
            plistblk[jhblk] = i;
         }
         for (i = (int) _blks[ihblk]; i < _blks[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jj = (int) pjaloc_ablk[j];
               jhblk = (int) pja2loc[j];
               ind = plistblk[jhblk];
               iloc = i - (int) _blks[ihblk];
               jloc = jj - (int) _blks[jhblk];
               k = piptr[ind];
               _Int *ppiindarr = &(piindarr[ind][0]);
               _Int *ppjindarr = &(pjindarr[ind][0]);
               ppiindarr[k] = (_Int) iloc;
               ppjindarr[k] = (_Int) jloc;
               piptr[ind]++;
            }
         }
         for (i = pia_blk[ihblk]; i < pia_blk[ihblk + 1]; i++) {
            jhblk = pja_blk[i];
            _Int *ppiindarr = &(piindarr[i][0]);
            _Int *ppjindarr = &(pjindarr[i][0]);
            for (k = 0; k < pnz_blk[i]; k++) {
               piiarr[k].ival = (int) ppiindarr[k];
               piiarr[k].i2val = k;
            }
            sort (piiarr, piiarr + pnz_blk[i]);
            int nlistloc = 0;
            int irow_prev = -1;
            for (k = 0; k < pnz_blk[i]; k++) {
               if (piiarr[k].ival != irow_prev) {
                  irow_prev = piiarr[k].ival;
                  nlistloc++;
               }
            }

            CMatrix < _Int, _Flt > ablk;
            ablk.ResizeAndSetAllSp (nlistloc, 0, pnz_blk[i], 0);

            _Int *plist_loc = ablk.GetListArr ();
            _Int *pia_loc = ablk.GetIaArr ();
            _Int *pja_loc = ablk.GetJaArr ();

            irow_prev = -1;

            pia_loc[0] = 0;

            nlistloc = 0;

            for (k = 0; k < pnz_blk[i]; k++) {
               if (piiarr[k].ival != irow_prev) {
                  irow_prev = piiarr[k].ival;
                  plist_loc[nlistloc] = (_Int) irow_prev;
                  nlistloc++;
               }
               pia_loc[nlistloc] = (_Int) (k + 1);
            }
            for (k = 0; k < pnz_blk[i]; k++) {
               pja_loc[k] = ppjindarr[piiarr[k].i2val];
            }
            for (k = 0; k < nlistloc; k++) {
               ibeg = (int) pia_loc[k];
               niloc = (int) (pia_loc[k + 1] - pia_loc[k]);
               sort (pja_loc + ibeg, pja_loc + ibeg + niloc);
            }

            pABlocks[i].ReplaceFree (ablk);

         }
      }

      CMatrix < int, float >*pAHBlkStr = _ahmatr.GetHMatrStr ();

      pAHBlkStr->ResizeAndSetAllSp (_nblks, 0, nzjablk, 0);

      vector < int >*pia_HBlk = pAHBlkStr->GetIa ();
      vector < int >*pja_HBlk = pAHBlkStr->GetJa ();

      pia_HBlk->swap (ia_blk);
      pja_HBlk->swap (ja_blk);

      int *plist_blk = pAHBlkStr->GetListArr ();

      for (i = 0; i < _nblks; i++)
         plist_blk[i] = i;

   }

/// @brief Split matrix into the set of matrices
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::SplitMatrIntoHMatr (int _nblks, long long *_blks, const CMatrix < _Int,
                                  _Flt > &_amatr, CBMatrix < _Int, _Flt > &_ahmatr)
   {

// Open sparsity

      const int nlistloc_ablk = _amatr.GetNlist ();
      const int nzjaloc_ablk = _amatr.GetNzja ();
      const _Int *pialoc_ablk = _amatr.GetIaArr ();
      const _Int *pjaloc_ablk = _amatr.GetJaArr ();
      const _Flt *paloc_ablk = _amatr.GetAArr ();

      if (nlistloc_ablk != _blks[_nblks])
         throw " CBMatrix<_Int,_Flt>::SplitMatrIntoHMatr: incorrect matrix on entry ";

// Compute block indices

      vector < _Int > ja2loc (nzjaloc_ablk + 1);

      _Int *pja2loc = &ja2loc[0];

      CBMatrix < _Int, _Flt >::ComputeJa2 (_nblks, _blks, nlistloc_ablk, pialoc_ablk,
                                           pjaloc_ablk, pja2loc);

// Compute block sparsity

      vector < int >imaskblk (_nblks);
      vector < int >listblk (_nblks);

      int *pimaskblk = &imaskblk[0];
      int *plistblk = &listblk[0];

      int i;

      for (i = 0; i < _nblks; i++)
         pimaskblk[i] = -1;

      int icycle = -1;

      vector < int >ia_blk (_nblks + 1);

      int *pia_blk = &ia_blk[0];

      for (i = 0; i <= _nblks; i++)
         pia_blk[i] = 0;

      int ihblk, nlistloc, j, jhblk;

      for (ihblk = 0; ihblk < _nblks; ihblk++) {
         icycle++;
         nlistloc = 0;
         for (i = (int) _blks[ihblk]; i < _blks[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jhblk = (int) pja2loc[j];
               if (pimaskblk[jhblk] != icycle) {
                  nlistloc++;
                  pimaskblk[jhblk] = icycle;
               }
            }
         }
         pia_blk[ihblk + 1] = nlistloc;
      }

      for (i = 0; i < _nblks; i++)
         pia_blk[i + 1] = pia_blk[i] + pia_blk[i + 1];

      int nzjablk = pia_blk[_nblks];

      vector < int >ja_blk (nzjablk + 1);

      int *pja_blk = &ja_blk[0];

      int ibeg;

      for (ihblk = 0; ihblk < _nblks; ihblk++) {
         icycle++;
         nlistloc = 0;
         for (i = (int) _blks[ihblk]; i < _blks[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jhblk = (int) pja2loc[j];
               if (pimaskblk[jhblk] != icycle) {
                  plistblk[nlistloc] = jhblk;
                  nlistloc++;
                  pimaskblk[jhblk] = icycle;
               }
            }
         }
         sort (plistblk, plistblk + nlistloc);
         ibeg = pia_blk[ihblk];
         for (i = 0; i < nlistloc; i++)
            pja_blk[ibeg + i] = plistblk[i];
      }

// Count numbers of elements in each block

      vector < int >nz_blk (nzjablk + 1);

      int *pnz_blk = &nz_blk[0];

      for (i = 0; i < nzjablk; i++)
         pnz_blk[i] = 0;

      int ind;

      for (ihblk = 0; ihblk < _nblks; ihblk++) {
         for (i = pia_blk[ihblk]; i < pia_blk[ihblk + 1]; i++) {
            jhblk = pja_blk[i];
            plistblk[jhblk] = i;
         }
         for (i = (int) _blks[ihblk]; i < _blks[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jhblk = (int) pja2loc[j];
               ind = plistblk[jhblk];
               pnz_blk[ind]++;
            }
         }
      }

// Rewrite data block by block

      vector < int >iptr (nzjablk + 1);
      vector < vector < _Int > >iindarr (nzjablk + 1);
      vector < vector < _Int > >jindarr (nzjablk + 1);
      vector < vector < _Flt > >aindarr (nzjablk + 1);

      int *piptr = &iptr[0];
      vector < _Int > *piindarr = &iindarr[0];
      vector < _Int > *pjindarr = &jindarr[0];
      vector < _Flt > *paindarr = &aindarr[0];

      for (i = 0; i < nzjablk; i++)
         piptr[i] = 0;

      int nzjmax = 0;

      for (i = 0; i < nzjablk; i++) {
         piindarr[i].resize (pnz_blk[i] + 1);
         pjindarr[i].resize (pnz_blk[i] + 1);
         paindarr[i].resize (pnz_blk[i] + 1);
         if (pnz_blk[i] > nzjmax)
            nzjmax = pnz_blk[i];
      }

      vector < CSortInt > iiarr (nzjmax + 1);

      CSortInt *piiarr = &iiarr[0];

      _ahmatr.ResizeASub (nzjablk);
      _ahmatr.SetNzblk (nzjablk);

      CMatrix < _Int, _Flt > *pABlocks = _ahmatr.GetASubArr ();

      int jj, k, iloc, jloc, niloc;

      for (ihblk = 0; ihblk < _nblks; ihblk++) {
         for (i = pia_blk[ihblk]; i < pia_blk[ihblk + 1]; i++) {
            jhblk = pja_blk[i];
            plistblk[jhblk] = i;
         }
         for (i = (int) _blks[ihblk]; i < _blks[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jj = (int) pjaloc_ablk[j];
               jhblk = (int) pja2loc[j];
               ind = plistblk[jhblk];
               iloc = i - (int) _blks[ihblk];
               jloc = jj - (int) _blks[jhblk];
               k = piptr[ind];
               _Int *ppiindarr = &(piindarr[ind][0]);
               _Int *ppjindarr = &(pjindarr[ind][0]);
               _Flt *ppaindarr = &(paindarr[ind][0]);
               ppiindarr[k] = (_Int) iloc;
               ppjindarr[k] = (_Int) jloc;
               ppaindarr[k] = paloc_ablk[j];
               piptr[ind]++;
            }
         }
         for (i = pia_blk[ihblk]; i < pia_blk[ihblk + 1]; i++) {
            jhblk = pja_blk[i];
            _Int *ppiindarr = &(piindarr[i][0]);
            _Int *ppjindarr = &(pjindarr[i][0]);
            _Flt *ppaindarr = &(paindarr[i][0]);
            for (k = 0; k < pnz_blk[i]; k++) {
               piiarr[k].ival = (int) ppiindarr[k];
               piiarr[k].i2val = k;
            }
            sort (piiarr, piiarr + pnz_blk[i]);
            int nlistloc = 0;
            int irow_prev = -1;
            for (k = 0; k < pnz_blk[i]; k++) {
               if (piiarr[k].ival != irow_prev) {
                  irow_prev = piiarr[k].ival;
                  nlistloc++;
               }
            }

            CMatrix < _Int, _Flt > ablk;
            ablk.ResizeAndSetAll (nlistloc, 0, pnz_blk[i], 0, pnz_blk[i]);

            _Int *plist_loc = ablk.GetListArr ();
            _Int *pia_loc = ablk.GetIaArr ();
            _Int *pja_loc = ablk.GetJaArr ();
            _Flt *pa_loc = ablk.GetAArr ();

            irow_prev = -1;

            pia_loc[0] = 0;

            nlistloc = 0;

            for (k = 0; k < pnz_blk[i]; k++) {
               if (piiarr[k].ival != irow_prev) {
                  irow_prev = piiarr[k].ival;
                  plist_loc[nlistloc] = (_Int) irow_prev;
                  nlistloc++;
               }
               pia_loc[nlistloc] = (_Int) (k + 1);
            }
            for (k = 0; k < pnz_blk[i]; k++) {
               pja_loc[k] = ppjindarr[piiarr[k].i2val];
               pa_loc[k] = ppaindarr[piiarr[k].i2val];
            }
            int nimax = 0;
            for (k = 0; k < nlistloc; k++) {
               niloc = (int) (pia_loc[k + 1] - pia_loc[k]);
               if (niloc > nimax)
                  nimax = niloc;
            }

            CVectorData < CSortInt > iiarr (nimax);
            CVectorData < _Flt > elemsarr (nimax);

            CSortInt *piiarr = iiarr.Ptr ();
            _Flt *pelemsarr = elemsarr.Ptr ();

            int k1, kind;

            for (k = 0; k < nlistloc; k++) {
               ibeg = (int) pia_loc[k];
               niloc = (int) (pia_loc[k + 1] - pia_loc[k]);
               for (k1 = 0; k1 < niloc; k1++) {
                  piiarr[k1].ival = (int) pja_loc[ibeg + k1];
                  piiarr[k1].i2val = ibeg + k1;
               }
               sort (piiarr, piiarr + niloc);
               for (k1 = 0; k1 < niloc; k1++) {
                  pja_loc[ibeg + k1] = piiarr[k1].ival;
                  kind = piiarr[k1].i2val;
                  pelemsarr[k1] = pa_loc[kind];
               }
               for (k1 = 0; k1 < niloc; k1++) {
                  pa_loc[ibeg + k1] = pelemsarr[k1];
               }
            }

            pABlocks[i].ReplaceFree (ablk);

         }
      }

      CMatrix < int, float >*pAHBlkStr = _ahmatr.GetHMatrStr ();

      pAHBlkStr->ResizeAndSetAllSp (_nblks, _nblks, nzjablk, nzjablk);

      vector < int >*pia_HBlk = pAHBlkStr->GetIa ();
      vector < int >*pja_HBlk = pAHBlkStr->GetJa ();

      pia_HBlk->swap (ia_blk);
      pja_HBlk->swap (ja_blk);

      int *plist_blk = pAHBlkStr->GetListArr ();
      int *plist2_blk = pAHBlkStr->GetList2Arr ();
      int *pja2_blk = pAHBlkStr->GetJa2Arr ();

      for (i = 0; i < _nblks; i++) {
         plist_blk[i] = i;
         plist2_blk[i] = 0;
      }

      for (i = 0; i < nzjablk; i++) {
         pja2_blk[i] = 0;
      }

   }

/// @brief Split matrix into the set of matrices
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::SplitMatrIntoHMatr_BxB (int _blksize, int _nblks, long long *_blks,
                                      const CMatrix < _Int, _Flt > &_amatr,
                                      CBMatrix < _Int, _Flt > &_ahmatr)
   {

      int b_2 = _blksize * _blksize;

// Open sparsity

      const int nlistloc_ablk = _amatr.GetNlist ();
      const int nzjaloc_ablk = _amatr.GetNzja ();
      const _Int *pialoc_ablk = _amatr.GetIaArr ();
      const _Int *pjaloc_ablk = _amatr.GetJaArr ();
      const _Flt *paloc_ablk = _amatr.GetAArr ();

      if (nlistloc_ablk != _blks[_nblks])
         throw " CBMatrix<_Int,_Flt>::SplitMatrIntoHMatr_BxB: incorrect matrix on entry ";

// Compute block indices

      vector < _Int > ja2loc (nzjaloc_ablk + 1);

      _Int *pja2loc = &ja2loc[0];

      CBMatrix < _Int, _Flt >::ComputeJa2 (_nblks, _blks, nlistloc_ablk, pialoc_ablk,
                                           pjaloc_ablk, pja2loc);

// Compute block sparsity

      vector < int >imaskblk (_nblks);
      vector < int >listblk (_nblks);

      int *pimaskblk = &imaskblk[0];
      int *plistblk = &listblk[0];

      int i;

      for (i = 0; i < _nblks; i++)
         pimaskblk[i] = -1;

      int icycle = -1;

      vector < int >ia_blk (_nblks + 1);

      int *pia_blk = &ia_blk[0];

      for (i = 0; i <= _nblks; i++)
         pia_blk[i] = 0;

      int ihblk, nlistloc, j, jhblk;

      for (ihblk = 0; ihblk < _nblks; ihblk++) {
         icycle++;
         nlistloc = 0;
         for (i = (int) _blks[ihblk]; i < _blks[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jhblk = (int) pja2loc[j];
               if (pimaskblk[jhblk] != icycle) {
                  nlistloc++;
                  pimaskblk[jhblk] = icycle;
               }
            }
         }
         pia_blk[ihblk + 1] = nlistloc;
      }

      for (i = 0; i < _nblks; i++)
         pia_blk[i + 1] = pia_blk[i] + pia_blk[i + 1];

      int nzjablk = pia_blk[_nblks];

      vector < int >ja_blk (nzjablk + 1);

      int *pja_blk = &ja_blk[0];

      int ibeg;

      for (ihblk = 0; ihblk < _nblks; ihblk++) {
         icycle++;
         nlistloc = 0;
         for (i = (int) _blks[ihblk]; i < _blks[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jhblk = (int) pja2loc[j];
               if (pimaskblk[jhblk] != icycle) {
                  plistblk[nlistloc] = jhblk;
                  nlistloc++;
                  pimaskblk[jhblk] = icycle;
               }
            }
         }
         sort (plistblk, plistblk + nlistloc);
         ibeg = pia_blk[ihblk];
         for (i = 0; i < nlistloc; i++)
            pja_blk[ibeg + i] = plistblk[i];
      }

// Count numbers of elements in each block

      vector < int >nz_blk (nzjablk + 1);

      int *pnz_blk = &nz_blk[0];

      for (i = 0; i < nzjablk; i++)
         pnz_blk[i] = 0;

      int ind;

      for (ihblk = 0; ihblk < _nblks; ihblk++) {
         for (i = pia_blk[ihblk]; i < pia_blk[ihblk + 1]; i++) {
            jhblk = pja_blk[i];
            plistblk[jhblk] = i;
         }
         for (i = (int) _blks[ihblk]; i < _blks[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jhblk = (int) pja2loc[j];
               ind = plistblk[jhblk];
               pnz_blk[ind]++;
            }
         }
      }

// Rewrite data block by block

      vector < int >iptr (nzjablk + 1);
      vector < vector < _Int > >iindarr (nzjablk + 1);
      vector < vector < _Int > >jindarr (nzjablk + 1);
      vector < vector < _Flt > >aindarr (nzjablk + 1);

      int *piptr = iptr.data ();
      vector < _Int > *piindarr = iindarr.data ();
      vector < _Int > *pjindarr = jindarr.data ();
      vector < _Flt > *paindarr = aindarr.data ();

      for (i = 0; i < nzjablk; i++)
         piptr[i] = 0;

      int nzjmax = 0;

      for (i = 0; i < nzjablk; i++) {
         piindarr[i].resize (pnz_blk[i] + 1);
         pjindarr[i].resize (pnz_blk[i] + 1);
         paindarr[i].resize (pnz_blk[i] * b_2 + 1);
         if (pnz_blk[i] > nzjmax)
            nzjmax = pnz_blk[i];
      }

      vector < CSortInt > iiarr (nzjmax + 1);

      CSortInt *piiarr = &iiarr[0];

      _ahmatr.ResizeASub (nzjablk);
      _ahmatr.SetNzblk (nzjablk);

      CMatrix < _Int, _Flt > *pABlocks = _ahmatr.GetASubArr ();

      int jj, k, iloc, jloc, niloc;

      for (ihblk = 0; ihblk < _nblks; ihblk++) {
         for (i = pia_blk[ihblk]; i < pia_blk[ihblk + 1]; i++) {
            jhblk = pja_blk[i];
            plistblk[jhblk] = i;
         }
         for (i = (int) _blks[ihblk]; i < _blks[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jj = (int) pjaloc_ablk[j];
               jhblk = (int) pja2loc[j];
               ind = plistblk[jhblk];
               iloc = i - (int) _blks[ihblk];
               jloc = jj - (int) _blks[jhblk];
               k = piptr[ind];
               _Int *ppiindarr = piindarr[ind].data ();
               _Int *ppjindarr = pjindarr[ind].data ();
               _Flt *ppaindarr = paindarr[ind].data ();
               ppiindarr[k] = (_Int) iloc;
               ppjindarr[k] = (_Int) jloc;
               CVector < _Flt >::CopyVector (b_2, paloc_ablk + j * b_2,
                                             ppaindarr + k * b_2);
               piptr[ind]++;
            }
         }
         for (i = pia_blk[ihblk]; i < pia_blk[ihblk + 1]; i++) {
            jhblk = pja_blk[i];
            _Int *ppiindarr = piindarr[i].data ();
            _Int *ppjindarr = pjindarr[i].data ();
            _Flt *ppaindarr = paindarr[i].data ();
            for (k = 0; k < pnz_blk[i]; k++) {
               piiarr[k].ival = (int) ppiindarr[k];
               piiarr[k].i2val = k;
            }
            sort (piiarr, piiarr + pnz_blk[i]);
            int nlistloc = 0;
            int irow_prev = -1;
            for (k = 0; k < pnz_blk[i]; k++) {
               if (piiarr[k].ival != irow_prev) {
                  irow_prev = piiarr[k].ival;
                  nlistloc++;
               }
            }

            CMatrix < _Int, _Flt > ablk;
            ablk.ResizeAndSetAll (nlistloc, 0, pnz_blk[i], 0, pnz_blk[i] * b_2);

            _Int *plist_loc = ablk.GetListArr ();
            _Int *pia_loc = ablk.GetIaArr ();
            _Int *pja_loc = ablk.GetJaArr ();
            _Flt *pa_loc = ablk.GetAArr ();

            irow_prev = -1;

            pia_loc[0] = 0;

            nlistloc = 0;

            for (k = 0; k < pnz_blk[i]; k++) {
               if (piiarr[k].ival != irow_prev) {
                  irow_prev = piiarr[k].ival;
                  plist_loc[nlistloc] = (_Int) irow_prev;
                  nlistloc++;
               }
               pia_loc[nlistloc] = (_Int) (k + 1);
            }
            for (k = 0; k < pnz_blk[i]; k++) {
               pja_loc[k] = ppjindarr[piiarr[k].i2val];
               CVector < _Flt >::CopyVector (b_2, ppaindarr + piiarr[k].i2val * b_2,
                                             pa_loc + k * b_2);
            }
            int nimax = 0;
            for (k = 0; k < nlistloc; k++) {
               niloc = (int) (pia_loc[k + 1] - pia_loc[k]);
               if (niloc > nimax)
                  nimax = niloc;
            }

            CVectorData < CSortInt > iiarr (nimax);
            CVectorData < _Flt > elemsarr (nimax * b_2);

            CSortInt *piiarr = iiarr.Ptr ();
            _Flt *pelemsarr = elemsarr.Ptr ();

            int k1, kind;

            for (k = 0; k < nlistloc; k++) {
               ibeg = (int) pia_loc[k];
               niloc = (int) (pia_loc[k + 1] - pia_loc[k]);
               for (k1 = 0; k1 < niloc; k1++) {
                  piiarr[k1].ival = (int) pja_loc[ibeg + k1];
                  piiarr[k1].i2val = ibeg + k1;
               }
               sort (piiarr, piiarr + niloc);
               for (k1 = 0; k1 < niloc; k1++) {
                  pja_loc[ibeg + k1] = piiarr[k1].ival;
                  kind = piiarr[k1].i2val;
                  CVector < _Flt >::CopyVector (b_2, pa_loc + kind * b_2,
                                                pelemsarr + k1 * b_2);
               }
               for (k1 = 0; k1 < niloc; k1++) {
                  CVector < _Flt >::CopyVector (b_2, pelemsarr + k1 * b_2,
                                                pa_loc + (ibeg + k1) * b_2);
               }
            }

            pABlocks[i].ReplaceFree (ablk);

         }
      }

      CMatrix < int, float >*pAHBlkStr = _ahmatr.GetHMatrStr ();

      pAHBlkStr->ResizeAndSetAllSp (_nblks, _nblks, nzjablk, nzjablk);

      vector < int >*pia_HBlk = pAHBlkStr->GetIa ();
      vector < int >*pja_HBlk = pAHBlkStr->GetJa ();

      pia_HBlk->swap (ia_blk);
      pja_HBlk->swap (ja_blk);

      int *plist_blk = pAHBlkStr->GetListArr ();
      int *plist2_blk = pAHBlkStr->GetList2Arr ();
      int *pja2_blk = pAHBlkStr->GetJa2Arr ();

      for (i = 0; i < _nblks; i++) {
         plist_blk[i] = i;
         plist2_blk[i] = 0;
      }

      for (i = 0; i < nzjablk; i++) {
         pja2_blk[i] = 0;
      }

   }

/// @brief Combine hmatrix into matrix
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::CombineHMatrIntoMatrSp (bool _b_is_char, int _nblks, long long *_blks,
                                      CMatrix < _Int, _Flt > &_amatr) const
   {

// Open hmatrix

      const CMatrix < int, float >*pAHMatr = this->GetHMatrStr ();
      const CMatrix < _Int, _Flt > *pASub = this->GetASubArr ();

      const int *pia_hmatr = pAHMatr->GetIaArr ();
      const int *pja_hmatr = pAHMatr->GetJaArr ();

      int nzja_hmatr = pia_hmatr[_nblks];

// Count matrix size

      int ntot = (int) _blks[_nblks];
      int nzja_tot = 0;

      int i;

      for (i = 0; i < nzja_hmatr; i++)
           nzja_tot += pASub[i].GetNzja ();

        _amatr.ResizeAndSetAllSp (ntot, 0, nzja_tot, 0);
      if (_b_is_char)
      {
         _amatr.ResizeJaChar (nzja_tot);
      }

      _Int *plist_tot = _amatr.GetListArr ();
      _Int *pia_tot = _amatr.GetIaArr ();
      _Int *pja_tot = _amatr.GetJaArr ();
      char *pjachar_tot = _amatr.GetJaCharArr ();

      for (i = 0; i < ntot; i++)
         plist_tot[i] = i;
      for (i = 0; i <= ntot; i++)
         pia_tot[i] = 0;

      int iblk, jblk, j, ibeg, jbeg, k, kk;

      for (iblk = 0; iblk < _nblks; iblk++) {
         ibeg = (int) _blks[iblk];
         for (j = pia_hmatr[iblk]; j < pia_hmatr[iblk + 1]; j++) {
            jblk = pja_hmatr[j];
            jbeg = (int) _blks[jblk];
            int nlist_temp = pASub[j].GetNlist ();
            const _Int *plist_temp = pASub[j].GetListArr ();
            const _Int *pia_temp = pASub[j].GetIaArr ();
            for (k = 0; k < nlist_temp; k++) {
               kk = (int) plist_temp[k];
               pia_tot[ibeg + kk + 1] += (pia_temp[k + 1] - pia_temp[k]);
            }
         }
      }

      for (i = 0; i < ntot; i++)
         pia_tot[i + 1] += pia_tot[i];

      CVectorData < int >iptr (ntot);
      int *piptr = iptr.Ptr ();

      for (i = 0; i < ntot; i++)
         piptr[i] = (int) pia_tot[i];

      int kkk, kj;

      for (iblk = 0; iblk < _nblks; iblk++) {
         ibeg = (int) _blks[iblk];
         for (j = pia_hmatr[iblk]; j < pia_hmatr[iblk + 1]; j++) {
            jblk = pja_hmatr[j];
            jbeg = (int) _blks[jblk];
            int nlist_temp = pASub[j].GetNlist ();
            const _Int *plist_temp = pASub[j].GetListArr ();
            const _Int *pia_temp = pASub[j].GetIaArr ();
            const _Int *pja_temp = pASub[j].GetJaArr ();
            const char *pjachar_temp = pASub[j].GetJaCharArr ();
            for (k = 0; k < nlist_temp; k++) {
               kk = (int) plist_temp[k];
               kkk = piptr[ibeg + kk];
               for (kj = (int) pia_temp[k]; kj < pia_temp[k + 1]; kj++) {
                  pja_tot[kkk] = jbeg + pja_temp[kj];
                  if (_b_is_char) {
                     pjachar_tot[kkk] = pjachar_temp[kj];
                  }
                  kkk++;
               }
               piptr[ibeg + kk] = kkk;
            }
         }
      }

   }

/// @brief Split structural rectangular matrix into the set of matrices
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::SplitRectMatrSpIntoHMatrSp (int _nblksR, int *_blksR, int _nblksC,
                                          int *_blksC, const CMatrix < _Int,
                                          _Flt > &_amatr, CBMatrix < _Int,
                                          _Flt > &_ahmatr)
   {

// Open sparsity

      int nlistloc_ablk = _amatr.GetNlist ();
      int nzjaloc_ablk = _amatr.GetNzja ();
      const _Int *plistloc_ablk = _amatr.GetListArr ();
      const _Int *pialoc_ablk = _amatr.GetIaArr ();
      const _Int *pjaloc_ablk = _amatr.GetJaArr ();

      int ni_tot = _blksR[_nblksR];

      if (nlistloc_ablk > ni_tot)
         throw
            " CBMatrix < _Int, _Flt >::SplitRectMatrSpIntoHMatrSp: incorrect matrix on entry ";

      int i, jj;

      for (i = 0; i < nlistloc_ablk; i++) {
         jj = (int) plistloc_ablk[i];
         if (jj >= ni_tot)
            throw
               " CBMatrix < _Int, _Flt >::SplitRectMatrSpIntoHMatrSp: incorrect matrix on entry ";
      }

// Create reduced block row partitioning

      CVectorData < _Int > list2loc_ablk (nlistloc_ablk);

      _Int *plist2loc_ablk = list2loc_ablk.Ptr ();

      _Int ia1row[2];

      ia1row[0] = 0;
      ia1row[1] = (_Int) nlistloc_ablk;

      CVectorData < long long >blksR_int64 (_nblksR + 1);

      long long *pblksR_int64 = blksR_int64.Ptr ();

      for (i = 0; i < _nblksR + 1; i++)
         pblksR_int64[i] = _blksR[i];

      CBMatrix < _Int, _Flt >::ComputeJa2 (_nblksR, pblksR_int64, 1, ia1row,
                                           plistloc_ablk, plist2loc_ablk);

      CVectorData < int >blks_list (_nblksR + 1);

      int *pblks_list = blks_list.Ptr ();

      for (i = 0; i <= _nblksR; i++)
         pblks_list[i] = 0;

      int jblk;

      for (i = 0; i < nlistloc_ablk; i++) {
         jblk = (int) plist2loc_ablk[i];
         pblks_list[jblk + 1]++;
      }

      for (i = 0; i < _nblksR; i++)
         pblks_list[i + 1] = pblks_list[i] + pblks_list[i + 1];

// Compute block column indices

      CVectorData < _Int > ja2loc (nzjaloc_ablk);

      _Int *pja2loc = ja2loc.Ptr ();

      CVectorData < long long >blksC_int64 (_nblksC + 1);

      long long *pblksC_int64 = blksC_int64.Ptr ();

      for (i = 0; i < _nblksC + 1; i++)
         pblksC_int64[i] = _blksC[i];

      CBMatrix < _Int, _Flt >::ComputeJa2 (_nblksC, pblksC_int64, nlistloc_ablk,
                                           pialoc_ablk, pjaloc_ablk, pja2loc);

// Compute block sparsity

      CVectorData < int >imaskblk (_nblksC);
      CVectorData < int >listblk (_nblksC);

      int *pimaskblk = imaskblk.Ptr ();
      int *plistblk = listblk.Ptr ();

      for (i = 0; i < _nblksC; i++)
         pimaskblk[i] = -1;

      int icycle = -1;

      vector < int >ia_blk (_nblksR + 1);

      int *pia_blk = &ia_blk[0];

      for (i = 0; i <= _nblksR; i++)
         pia_blk[i] = 0;

      int ihblk, nlistloc, j, jhblk;

      for (ihblk = 0; ihblk < _nblksR; ihblk++) {
         icycle++;
         nlistloc = 0;
         for (i = pblks_list[ihblk]; i < pblks_list[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jhblk = (int) pja2loc[j];
               if (pimaskblk[jhblk] != icycle) {
                  nlistloc++;
                  pimaskblk[jhblk] = icycle;
               }
            }
         }
         pia_blk[ihblk + 1] = nlistloc;
      }

      for (i = 0; i < _nblksR; i++)
         pia_blk[i + 1] = pia_blk[i] + pia_blk[i + 1];

      int nzjablk = pia_blk[_nblksR];

      vector < int >ja_blk (nzjablk);

      int *pja_blk = &ja_blk[0];

      int ibeg;

      for (ihblk = 0; ihblk < _nblksR; ihblk++) {
         icycle++;
         nlistloc = 0;
         for (i = pblks_list[ihblk]; i < pblks_list[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jhblk = (int) pja2loc[j];
               if (pimaskblk[jhblk] != icycle) {
                  plistblk[nlistloc] = jhblk;
                  nlistloc++;
                  pimaskblk[jhblk] = icycle;
               }
            }
         }
         sort (plistblk, plistblk + nlistloc);
         ibeg = pia_blk[ihblk];
         for (i = 0; i < nlistloc; i++)
            pja_blk[ibeg + i] = plistblk[i];
      }

// Count numbers of elements in each block

      CVectorData < int >nz_blk (nzjablk);

      int *pnz_blk = nz_blk.Ptr ();

      for (i = 0; i < nzjablk; i++)
         pnz_blk[i] = 0;

      int ind;

      for (ihblk = 0; ihblk < _nblksR; ihblk++) {
         for (i = pia_blk[ihblk]; i < pia_blk[ihblk + 1]; i++) {
            jhblk = pja_blk[i];
            plistblk[jhblk] = i;
         }
         for (i = pblks_list[ihblk]; i < pblks_list[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jhblk = (int) pja2loc[j];
               ind = plistblk[jhblk];
               pnz_blk[ind]++;
            }
         }
      }

// Rewrite data block by block

      CVectorData < int >iptr (nzjablk);
      CVectorData < CVectorData < _Int > >iindarr (nzjablk);
      CVectorData < CVectorData < _Int > >jindarr (nzjablk);
//   CVectorData<CVectorData<_Int> > j2indarr(nzjablk);

      int *piptr = iptr.Ptr ();
      CVectorData < _Int > *piindarr = iindarr.Ptr ();
      CVectorData < _Int > *pjindarr = jindarr.Ptr ();

      for (i = 0; i < nzjablk; i++)
         piptr[i] = 0;

      int nzjmax = 0;

      for (i = 0; i < nzjablk; i++) {
         piindarr[i].resize (pnz_blk[i]);
         pjindarr[i].resize (pnz_blk[i]);
         if (pnz_blk[i] > nzjmax)
            nzjmax = pnz_blk[i];
      }

      CVectorData < CSortInt > iiarr (nzjmax);

      CSortInt *piiarr = iiarr.Ptr ();

      _ahmatr.ResizeASub (nzjablk);
      _ahmatr.SetNzblk (nzjablk);

      CMatrix < _Int, _Flt > *pABlocks = _ahmatr.GetASubArr ();

      int k, iloc, jloc, niloc;

      for (ihblk = 0; ihblk < _nblksR; ihblk++) {
         for (i = pia_blk[ihblk]; i < pia_blk[ihblk + 1]; i++) {
            jhblk = pja_blk[i];
            plistblk[jhblk] = i;
         }
         for (i = pblks_list[ihblk]; i < pblks_list[ihblk + 1]; i++) {
            for (j = (int) pialoc_ablk[i]; j < pialoc_ablk[i + 1]; j++) {
               jj = (int) pjaloc_ablk[j];
               jhblk = (int) pja2loc[j];
               ind = plistblk[jhblk];
               iloc = (int) (plistloc_ablk[i] - _blksR[ihblk]);
               jloc = jj - _blksC[jhblk];
               k = piptr[ind];
               _Int *ppiindarr = piindarr[ind].Ptr ();
               _Int *ppjindarr = pjindarr[ind].Ptr ();
               ppiindarr[k] = (_Int) iloc;
               ppjindarr[k] = (_Int) jloc;
               piptr[ind]++;
            }
         }
         for (i = pia_blk[ihblk]; i < pia_blk[ihblk + 1]; i++) {
            jhblk = pja_blk[i];
            _Int *ppiindarr = piindarr[i].Ptr ();
            _Int *ppjindarr = pjindarr[i].Ptr ();
            for (k = 0; k < pnz_blk[i]; k++) {
               piiarr[k].ival = (int) ppiindarr[k];
               piiarr[k].i2val = k;
            }
            sort (piiarr, piiarr + pnz_blk[i]);
            int nlistloc = 0;
            int irow_prev = -1;
            for (k = 0; k < pnz_blk[i]; k++) {
               if (piiarr[k].ival != irow_prev) {
                  irow_prev = piiarr[k].ival;
                  nlistloc++;
               }
            }

            CMatrix < _Int, _Flt > ablk;

            ablk.ResizeAndSetAllSp (nlistloc, 0, pnz_blk[i], 0);

            _Int *plist_loc = ablk.GetListArr ();
            _Int *pia_loc = ablk.GetIaArr ();
            _Int *pja_loc = ablk.GetJaArr ();

            irow_prev = -1;

            pia_loc[0] = 0;

            nlistloc = 0;

            for (k = 0; k < pnz_blk[i]; k++) {
               if (piiarr[k].ival != irow_prev) {
                  irow_prev = piiarr[k].ival;
                  plist_loc[nlistloc] = (_Int) irow_prev;
                  nlistloc++;
               }
               pia_loc[nlistloc] = (_Int) (k + 1);
            }
            for (k = 0; k < pnz_blk[i]; k++) {
               pja_loc[k] = ppjindarr[piiarr[k].i2val];
            }
            for (k = 0; k < nlistloc; k++) {
               ibeg = (int) pia_loc[k];
               niloc = (int) (pia_loc[k + 1] - pia_loc[k]);
               sort (pja_loc + ibeg, pja_loc + ibeg + niloc);
            }

            pABlocks[i].ReplaceFree (ablk);

         }
      }

      CMatrix < int, float >*pAHBlkStr = _ahmatr.GetHMatrStr ();

      pAHBlkStr->ResizeAndSetAllSp (_nblksR, 0, nzjablk, 0);

      vector < int >*pia_set = pAHBlkStr->GetIa ();
      pia_set->swap (ia_blk);

      vector < int >*pja_set = pAHBlkStr->GetJa ();
      pja_set->swap (ja_blk);

//   pAHBlkStr->ReplaceIa (ia_blk);
//   pAHBlkStr->ReplaceJa (ja_blk);

      int *plist_blk = pAHBlkStr->GetListArr ();

      for (i = 0; i < _nblksR; i++)
         plist_blk[i] = i;

      pAHBlkStr->PackZeroRows ();

   }

// Print hmatrix data
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::PrintHMatrix (ofstream & _fout)
   {

      _fout << " CBMatrix:" << endl;

      _fout << "    HMatrStr:" << endl;

      CFct < int, float >::PrintMatrix (_fout, this->hmatr_str);

      _fout << "    Nzblk = " << this->nzblk << endl;

      _fout << "    ABlocks: " << endl;

      if (this->nzblk > 0) {

         int i;

         CMatrix < _Int, _Flt > *pABlocks = this->GetASubArr ();

         for (i = 0; i < this->nzblk; i++) {
            _fout << "       Iblk = " << i << endl;
            CFct < _Int, _Flt >::PrintMatrix (_fout, pABlocks[i]);
         }

      }

   }

// Print hmatrix data over thresh
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::PrintHMatrixThresh (ofstream & _fout, double _thresh)
   {

      _fout << " CBMatrix:" << endl;

      _fout << "    HMatrStr:" << endl;

      CFct < int, float >::PrintMatrix (_fout, this->hmatr_str);

      _fout << "    Nzblk = " << this->nzblk << endl;

      _fout << "    ABlocks: " << endl;

      if (this->nzblk > 0) {

         int i;

         CMatrix < _Int, _Flt > *pABlocks = this->GetASubArr ();

         for (i = 0; i < this->nzblk; i++) {
            _fout << "       Iblk = " << i << endl;
            CFct < _Int, _Flt >::PrintMatrixThresh (_fout, pABlocks[i], _thresh);
         }

      }

   }

// Print diag of hmatrix data
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::PrintHMatrixDiag (ofstream & _fout)
   {

      _fout << " CBMatrix:" << endl;

      _fout << "    HMatrStr:" << endl;

      CFct < int, float >::PrintMatrix (_fout, this->hmatr_str);

      int nlist_str = this->hmatr_str.GetNlist ();
      int *plist_str = this->hmatr_str.GetListArr ();
      int *plist2_str = this->hmatr_str.GetList2Arr ();
      int *pia_str = this->hmatr_str.GetIaArr ();
      int *pja_str = this->hmatr_str.GetJaArr ();
      int *pja2_str = this->hmatr_str.GetJa2Arr ();

      _fout << "    Nzblk = " << this->nzblk << endl;

      _fout << "    Diagonal ABlocks: " << endl;

      if (this->nzblk > 0) {

         int i, j, iblk, ihblk, jblk, jhblk;

         CMatrix < _Int, _Flt > *pABlocks = this->GetASubArr ();

         for (i = 0; i < nlist_str; i++) {
            iblk = plist_str[i];
            ihblk = plist2_str[i];
            for (j = pia_str[i]; j < pia_str[i + 1]; j++) {
               jblk = pja_str[j];
               jhblk = pja2_str[j];
               if (iblk == jblk && ihblk == jhblk) {
                  _fout << "       Iblk = " << iblk << " IHblk = " << ihblk << endl;
                  CFct < _Int, _Flt >::PrintMatrixDiag (_fout, pABlocks[j]);
               }
            }
         }

      }

   }

// Print diag of hmatrix data in pairs format
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::PrintHMatrixDiagPair (ofstream & _fout)
   {

      _fout << " CBMatrix:" << endl;

      _fout << "    HMatrStr:" << endl;

      CFct < int, float >::PrintMatrix (_fout, this->hmatr_str);

      int nlist_str = this->hmatr_str.GetNlist ();
      int *plist_str = this->hmatr_str.GetListArr ();
      int *plist2_str = this->hmatr_str.GetList2Arr ();
      int *pia_str = this->hmatr_str.GetIaArr ();
      int *pja_str = this->hmatr_str.GetJaArr ();
      int *pja2_str = this->hmatr_str.GetJa2Arr ();

      _fout << "    Nzblk = " << this->nzblk << endl;

      _fout << "    Diagonal ABlocks: " << endl;

      if (this->nzblk > 0) {

         int i, j, iblk, ihblk, jblk, jhblk;

         CMatrix < _Int, _Flt > *pABlocks = this->GetASubArr ();

         for (i = 0; i < nlist_str; i++) {
            iblk = plist_str[i];
            ihblk = plist2_str[i];
            for (j = pia_str[i]; j < pia_str[i + 1]; j++) {
               jblk = pja_str[j];
               jhblk = pja2_str[j];
               if (iblk == jblk && ihblk == jhblk) {
                  _fout << "       Iblk = " << iblk << " IHblk = " << ihblk << endl;
                  CFct < _Int, _Flt >::PrintMatrixDiagPair (_fout, pABlocks[j]);
               }
            }
         }

      }

   }

// Print sparsity with boxes that show nonzero blocks
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::Str2PsBox (int _collap, const CMatrix < _Int, _Flt > &_amatr,
                         const char *_fname, int _nblks, int *_blks)
   {

// Compute new blocks partitioning

      vector < int >blksnw (_nblks + 2);

      int *pblksnw = &blksnw[0];

      const int nsupmx = _amatr.GetNlist ();

      if (_nblks == 0) {
         pblksnw[0] = 0;
         pblksnw[1] = (nsupmx + _collap - 1) / _collap;
      } else {
         pblksnw[0] = 0;
         for (int iblk = 0; iblk < _nblks; iblk++) {
            int ni = _blks[iblk + 1] - _blks[iblk];
            int niloc = (ni + _collap - 1) / _collap;
            pblksnw[iblk + 1] = pblksnw[iblk] + niloc;
         }
      }

// Compute nd2sp and sp2nd arrays

      int nnew;

      if (_nblks == 0) {
         nnew = pblksnw[_nblks + 1];
      } else {
         nnew = pblksnw[_nblks];
      }

      vector < int >nd2sp (_amatr.GetNlist () + 1);
      vector < int >sp2nd (nnew + 1);

      int *pnd2sp = &nd2sp[0];
      int *psp2nd = &sp2nd[0];

      int i, j;

      if (_nblks == 0) {
         psp2nd[0] = 0;
         for (i = 0; i < nnew - 1; i++) {
            psp2nd[i + 1] = psp2nd[i] + _collap;
         }
         psp2nd[nnew] = nsupmx;
      } else {
         psp2nd[0] = 0;
         for (int iblk = 0; iblk < _nblks; iblk++) {
            for (i = pblksnw[iblk]; i < pblksnw[iblk + 1] - 1; i++) {
               psp2nd[i + 1] = psp2nd[i] + _collap;
            }
            psp2nd[pblksnw[iblk + 1]] = _blks[iblk + 1];
         }
      }

      for (i = 0; i < nnew; i++) {
         for (j = psp2nd[i]; j < psp2nd[i + 1]; j++) {
            pnd2sp[j] = i;
         }
      }

// Count the total number of elements in the collapsed matrix

      int isup, jsup, jj;

      int icycle = 0;

      vector < int >imask (nnew + 1);
      vector < int >lstloc (nnew + 1);

      int *pimask = &imask[0];
      int *plstloc = &lstloc[0];

      for (i = 0; i < nnew; i++)
         pimask[i] = icycle;

      int nz = 0;
      int nlstloc;

      const _Int *pia = _amatr.GetIaArr ();
      const _Int *pja = _amatr.GetJaArr ();

      for (isup = 0; isup < nnew; isup++) {
         icycle++;
         nlstloc = 0;
         for (i = psp2nd[isup]; i < psp2nd[isup + 1]; i++) {
            for (j = (int) pia[i]; j < pia[i + 1]; j++) {
               jj = (int) pja[j];
               jsup = pnd2sp[jj];
               if (pimask[jsup] != icycle) {
                  plstloc[nlstloc] = jsup;
                  pimask[jsup] = icycle;
                  nlstloc++;
               }
            }
         }
         nz += nlstloc;
      }

// Compute collapsed matrix

      CMatrix < int, float >temp;

      temp.ResizeAndSetAllSp (nnew, 0, nz, 0);

      int *plistt = temp.GetListArr ();
      int *piat = temp.GetIaArr ();
      int *pjat = temp.GetJaArr ();

      piat[0] = 0;
      for (isup = 0; isup < nnew; isup++) {
         icycle++;
         nlstloc = 0;
         for (i = psp2nd[isup]; i < psp2nd[isup + 1]; i++) {
            for (j = (int) pia[i]; j < pia[i + 1]; j++) {
               jj = (int) pja[j];
               jsup = pnd2sp[jj];
               if (pimask[jsup] != icycle) {
                  plstloc[nlstloc] = jsup;
                  pimask[jsup] = icycle;
                  nlstloc++;
               }
            }
         }
         if (nlstloc != 0)
            sort (plstloc, plstloc + nlstloc);
         for (j = 0; j < nlstloc; j++)
            pjat[piat[isup] + j] = (int) plstloc[j];
         piat[isup + 1] = piat[isup] + (int) nlstloc;
      }

      for (i = 0; i < nnew; i++)
         plistt[i] = (int) i;

// Print collapsed sparsity structure

      CBMatrix < int, float >::Str2PsBox (temp, _fname, _nblks, pblksnw);

   }

// Print sparsity with boxes that show nonzero blocks
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::Str2PsBox (const CMatrix < _Int, _Flt > &_amatr, const char *_fname,
                         int _nblks, int *_blks)
   {

// Open output file

      ofstream fout (_fname);

      if (!fout.is_open ()) {
         cout << " Error: File named " << _fname << " is not opened !!!" << endl;
         return;
      }

      static float default_bg[3] = { (float) 0.9, (float) 0.9, (float) 1.0 };
      static float default_fg[3] = { (float) 0.7, (float) 0.7, (float) 1.0 };

// Write the header information

      fout << "%!PS-Adobe-2.0" << endl;
      fout << "%%BoundingBox: 0 0 600 600" << endl;
      fout << "/m {moveto} def % x y" << endl;
      fout << "/l {lineto} def % x y" << endl;
      fout << "/s {stroke} def % x y" << endl;
      fout << "/n {newpath} def % x y" << endl;
      fout << "/c {closepath} def % x y" << endl;

// Parameters of the local window

      const int nsupmx = _amatr.GetNlist ();

      double s, s1;

      s1 = 50.0e0;
      s = 500.0e0 / ((double) nsupmx);

// Print the bounding window

      double dx, dy;

      fout << SetPw << 0.03 << " setlinewidth" << endl;

      fout << " n" << endl;
      dx = s1 + s * 0.5;
      dy = s1 + s * 0.5;
      Round (dx, dy);
      fout << SetPw << dx << SetPw << dy << " m" << endl;
      dx = s1 + s * (nsupmx + 0.5);
      dy = s1 + s * 0.5;
      Round (dx, dy);
      fout << SetPw << dx << SetPw << dy << " l" << endl;
      dx = s1 + s * (nsupmx + 0.5);
      dy = s1 + s * (nsupmx + 0.5);
      Round (dx, dy);
      fout << SetPw << dx << SetPw << dy << " l" << endl;
      dx = s1 + s * 0.5;
      dy = s1 + s * (nsupmx + 0.5);
      Round (dx, dy);
      fout << SetPw << dx << SetPw << dy << " l" << endl;
      dx = s1 + s * 0.5;
      dy = s1 + s * 0.5;
      Round (dx, dy);
      fout << SetPw << dx << SetPw << dy << " l s c" << endl;

// Print blocks partitioning

      int i, j, k;
      double x, y;
      double x1, y1;

      if (_nblks > 0) {

         vector < long long >blks_new (_nblks + 2);

         long long *pblks_new = &blks_new[0];

         int nblks_new = 0;

         pblks_new[0] = 0;

         for (i = 0; i < _nblks; i++) {
            if (_blks[i + 1] > _blks[i]) {
               pblks_new[nblks_new + 1] = _blks[i + 1];
               nblks_new++;
            }
         }

         if (pblks_new[nblks_new] < _amatr.GetNlist ()) {
            pblks_new[nblks_new + 1] = _amatr.GetNlist ();
            nblks_new++;
         }

         CBMatrix < _Int, _Flt > ahblk;

         CBMatrix < _Int, _Flt >::SplitMatrSpIntoHMatrSp (nblks_new, pblks_new, _amatr,
                                                          ahblk);

         CMatrix < int, float >*pahblkstr = ahblk.GetHMatrStr ();

         int nlistloc = pahblkstr->GetNlist ();
         int *plistloc = pahblkstr->GetListArr ();
         int *pialoc = pahblkstr->GetIaArr ();
         int *pjaloc = pahblkstr->GetJaArr ();

         for (int ilist = 0; ilist < nlistloc; ilist++) {
            int i = plistloc[ilist];
            for (int jlist = pialoc[ilist]; jlist < pialoc[ilist + 1]; jlist++) {
               j = pjaloc[jlist];
               x = pblks_new[j] + 0.5;
               x1 = pblks_new[j + 1] + 0.5;
               y = _amatr.GetNlist () - ((int) pblks_new[i] + 0.5) + 1;
               y1 = _amatr.GetNlist () - ((int) pblks_new[i + 1] + 0.5) + 1;
               fout << default_bg[0] << " " << default_bg[1] << " " << default_bg[2] <<
                  " setrgbcolor" << endl;
               fout << "[" << s1 + s * x << " " << s1 + s * y << " " << s * (x1 -
                                                                             x) << " " <<
                  s * (y1 - y) << "] rectfill" << endl;
               fout << default_fg[0] << " " << default_fg[1] << " " << default_fg[2] <<
                  " setrgbcolor" << endl;
               fout << "[" << s1 + s * x << " " << s1 + s * y << " " << s * (x1 -
                                                                             x) << " " <<
                  s * (y1 - y) << "] rectstroke" << endl;
            }
         }
         fout << "0 0 0 setrgbcolor" << endl;
      }
// Compute radius of the circle

      double r;

      r = (log10 (1.0e0 * nsupmx) + 1.0) / 4.0;
      if (r > 1.0e0)
         r = 1.0e0;

      r = s * r / 2.0;

      if (r < 0.001e0)
         r = 0.001e0;

      fout << SetPw << 2 * r << " setlinewidth" << endl;
      fout << " /d {moveto currentpoint " << SetPw << r;
      fout << " 0 360 arc fill} def % x y" << endl;

// Print the sparsity

      int i1, j1;

      const _Int *plist = _amatr.GetListArr ();
      const _Int *pia = _amatr.GetIaArr ();
      const _Int *pja = _amatr.GetJaArr ();

      fout << " n" << endl;
      for (int ilist = 0; ilist < _amatr.GetNlist (); ilist++) {
         i = (int) plist[ilist];
         for (k = (int) pia[ilist]; k < pia[ilist + 1]; k++) {
            j = (int) pja[k];
            i1 = i + 1;
            j1 = j + 1;
            x = (double) j1;
            y = (double) (_amatr.GetNlist () - i1 + 1);
            dx = s1 + s * x - r;
            dy = s1 + s * y;
            Round (dx, dy);
            fout << SetPw << dx << SetPw << dy << " m" << endl;
            dx = s1 + s * x + r;
            dy = s1 + s * y;
            Round (dx, dy);
            fout << SetPw << dx << SetPw << dy << " l" << endl;
         }
      }

// Write the footer

      fout << " s c" << endl;
      fout << " showpage" << endl;

// Close output file

      fout.close ();

   }

// Print sparsity with boxes that show nonzero blocks and hblocks
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::Str2PsBox2 (const CMatrix < _Int, _Flt > &_amatr, const char *_fname,
                          int _nhblks, int *_hblk2blks, int *_blks)
   {

// Open output file

      ofstream fout (_fname);

      if (!fout.is_open ()) {
         cout << " Error: File named " << _fname << " is not opened !!!" << endl;
         return;
      }

      static float default_bg[3] = { (float) 0.9, (float) 0.9, (float) 1.0 };
      static float default_fg[3] = { (float) 0.7, (float) 0.7, (float) 1.0 };

      static float default_bg2[3] = { (float) 0.97, (float) 0.97, (float) 1.0 };
      static float default_fg2[3] = { (float) 0.77, (float) 0.77, (float) 1.0 };

// Write the header information

      fout << "%!PS-Adobe-2.0" << endl;
      fout << "%%BoundingBox: 0 0 600 600" << endl;
      fout << "/m {moveto} def % x y" << endl;
      fout << "/l {lineto} def % x y" << endl;
      fout << "/s {stroke} def % x y" << endl;
      fout << "/n {newpath} def % x y" << endl;
      fout << "/c {closepath} def % x y" << endl;

// Parameters of the local window

      int nsupmx = _amatr.GetNlist ();

      double s, s1;

      s1 = 50.0e0;
      s = 500.0e0 / ((double) nsupmx);

// Print the bounding window

      double dx, dy;

      fout << SetPw << 0.03 << " setlinewidth" << endl;

      fout << " n" << endl;
      dx = s1 + s * 0.5;
      dy = s1 + s * 0.5;
      Round (dx, dy);
      fout << SetPw << dx << SetPw << dy << " m" << endl;
      dx = s1 + s * (nsupmx + 0.5);
      dy = s1 + s * 0.5;
      Round (dx, dy);
      fout << SetPw << dx << SetPw << dy << " l" << endl;
      dx = s1 + s * (nsupmx + 0.5);
      dy = s1 + s * (nsupmx + 0.5);
      Round (dx, dy);
      fout << SetPw << dx << SetPw << dy << " l" << endl;
      dx = s1 + s * 0.5;
      dy = s1 + s * (nsupmx + 0.5);
      Round (dx, dy);
      fout << SetPw << dx << SetPw << dy << " l" << endl;
      dx = s1 + s * 0.5;
      dy = s1 + s * 0.5;
      Round (dx, dy);
      fout << SetPw << dx << SetPw << dy << " l s c" << endl;

// Print blocks partitioning

      int i, j, k;
      double x, x1, y, y1;

      if (_nhblks > 0) {

         int nblks = _hblk2blks[_nhblks];

         CVectorData < long long >blks_new (nblks + 2);
         CVectorData < long long >hblks_new (nblks + 2);

         long long *pblks_new = blks_new.Ptr ();
         long long *phblks_new = hblks_new.Ptr ();

         int nblks_new = 0;
         int nhblks_new = 0;

         pblks_new[0] = 0;
         phblks_new[0] = 0;

         for (i = 0; i < nblks; i++) {
            if (_blks[i + 1] > _blks[i]) {
               pblks_new[nblks_new + 1] = _blks[i + 1];
               nblks_new++;
            }
         }
         if (pblks_new[nblks_new] < _amatr.GetNlist ()) {
            pblks_new[nblks_new + 1] = _amatr.GetNlist ();
            nblks_new++;
         }

         int iblk;

         for (i = 0; i < _nhblks; i++) {
            if (_hblk2blks[i + 1] > _hblk2blks[i]) {
               iblk = _hblk2blks[i + 1] - 1;
               phblks_new[nhblks_new + 1] = _blks[iblk + 1];
               nhblks_new++;
            }
         }
         if (phblks_new[nhblks_new] < _amatr.GetNlist ()) {
            phblks_new[nhblks_new + 1] = _amatr.GetNlist ();
            nhblks_new++;
         }

         {

            CBMatrix < _Int, _Flt > ahblk;

            CBMatrix < _Int, _Flt >::SplitMatrSpIntoHMatrSp (nhblks_new, phblks_new,
                                                             _amatr, ahblk);

            CMatrix < int, float >*pahblkstr = ahblk.GetHMatrStr ();

            int nlistloc = pahblkstr->GetNlist ();
            int *plistloc = pahblkstr->GetListArr ();
            int *pialoc = pahblkstr->GetIaArr ();
            int *pjaloc = pahblkstr->GetJaArr ();

            for (int ilist = 0; ilist < nlistloc; ilist++) {
               int i = plistloc[ilist];
               for (int jlist = pialoc[ilist]; jlist < pialoc[ilist + 1]; jlist++) {
                  j = pjaloc[jlist];
                  x = phblks_new[j] + 0.5;
                  x1 = phblks_new[j + 1] + 0.5;
                  y = _amatr.GetNlist () - (phblks_new[i] + 0.5) + 1;
                  y1 = _amatr.GetNlist () - (phblks_new[i + 1] + 0.5) + 1;
                  fout << default_bg2[0] << " " << default_bg2[1] << " " << default_bg2[2]
                     << " setrgbcolor" << endl;
                  fout << "[" << s1 + s * x << " " << s1 + s * y << " " << s * (x1 -
                                                                                x) << " "
                     << s * (y1 - y) << "] rectfill" << endl;
                  fout << default_fg2[0] << " " << default_fg2[1] << " " << default_fg2[2]
                     << " setrgbcolor" << endl;
                  fout << "[" << s1 + s * x << " " << s1 + s * y << " " << s * (x1 -
                                                                                x) << " "
                     << s * (y1 - y) << "] rectstroke" << endl;
               }
            }
            fout << "0 0 0 setrgbcolor" << endl;
         }

         {

            CBMatrix < _Int, _Flt > ahblk;

            CBMatrix < _Int, _Flt >::SplitMatrSpIntoHMatrSp (nblks_new, pblks_new, _amatr,
                                                             ahblk);

            CMatrix < int, float >*pahblkstr = ahblk.GetHMatrStr ();

            int nlistloc = pahblkstr->GetNlist ();
            int *plistloc = pahblkstr->GetListArr ();
            int *pialoc = pahblkstr->GetIaArr ();
            int *pjaloc = pahblkstr->GetJaArr ();

            for (int ilist = 0; ilist < nlistloc; ilist++) {
               int i = plistloc[ilist];
               for (int jlist = pialoc[ilist]; jlist < pialoc[ilist + 1]; jlist++) {
                  j = pjaloc[jlist];
                  x = pblks_new[j] + 0.5;
                  x1 = pblks_new[j + 1] + 0.5;
                  y = _amatr.GetNlist () - (pblks_new[i] + 0.5) + 1;
                  y1 = _amatr.GetNlist () - (pblks_new[i + 1] + 0.5) + 1;
                  fout << default_bg[0] << " " << default_bg[1] << " " << default_bg[2] <<
                     " setrgbcolor" << endl;
                  fout << "[" << s1 + s * x << " " << s1 + s * y << " " << s * (x1 -
                                                                                x) << " "
                     << s * (y1 - y) << "] rectfill" << endl;
                  fout << default_fg[0] << " " << default_fg[1] << " " << default_fg[2] <<
                     " setrgbcolor" << endl;
                  fout << "[" << s1 + s * x << " " << s1 + s * y << " " << s * (x1 -
                                                                                x) << " "
                     << s * (y1 - y) << "] rectstroke" << endl;
               }
            }
            fout << "0 0 0 setrgbcolor" << endl;

         }

      }
// Compute radius of the circle

      double r;

      r = (log10 (1.0e0 * nsupmx) + 1.0) / 4.0;
      if (r > 1.0e0)
         r = 1.0e0;

      r = s * r / 2.0;

      if (r < 0.001e0)
         r = 0.001e0;

      fout << SetPw << 2 * r << " setlinewidth" << endl;
      fout << " /d {moveto currentpoint " << SetPw << r;
      fout << " 0 360 arc fill} def % x y" << endl;

// Print the sparsity

      int i1, j1;

      const _Int *plist = _amatr.GetListArr ();
      const _Int *pia = _amatr.GetIaArr ();
      const _Int *pja = _amatr.GetJaArr ();

      fout << " n" << endl;
      for (int ilist = 0; ilist < _amatr.GetNlist (); ilist++) {
         i = (int) plist[ilist];
         for (k = (int) pia[ilist]; k < pia[ilist + 1]; k++) {
            j = (int) pja[k];
            i1 = i + 1;
            j1 = j + 1;
            x = (double) j1;
            y = (double) (_amatr.GetNlist () - i1 + 1);
            dx = s1 + s * x - r;
            dy = s1 + s * y;
            Round (dx, dy);
            fout << SetPw << dx << SetPw << dy << " m" << endl;
            dx = s1 + s * x + r;
            dy = s1 + s * y;
            Round (dx, dy);
            fout << SetPw << dx << SetPw << dy << " l" << endl;
         }
      }

// Write the footer

      fout << " s c" << endl;
      fout << " showpage" << endl;

// Close output file

      fout.close ();

   }

// Print sparsity with boxes that show nonzero blocks
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::StrRect2PsBox (const CMatrix < _Int, _Flt > &_amatr, const char *_fname,
                             int _nblksR, int *_blksR, int _nblksC, int *_blksC)
   {

// Open output file

      ofstream fout (_fname);

      if (!fout.is_open ()) {
         cout << " Error: File named " << _fname << " is not opened !!!" << endl;
         return;
      }

      static float default_bg[3] = { (float) 0.9, (float) 0.9, (float) 1.0 };
      static float default_fg[3] = { (float) 0.7, (float) 0.7, (float) 1.0 };

      static float default_bg2[3] = { (float) 0.97, (float) 0.97, (float) 1.0 };
      static float default_fg2[3] = { (float) 0.77, (float) 0.77, (float) 1.0 };

// Write the header information

      fout << "%!PS-Adobe-2.0" << endl;
      fout << "%%BoundingBox: 0 0 600 600" << endl;
      fout << "/m {moveto} def % x y" << endl;
      fout << "/l {lineto} def % x y" << endl;
      fout << "/s {stroke} def % x y" << endl;
      fout << "/n {newpath} def % x y" << endl;
      fout << "/c {closepath} def % x y" << endl;

// Parameters of the local window

      int nsupC = _blksC[_nblksC];
      int nsupR = _blksR[_nblksR];

      int nsupmx = nsupC;
      if (nsupR > nsupmx)
         nsupmx = nsupR;

      double s, s1;

      s1 = 50.0e0;
      s = 500.0e0 / ((double) nsupmx);

// Print the bounding window

      double dx, dy;

      fout << SetPw << 0.03 << " setlinewidth" << endl;

      fout << " n" << endl;
      dx = s1 + s * 0.5;
      dy = s1 + s * 0.5;
      Round (dx, dy);
      fout << SetPw << dx << SetPw << dy << " m" << endl;
      dx = s1 + s * (nsupC + 0.5);
      dy = s1 + s * 0.5;
      Round (dx, dy);
      fout << SetPw << dx << SetPw << dy << " l" << endl;
      dx = s1 + s * (nsupC + 0.5);
      dy = s1 + s * (nsupR + 0.5);
      Round (dx, dy);
      fout << SetPw << dx << SetPw << dy << " l" << endl;
      dx = s1 + s * 0.5;
      dy = s1 + s * (nsupR + 0.5);
      Round (dx, dy);
      fout << SetPw << dx << SetPw << dy << " l" << endl;
      dx = s1 + s * 0.5;
      dy = s1 + s * 0.5;
      Round (dx, dy);
      fout << SetPw << dx << SetPw << dy << " l s c" << endl;

// Print blocks partitioning

      int i, j, k;
      double x, x1, y, y1;

      if (_nblksC > 0) {

         CVectorData < int >blksC_new (_nblksC + 2);

         int *pblksC_new = blksC_new.Ptr ();

         int nblksC_new = 0;

         pblksC_new[0] = 0;

         for (i = 0; i < _nblksC; i++) {
            if (_blksC[i + 1] > _blksC[i]) {
               pblksC_new[nblksC_new + 1] = _blksC[i + 1];
               nblksC_new++;
            }
         }

         CVectorData < int >blksR_new (_nblksR + 2);

         int *pblksR_new = blksR_new.Ptr ();

         int nblksR_new = 0;

         pblksR_new[0] = 0;

         for (i = 0; i < _nblksR; i++) {
            if (_blksR[i + 1] > _blksR[i]) {
               pblksR_new[nblksR_new + 1] = _blksR[i + 1];
               nblksR_new++;
            }
         }

         {

            CBMatrix < _Int, _Flt > ahblk;

            CBMatrix < _Int, _Flt >::SplitRectMatrSpIntoHMatrSp (nblksR_new, pblksR_new,
                                                                 nblksC_new, pblksC_new,
                                                                 _amatr, ahblk);

            CMatrix < int, float >*pahblkstr = ahblk.GetHMatrStr ();

            int nlistloc = pahblkstr->GetNlist ();
            int *plistloc = pahblkstr->GetListArr ();
            int *pialoc = pahblkstr->GetIaArr ();
            int *pjaloc = pahblkstr->GetJaArr ();

            for (int ilist = 0; ilist < nlistloc; ilist++) {
               int i = plistloc[ilist];
               for (int jlist = pialoc[ilist]; jlist < pialoc[ilist + 1]; jlist++) {
                  j = pjaloc[jlist];
                  x = pblksC_new[j] + 0.5;
                  x1 = pblksC_new[j + 1] + 0.5;
                  y = nsupR - (pblksR_new[i] + 0.5) + 1;
                  y1 = nsupR - (pblksR_new[i + 1] + 0.5) + 1;
                  fout << default_bg[0] << " " << default_bg[1] << " " << default_bg[2] <<
                     " setrgbcolor" << endl;
                  fout << "[" << s1 + s * x << " " << s1 + s * y << " " << s * (x1 -
                                                                                x) << " "
                     << s * (y1 - y) << "] rectfill" << endl;
                  fout << default_fg[0] << " " << default_fg[1] << " " << default_fg[2] <<
                     " setrgbcolor" << endl;
                  fout << "[" << s1 + s * x << " " << s1 + s * y << " " << s * (x1 -
                                                                                x) << " "
                     << s * (y1 - y) << "] rectstroke" << endl;
               }
            }
            fout << "0 0 0 setrgbcolor" << endl;
         }

      }
// Compute radius of the circle

      double r;

      r = (log10 (1.0e0 * nsupmx) + 1.0) / 4.0;
      if (r > 1.0e0)
         r = 1.0e0;

      r = s * r / 2.0;

      if (r < 0.001e0)
         r = 0.001e0;

      fout << SetPw << 2 * r << " setlinewidth" << endl;
      fout << " /d {moveto currentpoint " << SetPw << r;
      fout << " 0 360 arc fill} def % x y" << endl;

// Print the sparsity

      int i1, j1;

      const _Int *plist = _amatr.GetListArr ();
      const _Int *pia = _amatr.GetIaArr ();
      const _Int *pja = _amatr.GetJaArr ();

      fout << " n" << endl;
      for (int ilist = 0; ilist < _amatr.GetNlist (); ilist++) {
         i = (int) plist[ilist];
         for (k = (int) pia[ilist]; k < pia[ilist + 1]; k++) {
            j = (int) pja[k];
            i1 = i + 1;
            j1 = j + 1;
            x = (double) j1;
            y = (double) (nsupR - i1 + 1);
            dx = s1 + s * x - r;
            dy = s1 + s * y;
            Round (dx, dy);
            fout << SetPw << dx << SetPw << dy << " m" << endl;
            dx = s1 + s * x + r;
            dy = s1 + s * y;
            Round (dx, dy);
            fout << SetPw << dx << SetPw << dy << " l" << endl;
         }
      }

// Write the footer

      fout << " s c" << endl;
      fout << " showpage" << endl;

// Close output file

      fout.close ();
   };

// Print sparsity with boxes that show nonzero blocks
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::StrRect2PsBox (int _collap, const CMatrix < _Int, _Flt > &_amatr,
                             const char *_fname, int _nblksR, int *_blksR, int _nblksC,
                             int *_blksC)
   {

// Compute new blocks partitioning

      CVectorData < int >blksCnw (_nblksC + 2);
      CVectorData < int >blksRnw (_nblksR + 2);

      int *pblksCnw = blksCnw.Ptr ();
      int *pblksRnw = blksRnw.Ptr ();

      int nsupC = _blksC[_nblksC];
      int nsupR = _blksR[_nblksR];

      int nblksCnew = 0;

      pblksCnw[0] = 0;

      int iblk;

      for (iblk = 0; iblk < _nblksC; iblk++) {
         int ni = _blksC[iblk + 1] - _blksC[iblk];
         int niloc = (ni + _collap - 1) / _collap;
         if (niloc > 0) {
            pblksCnw[nblksCnew + 1] = pblksCnw[nblksCnew] + niloc;
            nblksCnew++;
         }
      }

      int nblksRnew = 0;

      pblksRnw[0] = 0;
      for (iblk = 0; iblk < _nblksR; iblk++) {
         int ni = _blksR[iblk + 1] - _blksR[iblk];
         int niloc = (ni + _collap - 1) / _collap;
         if (niloc > 0) {
            pblksRnw[nblksRnew + 1] = pblksRnw[nblksRnew] + niloc;
            nblksRnew++;
         }
      }

// Compute nd2sp and sp2nd arrays

      int nsupCnew = pblksCnw[nblksCnew];

      CVectorData < int >nd2spC (nsupC);
      CVectorData < int >sp2ndC (nsupCnew + 1);

      int *pnd2spC = nd2spC.Ptr ();
      int *psp2ndC = sp2ndC.Ptr ();

      int i, j;

      psp2ndC[0] = 0;
      for (iblk = 0; iblk < nblksCnew; iblk++) {
         for (i = pblksCnw[iblk]; i < pblksCnw[iblk + 1] - 1; i++) {
            psp2ndC[i + 1] = psp2ndC[i] + _collap;
         }
         psp2ndC[pblksCnw[iblk + 1]] = _blksC[iblk + 1];
      }

      for (i = 0; i < nsupCnew; i++) {
         for (j = psp2ndC[i]; j < psp2ndC[i + 1]; j++) {
            pnd2spC[j] = i;
         }
      }

      int nsupRnew = pblksRnw[nblksRnew];

      CVectorData < int >nd2spR (nsupR);
      CVectorData < int >sp2ndR (nsupRnew + 1);

      int *pnd2spR = nd2spR.Ptr ();
      int *psp2ndR = sp2ndR.Ptr ();

      psp2ndR[0] = 0;
      for (iblk = 0; iblk < nblksRnew; iblk++) {
         for (i = pblksRnw[iblk]; i < pblksRnw[iblk + 1] - 1; i++) {
            psp2ndR[i + 1] = psp2ndR[i] + _collap;
         };
         psp2ndR[pblksRnw[iblk + 1]] = _blksR[iblk + 1];
      }

      for (i = 0; i < nsupRnew; i++) {
         for (j = psp2ndR[i]; j < psp2ndR[i + 1]; j++) {
            pnd2spR[j] = i;
         }
      }

// Count the total number of elements in the collapsed matrix

      int isup, jsup, jj;

      int icycle = 0;

      CVectorData < int >imask (nsupCnew);
      CVectorData < int >lstloc (nsupCnew);

      int *pimask = imask.Ptr ();
      int *plstloc = lstloc.Ptr ();

      for (i = 0; i < nsupCnew; i++)
         pimask[i] = icycle;

      int nz = 0;
      int nlstloc;

      const _Int *pia = _amatr.GetIaArr ();
      const _Int *pja = _amatr.GetJaArr ();

      for (isup = 0; isup < nsupRnew; isup++) {
         icycle++;
         nlstloc = 0;
         for (i = psp2ndR[isup]; i < psp2ndR[isup + 1]; i++) {
            for (j = (int) pia[i]; j < pia[i + 1]; j++) {
               jj = (int) pja[j];
               jsup = pnd2spC[jj];
               if (pimask[jsup] != icycle) {
                  plstloc[nlstloc] = jsup;
                  pimask[jsup] = icycle;
                  nlstloc++;
               }
            }
         }
         nz += nlstloc;
      }

// Compute collapsed matrix

      CMatrix < _Int, _Flt > temp;

      temp.ResizeAndSetAllSp (nsupRnew, 0, nz, 0);

      _Int *plistt = temp.GetListArr ();
      _Int *piat = temp.GetIaArr ();
      _Int *pjat = temp.GetJaArr ();

      piat[0] = 0;
      for (isup = 0; isup < nsupRnew; isup++) {
         icycle++;
         nlstloc = 0;
         for (i = psp2ndR[isup]; i < psp2ndR[isup + 1]; i++) {
            for (j = (int) pia[i]; j < pia[i + 1]; j++) {
               jj = (int) pja[j];
               jsup = pnd2spC[jj];
               if (pimask[jsup] != icycle) {
                  plstloc[nlstloc] = jsup;
                  pimask[jsup] = icycle;
                  nlstloc++;
               }
            }
         }
         if (nlstloc != 0)
            sort (plstloc, plstloc + nlstloc);
         for (j = 0; j < nlstloc; j++)
            pjat[piat[isup] + j] = (int) plstloc[j];
         piat[isup + 1] = piat[isup] + (int) nlstloc;
      }
      for (i = 0; i < nsupRnew; i++)
         plistt[i] = (int) i;

// Print collapsed sparsity structure

      CBMatrix < _Int, _Flt >::StrRect2PsBox (temp, _fname, nblksRnew, pblksRnw,
                                              nblksCnew, pblksCnw);

   };

// Print sparsity with boxes that show nonzero blocks and hblocks
//========================================================================================
   template < typename _Int, typename _Flt > void CBMatrix < _Int,
      _Flt >::Str2PsBox2 (int _collap, const CMatrix < _Int, _Flt > &_amatr,
                          const char *_fname, int _nhblks, int *_hblk2blks, int *_blks)
   {

// Compute new blocks and hblocks partitioning

      int nblks_max = 0;

      if (_nhblks > 0) {
         nblks_max = _hblk2blks[_nhblks];
      }

      CVectorData < int >blksnw (nblks_max + 2);

      int *pblksnw = blksnw.Ptr ();

      int nsupmx = _amatr.GetNlist ();

      int nblksnew = 0;

      if (_nhblks == 0) {
         pblksnw[0] = 0;
         pblksnw[1] = (nsupmx + _collap - 1) / _collap;
         nblksnew = 1;
      } else {
         pblksnw[0] = 0;
         for (int iblk = 0; iblk < nblks_max; iblk++) {
            int ni = _blks[iblk + 1] - _blks[iblk];
            int niloc = (ni + _collap - 1) / _collap;
            if (niloc > 0) {
               pblksnw[nblksnew + 1] = pblksnw[nblksnew] + niloc;
               nblksnew++;
            }
         }
      }

// Compute nd2sp and sp2nd arrays

      int nnew;

      if (nblksnew == 0) {
         nnew = pblksnw[nblksnew + 1];
      } else {
         nnew = pblksnw[nblksnew];
      }

      CVectorData < int >nd2sp (_amatr.GetNlist ());
      CVectorData < int >sp2nd (nnew + 1);

      int *pnd2sp = nd2sp.Ptr ();
      int *psp2nd = sp2nd.Ptr ();

      int i, j;

      if (nblksnew == 0) {
         psp2nd[0] = 0;
         for (i = 0; i < nnew - 1; i++) {
            psp2nd[i + 1] = psp2nd[i] + _collap;
         }
         psp2nd[nnew] = nsupmx;
      } else {
         psp2nd[0] = 0;
         for (int iblk = 0; iblk < nblksnew; iblk++) {
            for (i = pblksnw[iblk]; i < pblksnw[iblk + 1] - 1; i++) {
               psp2nd[i + 1] = psp2nd[i] + _collap;
            }
            psp2nd[pblksnw[iblk + 1]] = _blks[iblk + 1];
         }
      }

      for (i = 0; i < nnew; i++) {
         for (j = psp2nd[i]; j < psp2nd[i + 1]; j++) {
            pnd2sp[j] = i;
         }
      }

// Count the total number of elements in the collapsed matrix

      int isup, jsup, jj;

      int icycle = 0;

      CVectorData < int >imask (nnew);
      CVectorData < int >lstloc (nnew);

      int *pimask = imask.Ptr ();
      int *plstloc = lstloc.Ptr ();

      for (i = 0; i < nnew; i++)
         pimask[i] = icycle;

      int nz = 0;
      int nlstloc;

      const _Int *pia = _amatr.GetIaArr ();
      const _Int *pja = _amatr.GetJaArr ();

      for (isup = 0; isup < nnew; isup++) {
         icycle++;
         nlstloc = 0;
         for (i = psp2nd[isup]; i < psp2nd[isup + 1]; i++) {
            for (j = (int) pia[i]; j < pia[i + 1]; j++) {
               jj = (int) pja[j];
               jsup = pnd2sp[jj];
               if (pimask[jsup] != icycle) {
                  plstloc[nlstloc] = jsup;
                  pimask[jsup] = icycle;
                  nlstloc++;
               }
            }
         }
         nz += nlstloc;
      }

// Compute collapsed matrix

      CMatrix < int, float >temp;

      temp.ResizeAndSetAllSp (nnew, 0, nz, 0);

      int *plistt = temp.GetListArr ();
      int *piat = temp.GetIaArr ();
      int *pjat = temp.GetJaArr ();

      piat[0] = 0;
      for (isup = 0; isup < nnew; isup++) {
         icycle++;
         nlstloc = 0;
         for (i = psp2nd[isup]; i < psp2nd[isup + 1]; i++) {
            for (j = (int) pia[i]; j < pia[i + 1]; j++) {
               jj = (int) pja[j];
               jsup = pnd2sp[jj];
               if (pimask[jsup] != icycle) {
                  plstloc[nlstloc] = jsup;
                  pimask[jsup] = icycle;
                  nlstloc++;
               }
            }
         }
         if (nlstloc != 0)
            sort (plstloc, plstloc + nlstloc);
         for (j = 0; j < nlstloc; j++)
            pjat[piat[isup] + j] = (int) plstloc[j];
         piat[isup + 1] = piat[isup] + (int) nlstloc;
      }
      for (i = 0; i < nnew; i++)
         plistt[i] = (int) i;

// Print collapsed sparsity structure

      CBMatrix < int, float >::Str2PsBox2 (temp, _fname, _nhblks, _hblk2blks, pblksnw);

   }

/// @brief Get the current number of rows
//========================================================================================
   template < typename _FltVect > int CQrdBase < _FltVect >::GetNRows ()
   {

      int nrows = 0;

      int *pnrowarr = &nrowarr[0];

      if (nqblk > 0)
         nrows = pnrowarr[nqblk - 1];

      return nrows;

   }

/// @brief Get the current number of cols
//========================================================================================
   template < typename _FltVect > int CQrdBase < _FltVect >::GetNCols ()
   {

      int ncols = 0;

      int *pqblksc = &qblksc[0];

      if (nqblk > 0)
         ncols = pqblksc[nqblk];

      return ncols;

   }

/// @brief Get the current allocated memory at node
//========================================================================================
   template < typename _FltVect > int CQrdBase < _FltVect >::GetAllocatedMemory ()
   {

      int nelems = 0;

      int i;

      int *pncolarr_alloc = &ncolarr_alloc[0];
      int *pnrowarr_alloc = &nrowarr_alloc[0];

      for (i = 0; i < nqblk_alloc; i++) {
         nelems += pncolarr_alloc[i] * (pnrowarr_alloc[i] + 1);
      }

      return nelems;

   }

/// @brief Update QR decomposition for the current block and store data in the local buffers
//========================================================================================
   template < typename _FltVect > void CQrdBase < _FltVect >::UpdateQrdBlk (int _ncol,
                                                                            int _nrow,
                                                                            _FltVect *
                                                                            _ablk,
                                                                            int _lda)
   {

      this->UpdateQrdBlk_impl (false, _ncol, _nrow, _ablk, _lda);

   }

/// @brief Update QR decomposition for the current block and store data in the local buffers (threads version)
//========================================================================================
   template < typename _FltVect > void CQrdBase < _FltVect >::UpdateQrdBlk_thr (int _ncol,
                                                                                int _nrow,
                                                                                _FltVect *
                                                                                _ablk,
                                                                                int _lda)
   {

      this->UpdateQrdBlk_impl (true, _ncol, _nrow, _ablk, _lda);

   }

/// @brief Update QR decomposition for the current block and store data in the local buffers
//========================================================================================
   template < typename _FltVect > void CQrdBase <
      _FltVect >::UpdateQrdBlk_impl (bool _b_use_threads, int _ncol, int _nrow,
                                     _FltVect * _ablk, int _lda)
   {

// Get the sizes

      int nrowstot = this->GetNRows ();
      int ncolstot = this->GetNCols ();

// Perform computation of the QR decomposition

      int nrowstot_new = nrowstot;
      if (nrowstot_new < ncolstot + _ncol)
         nrowstot_new = ncolstot + _ncol;
      if (nrowstot_new < _nrow)
         nrowstot_new = _nrow;

// Find the concrete place or allocate work data

      int *pqblksc = &qblksc[0];
      int *pncolarr_alloc = &ncolarr_alloc[0];
      int *pnrowarr = &nrowarr[0];
      int *pnrowarr_alloc = &nrowarr_alloc[0];
      CVectorData < _FltVect > *pqarr = &qarr[0];
      vector < _FltVect > *ptauarr = &tauarr[0];

      _FltVect *qloc = NULL;
      _FltVect *tauloc = NULL;

      int ialloc = 0;

      if (nqblk_alloc == 0 || nqblk == 0) {
         ialloc = 1;
      } else {
         if (pqblksc[nqblk] - pqblksc[nqblk - 1] + _ncol <= pncolarr_alloc[nqblk - 1]
             && nrowstot_new == pnrowarr[nqblk - 1]) {
            qloc =
               pqarr[nqblk - 1].Ptr () + (pqblksc[nqblk] -
                                          pqblksc[nqblk - 1]) * nrowstot_new;
            tauloc = &ptauarr[nqblk - 1][0] + (pqblksc[nqblk] - pqblksc[nqblk - 1]);
         } else {
            if (nqblk_alloc > nqblk) {
               if (_ncol <= pncolarr_alloc[nqblk]
                   && nrowstot_new <= pnrowarr_alloc[nqblk]) {
                  qloc = pqarr[nqblk].Ptr ();
                  tauloc = &ptauarr[nqblk][0];
               } else {
                  ialloc = 1;
               }
            } else {
               ialloc = 1;
            }
         }
      }

      CVectorData < _FltVect > q_store;
      vector < _FltVect > tau_store;

      if (ialloc == 1) {

         q_store.resize (_ncol * nrowstot_new + 1);
         tau_store.resize (_ncol + 1);

         qloc = q_store.Ptr ();
         tauloc = &tau_store[0];

      }

      int i;

      for (i = 0; i < _ncol; i++) {
         if (_b_use_threads) {
            CVector < _FltVect >::SetByZeroes_thr (nrowstot_new, qloc + i * nrowstot_new);
            CVector < _FltVect >::CopyVector_thr (_nrow, _ablk + i * _lda,
                                                  qloc + i * nrowstot_new);
         } else {
            CVector < _FltVect >::SetByZeroes (nrowstot_new, qloc + i * nrowstot_new);
            CVector < _FltVect >::CopyVector (_nrow, _ablk + i * _lda,
                                              qloc + i * nrowstot_new);
         }
      }

      if (_b_use_threads) {
         this->MvmQH_thr (_ncol, qloc, nrowstot_new);
      } else {
         this->MvmQH (_ncol, qloc, nrowstot_new);
      }

      if (_b_use_threads) {
         CVector < _FltVect >::QrdBlock_thr (_ncol, nrowstot_new - ncolstot,
                                             qloc + ncolstot, nrowstot_new, tauloc);
      } else {
         CVector < _FltVect >::QrdBlock (_ncol, nrowstot_new - ncolstot, qloc + ncolstot,
                                         nrowstot_new, tauloc);
      }

// Store the result in the structures

      if (ialloc == 0) {
         if (pqblksc[nqblk] - pqblksc[nqblk - 1] + _ncol <= pncolarr_alloc[nqblk - 1]
             && nrowstot_new == pnrowarr[nqblk - 1]) {
            pqblksc[nqblk] += _ncol;
         } else {
            if (nqblk_alloc > nqblk) {
               if (_ncol <= pncolarr_alloc[nqblk]
                   && nrowstot_new <= pnrowarr_alloc[nqblk]) {
                  pqblksc[nqblk + 1] = pqblksc[nqblk] + _ncol;
                  pnrowarr[nqblk] = nrowstot_new;
                  nqblk++;
               }
            }
         }
      } else {
         if (nqblk_alloc == nqblk) {
            int nqblk_alloc_new = nqblk + 10;
            {
               vector < int >iarr (nqblk_alloc_new + 1);
               int *piarr = &iarr[0];
               for (i = 0; i <= nqblk; i++)
                  piarr[i] = pqblksc[i];
               qblksc.swap (iarr);
               pqblksc = piarr;
            }
            pqblksc[0] = 0;
            {
               vector < int >iarr (nqblk_alloc_new + 1);
               int *piarr = &iarr[0];
               for (i = 0; i < nqblk; i++)
                  piarr[i] = pncolarr_alloc[i];
               ncolarr_alloc.swap (iarr);
               pncolarr_alloc = piarr;
            }
            pncolarr_alloc[nqblk] = _ncol;
            {
               vector < int >iarr (nqblk_alloc_new + 1);
               int *piarr = &iarr[0];
               for (i = 0; i < nqblk; i++)
                  piarr[i] = pnrowarr[i];
               nrowarr.swap (iarr);
               pnrowarr = piarr;
            }
            {
               vector < int >iarr (nqblk_alloc_new + 1);
               int *piarr = &iarr[0];
               for (i = 0; i < nqblk; i++)
                  piarr[i] = pnrowarr_alloc[i];
               nrowarr_alloc.swap (iarr);
               pnrowarr_alloc = piarr;
            }
            pnrowarr_alloc[nqblk] = nrowstot_new;
            {
               vector < CVectorData < _FltVect > >setarr (nqblk_alloc_new + 1);
               CVectorData < _FltVect > *psetarr = &setarr[0];
               for (i = 0; i < nqblk; i++)
                  psetarr[i].swap (pqarr[i]);
               qarr.swap (setarr);
               pqarr = psetarr;
            }
            for (i = nqblk + 1; i < nqblk_alloc_new; i++) {
               pnrowarr_alloc[i] = 0;
               pncolarr_alloc[i] = 0;
               pnrowarr[i] = 0;
            }
            {
               vector < vector < _FltVect > >setarr (nqblk_alloc_new + 1);
               vector < _FltVect > *psetarr = &setarr[0];
               for (i = 0; i < nqblk; i++)
                  psetarr[i].swap (ptauarr[i]);
               tauarr.swap (setarr);
               ptauarr = psetarr;
            }
            nqblk_alloc = nqblk_alloc_new;
         } else {
            pncolarr_alloc[nqblk] = _ncol;
            pnrowarr_alloc[nqblk] = nrowstot_new;
         }
         pqblksc[nqblk + 1] = pqblksc[nqblk] + _ncol;
         pnrowarr[nqblk] = nrowstot_new;
         pqarr[nqblk].swap (q_store);
         ptauarr[nqblk].swap (tau_store);
         nqblk++;
      }

   }

///
/// @brief Multiply Q factor by the current block (self version)
//========================================================================================
   template < typename _FltVect > void CQrdBase < _FltVect >::MvmQ (int _nrhs,
                                                                    _FltVect * _qx,
                                                                    int _ldqx)
   {

      this->MvmQ_impl (false, _nrhs, _qx, _ldqx);

   }

///
/// @brief Multiply Q factor by the current block (self version) (threads version)
//========================================================================================
   template < typename _FltVect > void CQrdBase < _FltVect >::MvmQ_thr (int _nrhs,
                                                                        _FltVect * _qx,
                                                                        int _ldqx)
   {

      this->MvmQ_impl (true, _nrhs, _qx, _ldqx);

   }

///
/// @brief Multiply Q factor by the current block (self version) (implementation)
//========================================================================================
   template < typename _FltVect > void CQrdBase <
      _FltVect >::MvmQ_impl (bool _b_use_threads, int _nrhs, _FltVect * _qx, int _ldqx)
   {

// Get the sizes

      int nrowstot = this->GetNRows ();

      if (_ldqx < nrowstot)
         throw " CQrdBase<_FltVect>::MvmQ_impl: error in ldqx value ";

// Main cycle over columns

      int *pqblksc = &qblksc[0];
      int *pnrowarr = &nrowarr[0];
      CVectorData < _FltVect > *pqarr = &qarr[0];
      vector < _FltVect > *ptauarr = &tauarr[0];

      int iblkrd;

      for (iblkrd = nqblk - 1; iblkrd >= 0; iblkrd--) {

         int jbs = pqblksc[iblkrd];
         int ncolj = pqblksc[iblkrd + 1] - pqblksc[iblkrd];
         int mlocj = pnrowarr[iblkrd];
         _FltVect *qblk = pqarr[iblkrd].Ptr () + jbs;
         _FltVect *taublk = &ptauarr[iblkrd][0];
         _FltVect *qxloc = _qx + jbs;

         if (_b_use_threads) {
            CVector < _FltVect >::MvmQ_Housholder_thr (_nrhs, mlocj - jbs, ncolj, qblk,
                                                       mlocj, taublk, qxloc, _ldqx);
         } else {
            CVector < _FltVect >::MvmQ_Housholder (_nrhs, mlocj - jbs, ncolj, qblk, mlocj,
                                                   taublk, qxloc, _ldqx);
         }

      }

   }

///
/// @brief Multiply Q factor by the current block
//========================================================================================
   template < typename _FltVect > void CQrdBase < _FltVect >::MvmQ (int _nrhs, int _nrows,
                                                                    _FltVect * _x,
                                                                    int _ldx,
                                                                    _FltVect * _qx,
                                                                    int _ldqx)
   {

      this->MvmQ_impl (false, _nrhs, _nrows, _x, _ldx, _qx, _ldqx);

   }

///
/// @brief Multiply Q factor by the current block (threads version)
//========================================================================================
   template < typename _FltVect > void CQrdBase < _FltVect >::MvmQ_thr (int _nrhs,
                                                                        int _nrows,
                                                                        _FltVect * _x,
                                                                        int _ldx,
                                                                        _FltVect * _qx,
                                                                        int _ldqx)
   {

      this->MvmQ_impl (true, _nrhs, _nrows, _x, _ldx, _qx, _ldqx);

   }

///
/// @brief Multiply Q factor by the current block (implementation)
//========================================================================================
   template < typename _FltVect > void CQrdBase <
      _FltVect >::MvmQ_impl (bool _b_use_threads, int _nrhs, int _nrows, _FltVect * _x,
                             int _ldx, _FltVect * _qx, int _ldqx)
   {

// Get the sizes

      int nrowstot = this->GetNRows ();
      int ncolstot = this->GetNCols ();

      if (_ldx < ncolstot)
         throw " CQrdBase<_FltVect>::MvmQ_impl: error in ldx value ";
      if (_ldqx < _nrows)
         throw " CQrdBase<_FltVect>::MvmQ_impl: error in ldqx value ";

// Init resulting data

      int i;

      if (_nrows >= ncolstot && _nrows >= nrowstot) {

         for (i = 0; i < _nrhs; i++) {
            if (_b_use_threads) {
               CVector < _FltVect >::SetByZeroes_thr (nrowstot, _qx + i * _ldqx);
               CVector < _FltVect >::CopyVector_thr (ncolstot, _x + i * _ldx,
                                                     _qx + i * _ldqx);
            } else {
               CVector < _FltVect >::SetByZeroes (nrowstot, _qx + i * _ldqx);
               CVector < _FltVect >::CopyVector (ncolstot, _x + i * _ldx,
                                                 _qx + i * _ldqx);
            }
         }

         if (_b_use_threads) {
            this->MvmQ_thr (_nrhs, _qx, _ldqx);
         } else {
            this->MvmQ (_nrhs, _qx, _ldqx);
         }

      } else {

         CVectorData < _FltVect > qxloc (nrowstot * _nrhs + 1);
         _FltVect *pqxloc = qxloc.Ptr ();

         for (i = 0; i < _nrhs; i++) {
            if (_b_use_threads) {
               CVector < _FltVect >::SetByZeroes_thr (nrowstot, pqxloc + i * nrowstot);
               CVector < _FltVect >::CopyVector_thr (ncolstot, _x + i * _ldx,
                                                     pqxloc + i * nrowstot);
            } else {
               CVector < _FltVect >::SetByZeroes (nrowstot, pqxloc + i * nrowstot);
               CVector < _FltVect >::CopyVector (ncolstot, _x + i * _ldx,
                                                 pqxloc + i * nrowstot);
            }
         }

         if (_b_use_threads) {
            this->MvmQ_thr (_nrhs, pqxloc, nrowstot);
         } else {
            this->MvmQ (_nrhs, pqxloc, nrowstot);
         }

         for (i = 0; i < _nrhs; i++) {
            if (_b_use_threads) {
               CVector < _FltVect >::CopyVector_thr (_nrows, pqxloc + i * nrowstot,
                                                     _qx + i * _ldqx);
            } else {
               CVector < _FltVect >::CopyVector (_nrows, pqxloc + i * nrowstot,
                                                 _qx + i * _ldqx);
            }
         }

      }

   }

///
/// @brief Multiply QH factor by the current block (self version) (implementation)
//========================================================================================
   template < typename _FltVect > void CQrdBase < _FltVect >::MvmQH (int _nrhs,
                                                                     _FltVect * _qx,
                                                                     int _ldqx)
   {

      this->MvmQH_impl (false, _nrhs, _qx, _ldqx);

   }

///
/// @brief Multiply QH factor by the current block (self version) (implementation)
//========================================================================================
   template < typename _FltVect > void CQrdBase < _FltVect >::MvmQH_thr (int _nrhs,
                                                                         _FltVect * _qx,
                                                                         int _ldqx)
   {

      this->MvmQH_impl (true, _nrhs, _qx, _ldqx);

   }

///
/// @brief Multiply QH factor by the current block (self version) (implementation)
//========================================================================================
   template < typename _FltVect > void CQrdBase <
      _FltVect >::MvmQH_impl (bool _b_use_threads, int _nrhs, _FltVect * _qx, int _ldqx)
   {

// Get the sizes

      int nrowstot = this->GetNRows ();

      if (_ldqx < nrowstot)
         throw " CQrdBase<_FltVect>::MvmQH: error in ldqx value ";

// Main cycle over columns

      int *pqblksc = &qblksc[0];
      int *pnrowarr = &nrowarr[0];
      CVectorData < _FltVect > *pqarr = &qarr[0];
      vector < _FltVect > *ptauarr = &tauarr[0];

      int iblkrd;

      for (iblkrd = 0; iblkrd < nqblk; iblkrd++) {

         int jbs = pqblksc[iblkrd];
         int ncolj = pqblksc[iblkrd + 1] - pqblksc[iblkrd];
         int mlocj = pnrowarr[iblkrd];

         _FltVect *qblk = pqarr[iblkrd].Ptr () + jbs;
         _FltVect *taublk = &ptauarr[iblkrd][0];
         _FltVect *qxloc = _qx + jbs;

         if (_b_use_threads) {
            CVector < _FltVect >::MvmQH_Housholder_thr (_nrhs, mlocj - jbs, ncolj, qblk,
                                                        mlocj, taublk, qxloc, _ldqx);
         } else {
            CVector < _FltVect >::MvmQH_Housholder (_nrhs, mlocj - jbs, ncolj, qblk,
                                                    mlocj, taublk, qxloc, _ldqx);
         }

      }

   }

///
/// @brief Multiply QH factor by the current block
//========================================================================================
   template < typename _FltVect > void CQrdBase < _FltVect >::MvmQHPart (int _nrhs,
                                                                         int _ibegQ,
                                                                         int _iendQ,
                                                                         _FltVect * _qx,
                                                                         int _ldqx)
   {

// Get the sizes

      int nrowstot = this->GetNRows ();

      if (_ldqx < nrowstot)
         throw " CQrdBase<_FltVect>::MvmQHPart: error in ldqx value ";

// Main cycle over columns

      int *pqblksc = &qblksc[0];
      int *pnrowarr = &nrowarr[0];
      CVectorData < _FltVect > *pqarr = &qarr[0];
      vector < _FltVect > *ptauarr = &tauarr[0];

      int iblkrd, j, jloc;

      for (iblkrd = 0; iblkrd < nqblk; iblkrd++) {

         int jbs = pqblksc[iblkrd];
         int ncolj = pqblksc[iblkrd + 1] - pqblksc[iblkrd];
         int mlocj = pnrowarr[iblkrd];

         _FltVect *qblk = pqarr[iblkrd].Ptr () + jbs;
         _FltVect *taublk = &ptauarr[iblkrd][0];
         _FltVect *qxloc = _qx + jbs;

         for (j = 0; j < ncolj; j++) {
            jloc = j + jbs;
            if (jloc >= _ibegQ && jloc <= _iendQ) {
               CVector < _FltVect >::MvmQH_Housholder (_nrhs, mlocj - jloc, 1,
                                                       qblk + j * mlocj + j, mlocj,
                                                       taublk + j, qxloc + j, _ldqx);
            }
         }

      }

   }

///
/// @brief Multiply QH factor by the current block
//========================================================================================
   template < typename _FltVect > void CQrdBase < _FltVect >::MvmQH (int _nrhs,
                                                                     _FltVect * _x,
                                                                     int _ldx,
                                                                     _FltVect * _qx,
                                                                     int _ldqx)
   {

      this->MvmQH_impl (false, _nrhs, _x, _ldx, _qx, _ldqx);

   }

///
/// @brief Multiply QH factor by the current block (threads version)
//========================================================================================
   template < typename _FltVect > void CQrdBase < _FltVect >::MvmQH_thr (int _nrhs,
                                                                         _FltVect * _x,
                                                                         int _ldx,
                                                                         _FltVect * _qx,
                                                                         int _ldqx)
   {

      this->MvmQH_impl (true, _nrhs, _x, _ldx, _qx, _ldqx);

   }

///
/// @brief Multiply QH factor by the current block (implementation)
//========================================================================================
   template < typename _FltVect > void CQrdBase <
      _FltVect >::MvmQH_impl (bool _b_use_threads, int _nrhs, _FltVect * _x, int _ldx,
                              _FltVect * _qx, int _ldqx)
   {

// Get the sizes

      int nrowstot = this->GetNRows ();
      int ncolstot = this->GetNCols ();

      if (_ldx < nrowstot)
         throw " CQrdBase<_FltVect>::MvmQH_impl: error in ldx value ";
      if (_ldqx < ncolstot)
         throw " CQrdBase<_FltVect>::MvmQH_impl: error in ldqx value ";

// Init resulting data

      CVectorData < _FltVect > qxloc (_nrhs * nrowstot + 1);

      _FltVect *pqxloc = qxloc.Ptr ();

      int i;

      for (i = 0; i < _nrhs; i++) {
         if (_b_use_threads) {
            CVector < _FltVect >::CopyVector_thr (nrowstot, _x + i * _ldx,
                                                  pqxloc + i * nrowstot);
         } else {
            CVector < _FltVect >::CopyVector (nrowstot, _x + i * _ldx,
                                              pqxloc + i * nrowstot);
         }
      }

      if (_b_use_threads) {
         MvmQH_thr (_nrhs, pqxloc, nrowstot);
      } else {
         MvmQH (_nrhs, pqxloc, nrowstot);
      }

      for (i = 0; i < _nrhs; i++) {
         if (_b_use_threads) {
            CVector < _FltVect >::CopyVector_thr (ncolstot, pqxloc + i * nrowstot,
                                                  _qx + i * _ldqx);
         } else {
            CVector < _FltVect >::CopyVector (ncolstot, pqxloc + i * nrowstot,
                                              _qx + i * _ldqx);
         }
      }

   }

///
/// @brief Get R part of the QR decomposition
//========================================================================================
   template < typename _FltVect > void CQrdBase < _FltVect >::GetRQrd (int _ibegc,
                                                                       int _iendc,
                                                                       int _ibegr,
                                                                       int _iendr,
                                                                       _FltVect * _r,
                                                                       int _ldr)
   {

      int i;

      int njloc = _iendc - _ibegc + 1;
      int niloc = _iendr - _ibegr + 1;

      for (i = 0; i < njloc; i++) {
         CVector < _FltVect >::SetByZeroes (niloc, _r + i * _ldr);
      }

      int ibegrloc = _ibegr;
      if (ibegrloc > _iendc)
         ibegrloc = -1;

      int iendrloc = _iendr;
      if (iendrloc > _iendc)
         iendrloc = _iendc;

      if (ibegrloc >= 0) {
         this->GetRQrd_impl (_ibegc, _iendc, ibegrloc, iendrloc, _r, _ldr);
      }

   }

///
/// @brief Get R part of the QR decomposition
//========================================================================================
   template < typename _FltVect > void CQrdBase < _FltVect >::GetRQrd_impl (int _ibegc,
                                                                            int _iendc,
                                                                            int _ibegr,
                                                                            int _iendr,
                                                                            _FltVect * _r,
                                                                            int _ldr)
   {

      int i;

      int *pqblksc = &qblksc[0];
      int *pnrowarr = &nrowarr[0];
      CVectorData < _FltVect > *pqarr = &qarr[0];

      int iblk, jbegloc, jendloc, iloc, ishift, ibegloc, iendloc, niiloc;
      _FltVect *qtemp;

      for (iblk = 0; iblk < nqblk; iblk++) {
         jbegloc = pqblksc[iblk];
         jendloc = pqblksc[iblk + 1] - 1;
         if (jendloc >= _ibegc && jbegloc <= _iendc) {
            for (i = pqblksc[iblk]; i < pqblksc[iblk + 1]; i++) {
               if (i >= _ibegc && i <= _iendc) {
                  iloc = i - _ibegc;
                  ishift = i - pqblksc[iblk];
                  qtemp = pqarr[iblk].Ptr () + ishift * pnrowarr[iblk];
                  ibegloc = _ibegr;
                  if (ibegloc > i)
                     ibegloc = i + 1;
                  iendloc = _iendr;
                  if (iendloc > i)
                     iendloc = i;
                  niiloc = iendloc - ibegloc + 1;
                  if (niiloc > 0) {
                     CVector < _FltVect >::CopyVector (niiloc, qtemp + ibegloc,
                                                       _r + iloc * _ldr);
                  }
               }
            }
         }
      }

   }

///
/// @Store R part of the QR decomposition
//========================================================================================
   template < typename _FltVect > void CQrdBase < _FltVect >::StoreR (int _ibegc,
                                                                      int _iendc,
                                                                      int _ibegr,
                                                                      int _iendr,
                                                                      _FltVect * _r,
                                                                      int _ldr)
   {

      int *pqblksc = &qblksc[0];
      int *pncolarr_alloc = &ncolarr_alloc[0];
      int *pnrowarr = &nrowarr[0];
      int *pnrowarr_alloc = &nrowarr_alloc[0];
      CVectorData < _FltVect > *pqarr = &qarr[0];
      vector < _FltVect > *ptauarr = &tauarr[0];

      if (_ibegc != pqblksc[nqblk]) {
         throw " CQrdBase<_FltVect>::StoreR: error in input data !!! ";
      }

      int ncol_loc = _iendc - _ibegc + 1;

      if (ncol_loc <= 0) {
         throw " CQrdBase<_FltVect>::StoreR: error 2 in input data !!! ";
      }

      if (_ibegr > _iendr) {
         throw " CQrdBase<_FltVect>::StoreR: error 3 in input data !!! ";
      }

      if (_iendr > pqblksc[nqblk] + ncol_loc - 1) {
         throw " CQrdBase<_FltVect>::StoreR: error 4 in input data !!! ";
      }

      int i;

      int ncol_new = pqblksc[nqblk] + ncol_loc;

      CVectorData < _FltVect > q_store (ncol_loc * ncol_new + 1);
      vector < _FltVect > tau_store (ncol_loc + 1);

      _FltVect *pq_store = q_store.Ptr ();
      _FltVect *ptau_store = &tau_store[0];

      CVector < _FltVect >::SetByZeroes (ncol_loc * ncol_new, pq_store);
      CVector < _FltVect >::SetByZeroes (ncol_loc, ptau_store);

      {

         if (nqblk_alloc == nqblk) {
            int nqblk_alloc_new = nqblk + 10;
            {
               vector < int >iarr (nqblk_alloc_new + 1);
               int *piarr = &iarr[0];
               for (i = 0; i <= nqblk; i++)
                  piarr[i] = pqblksc[i];
               qblksc.swap (iarr);
               pqblksc = piarr;
            }
            pqblksc[0] = 0;
            {
               vector < int >iarr (nqblk_alloc_new + 1);
               int *piarr = &iarr[0];
               for (i = 0; i < nqblk; i++)
                  piarr[i] = pncolarr_alloc[i];
               ncolarr_alloc.swap (iarr);
               pncolarr_alloc = piarr;
            }
            pncolarr_alloc[nqblk] = ncol_loc;
            {
               vector < int >iarr (nqblk_alloc_new + 1);
               int *piarr = &iarr[0];
               for (i = 0; i < nqblk; i++)
                  piarr[i] = pnrowarr[i];
               nrowarr.swap (iarr);
               pnrowarr = piarr;
            }
            {
               vector < int >iarr (nqblk_alloc_new + 1);
               int *piarr = &iarr[0];
               for (i = 0; i < nqblk; i++)
                  piarr[i] = pnrowarr_alloc[i];
               nrowarr_alloc.swap (iarr);
               pnrowarr_alloc = piarr;
            }
            pnrowarr_alloc[nqblk] = ncol_new;
            {
               vector < CVectorData < _FltVect > >setarr (nqblk_alloc_new + 1);
               CVectorData < _FltVect > *psetarr = &setarr[0];
               for (i = 0; i < nqblk; i++)
                  psetarr[i].swap (pqarr[i]);
               qarr.swap (setarr);
               pqarr = psetarr;
            }
            for (i = nqblk + 1; i < nqblk_alloc_new; i++) {
               pnrowarr_alloc[i] = 0;
               pncolarr_alloc[i] = 0;
               pnrowarr[i] = 0;
            }
            {
               vector < vector < _FltVect > >setarr (nqblk_alloc_new + 1);
               vector < _FltVect > *psetarr = &setarr[0];
               for (i = 0; i < nqblk; i++)
                  psetarr[i].swap (ptauarr[i]);
               tauarr.swap (setarr);
               ptauarr = psetarr;
            }
            nqblk_alloc = nqblk_alloc_new;
         } else {
            pncolarr_alloc[nqblk] = ncol_loc;
            pnrowarr_alloc[nqblk] = ncol_new;
         }
         pqblksc[nqblk + 1] = pqblksc[nqblk] + ncol_loc;
         pnrowarr[nqblk] = ncol_new;
         pqarr[nqblk].swap (q_store);
         ptauarr[nqblk].swap (tau_store);
         nqblk++;

      }

      pqblksc = &qblksc[0];
      pnrowarr = &nrowarr[0];
      pqarr = &qarr[0];

      int iblk, jbegloc, jendloc, iloc, ishift, ibegloc, iendloc, niiloc;
      _FltVect *qtemp;

      for (iblk = 0; iblk < nqblk; iblk++) {
         jbegloc = pqblksc[iblk];
         jendloc = pqblksc[iblk + 1] - 1;
         if (jendloc >= _ibegc && jbegloc <= _iendc) {
            for (i = pqblksc[iblk]; i < pqblksc[iblk + 1]; i++) {
               if (i >= _ibegc && i <= _iendc) {
                  iloc = i - _ibegc;
                  ishift = i - pqblksc[iblk];
                  qtemp = pqarr[iblk].Ptr () + ishift * pnrowarr[iblk];
                  ibegloc = _ibegr;
                  if (ibegloc > i)
                     ibegloc = i + 1;
                  iendloc = _iendr;
                  if (iendloc > i)
                     iendloc = i;
                  niiloc = iendloc - ibegloc + 1;
                  if (niiloc > 0) {
                     CVector < _FltVect >::CopyVector (niiloc, _r + iloc * _ldr,
                                                       qtemp + ibegloc);
                  }
               }
            }
         }
      }

   }

///
/// @brief Update QR decomposition in the head structure
//========================================================================================
   template < typename _FltVect > void CQrdSet < _FltVect >::UpdateQrdHead (int _ncol)
   {

// Check that data are correct

      int ncols_head = pqrd_head->GetNCols ();

      int i, ncolsloc;

      for (i = 0; i < nqrdsets; i++) {
         ncolsloc = ppqrd_childs[i]->GetNCols ();
         if (ncolsloc != ncols_head + _ncol) {
            throw
               " CQrdSet<_FltVect>::UpdateQrdHead: incorrect number of columns on entry ";
         }
      }

// Allocate and init data for QRD

      ncolsloc = ncols_head + _ncol;

      int ldablk = ncolsloc * nqrdsets;

      vector < _FltVect > ablk (ldablk * _ncol + 1);
      vector < _FltVect > rblk (ncolsloc * _ncol + 1);

      _FltVect *pablk = &ablk[0];
      _FltVect *prblk = &rblk[0];

      CVector < _FltVect >::SetByZeroes (ldablk * _ncol, pablk);

      int kii, kjj, ibsabeg, ibsrbeg, ibsa, ibsr;

      for (i = 0; i < nqrdsets; i++) {

         ppqrd_childs[i]->GetRQrd (ncols_head, ncolsloc - 1, 0, ncolsloc - 1, prblk,
                                   ncolsloc);

         for (kjj = 0; kjj < _ncol; kjj++) {
            ibsabeg = kjj * ldablk + i;
            ibsrbeg = kjj * ncolsloc;
            for (kii = 0; kii < ncolsloc; kii++) {
               ibsa = ibsabeg + kii * nqrdsets;
               ibsr = ibsrbeg + kii;
               pablk[ibsa] = prblk[ibsr];
            }
         }

      }

// Update QRD

      pqrd_head->UpdateQrdBlk (_ncol, ldablk, pablk, ldablk);

   }

///
/// @brief Multiply by Q factor from the head and transform the result for subsequent child multiply
//========================================================================================
   template < typename _FltVect > void CQrdSet < _FltVect >::MvmQ (int _nrhs,
                                                                   _FltVect * _x,
                                                                   int _ldx,
                                                                   _FltVect * _qx,
                                                                   int _ldqx)
   {

// Check that data are correct

      int ncols_head = pqrd_head->GetNCols ();

      int i, ncolsloc;

      for (i = 0; i < nqrdsets; i++) {
         ncolsloc = ppqrd_childs[i]->GetNCols ();
         if (ncolsloc != ncols_head)
            throw " CQrdSet<_FltVect>::MvmQ: incorrect number of columns in childs QR ";
      }

      if (_ldx < ncols_head)
         throw " CQrdSet<_FltVect>::MvmQ: incorrect ldx ";
      if (_ldqx < ncols_head * nqrdsets)
         throw " CQrdSet<_FltVect>::MvmQ: incorrect ldqx ";

// Allocate data

      ncolsloc = ncols_head;

      int ldqxblk = ncolsloc * nqrdsets;

      vector < _FltVect > qxblk (ldqxblk * _nrhs + 1);

      _FltVect *pqxblk = &qxblk[0];

// Multiply

      pqrd_head->MvmQ (_nrhs, ldqxblk, _x, _ldx, pqxblk, ldqxblk);

// Store data

      int kii, kjj, ibsqxbegloc, ibsqxbeg, ibsqxloc, ibsqx;

      for (i = 0; i < nqrdsets; i++) {

         for (kjj = 0; kjj < _nrhs; kjj++) {
            ibsqxbegloc = kjj * ldqxblk + i;
            ibsqxbeg = kjj * _ldqx + i * ncolsloc;
            for (kii = 0; kii < ncolsloc; kii++) {
               ibsqxloc = ibsqxbegloc + kii * nqrdsets;
               ibsqx = ibsqxbeg + kii;
               _qx[ibsqx] = pqxblk[ibsqxloc];
            }
         }

      }

   }

///
/// @brief Init the structure
//========================================================================================
   template < typename _FltVect > void CQrdMPI < _FltVect >::Init (void *_pComm,
                                                                   int _ni_myid)
   {

      this->pComm = _pComm;

      int nproc = CMPIDataExchange::GetNproc (_pComm);
      int myid = CMPIDataExchange::GetMyid (_pComm);

      CTree treeloc (nproc, 2);

      this->treeMPI = treeloc;

      int nnodes = this->treeMPI.GetNnodes ();
      int *pnchilds = this->treeMPI.GetNchilds ();
      vector < int >*pchilds_list = this->treeMPI.GetChildsList ();

      this->nd2cpu.resize (nnodes + 1);
      this->cpu2nd.resize (nproc + 1);

      int *pnd2cpu = &this->nd2cpu[0];
      int *pcpu2nd = &this->cpu2nd[0];

      int i, nchildsloc, j, inode;

      int iproc = 0;

      for (i = 0; i < nnodes; i++) {

         nchildsloc = pnchilds[i];

         if (nchildsloc == 1) {
            pnd2cpu[i] = iproc;
            pcpu2nd[iproc] = i;
            iproc++;
         } else {
            pnd2cpu[i] = -1;
         }

      }

      if (iproc != nproc) {
         throw " CQrdMPI<_FltVect>::Init: error in number of kernel nodes ";
      }

      for (i = 0; i < nnodes; i++) {

         nchildsloc = pnchilds[i];

         if (nchildsloc > 1) {

            int *ppchilds_list = &pchilds_list[i][0];

            inode = ppchilds_list[0];

            pnd2cpu[i] = pnd2cpu[inode];

         }

      }

      this->node_myid_up = -1;

      for (i = 0; i < nnodes; i++) {
         if (pnd2cpu[i] == myid)
            this->node_myid_up = i;
      }

      CQrdSet < _FltVect > *pqrd_sets_loc = new CQrdSet < _FltVect >[nnodes + 1];
      CQrdBase < _FltVect > *pqrd_childs_loc = new CQrdBase < _FltVect >[nnodes + 1];
      CQrdBase < _FltVect > **ppqrd_childs_loc = new CQrdBase < _FltVect > *[nnodes + 1];

      pqrd_sets = pqrd_sets_loc;
      pqrd_childs = pqrd_childs_loc;
      ppqrd_childs = ppqrd_childs_loc;

      int ibs = 0;

      for (i = 0; i < nnodes; i++) {

         nchildsloc = pnchilds[i];

         if (nchildsloc > 1) {

            int *ppchilds_list = &pchilds_list[i][0];

            pqrd_sets_loc[i].SetNqrdsets (nchildsloc);

            pqrd_sets_loc[i].SetPQrdHead (pqrd_childs_loc + i);

            for (j = 0; j < nchildsloc; j++) {
               inode = ppchilds_list[j];
               ppqrd_childs_loc[ibs + j] = pqrd_childs_loc + inode;
            }

            pqrd_sets_loc[i].SetPPQrdChilds (ppqrd_childs_loc + ibs);

            ibs += nchildsloc;

         }

      }

      this->ni_myid = _ni_myid;

   }

/// @brief Get the current number of columns
//========================================================================================
   template < typename _FltVect > int CQrdMPI < _FltVect >::GetNCols ()
   {

      int myid = CMPIDataExchange::GetMyid (this->pComm);

      int node_myid = this->cpu2nd[myid];

      CQrdBase < _FltVect > *pqrd_childs_loc = this->pqrd_childs;

      int ncols = pqrd_childs_loc[node_myid].GetNCols ();

      return ncols;

   }

/// @brief Update QR decomposition for the current block
//========================================================================================
   template < typename _FltVect > void CQrdMPI < _FltVect >::UpdateQrdMPI (int _ncol,
                                                                           int _nrows,
                                                                           _FltVect *
                                                                           _ablk,
                                                                           int _lda)
   {

      this->UpdateQrdMPI_impl (false, _ncol, _nrows, _ablk, _lda);

   }

/// @brief Update QR decomposition for the current block (threads version)
//========================================================================================
   template < typename _FltVect > void CQrdMPI < _FltVect >::UpdateQrdMPI_thr (int _ncol,
                                                                               int _nrows,
                                                                               _FltVect *
                                                                               _ablk,
                                                                               int _lda)
   {

      this->UpdateQrdMPI_impl (true, _ncol, _nrows, _ablk, _lda);

   }

/// @brief Update QR decomposition for the current block (implementation)
//========================================================================================
   template < typename _FltVect > void CQrdMPI <
      _FltVect >::UpdateQrdMPI_impl (bool _b_use_threads, int _ncol, int _nrows,
                                     _FltVect * _ablk, int _lda)
   {

      int myid = CMPIDataExchange::GetMyid (this->pComm);

// Check data on entry

      if (this->ni_myid != _nrows)
         throw " CQrdMPI<_FltVect>::UpdateQrdMPI: incorrect row size ";

// Update local QR

      int node_myid = this->cpu2nd[myid];

      CQrdBase < _FltVect > *pqrd_childs_loc = this->pqrd_childs;

      if (_b_use_threads) {
         pqrd_childs_loc[node_myid].UpdateQrdBlk_thr (_ncol, _nrows, _ablk, _lda);
      } else {
         pqrd_childs_loc[node_myid].UpdateQrdBlk (_ncol, _nrows, _ablk, _lda);
      }

// Allocate work send/recv memory

      int ncols_tot = pqrd_childs_loc[node_myid].GetNCols ();

      vector < _FltVect > rloc (ncols_tot * _ncol + 1);
      _FltVect *prloc = &rloc[0];

// Perform MPI based parallel computations

      CQrdSet < _FltVect > *pqrd_sets_loc = this->pqrd_sets;

      int *pnchilds = this->treeMPI.GetNchilds ();
      int *pfather = this->treeMPI.GetFather ();
      vector < int >*pchilds_list = this->treeMPI.GetChildsList ();

      int inode, ifather, nchildsloc, inode1, iproc, j;

      inode = node_myid;

      while (true) {

         ifather = pfather[inode];

         if (ifather == inode)
            break;

         if (this->nd2cpu[ifather] == myid) {

            nchildsloc = pnchilds[ifather];

            int *ppchilds_list = &pchilds_list[ifather][0];

            for (j = 0; j < nchildsloc; j++) {

               inode1 = ppchilds_list[j];
               iproc = this->nd2cpu[inode1];

               if (iproc != myid) {

                  int isize = ncols_tot * _ncol * sizeof (_FltVect);

                  CMPIDataExchange::Recv (this->pComm, iproc, inode1, isize,
                                          (char *) (prloc));

                  pqrd_childs_loc[inode1].StoreR (ncols_tot - _ncol, ncols_tot - 1, 0,
                                                  ncols_tot - 1, prloc, ncols_tot);

               }

            }

            pqrd_sets_loc[ifather].UpdateQrdHead (_ncol);

            inode = ifather;

         } else {

            iproc = this->nd2cpu[ifather];

            pqrd_childs_loc[inode].GetRQrd (ncols_tot - _ncol, ncols_tot - 1, 0,
                                            ncols_tot - 1, prloc, ncols_tot);

            int isize = ncols_tot * _ncol * sizeof (_FltVect);

            CMPIDataExchange::Send (this->pComm, iproc, inode, isize, (char *) (prloc));

            break;

         }

      }

   }

/// @brief Multiply by Q
//========================================================================================
   template < typename _FltVect > void CQrdMPI < _FltVect >::MvmQMPI (int _nrhs,
                                                                      _FltVect * _x,
                                                                      int _ldx,
                                                                      _FltVect * _qx,
                                                                      int _ldqx)
   {

      this->MvmQMPI_impl (false, _nrhs, _x, _ldx, _qx, _ldqx);

   }

/// @brief Multiply by Q (threads version)
//========================================================================================
   template < typename _FltVect > void CQrdMPI < _FltVect >::MvmQMPI_thr (int _nrhs,
                                                                          _FltVect * _x,
                                                                          int _ldx,
                                                                          _FltVect * _qx,
                                                                          int _ldqx)
   {

      this->MvmQMPI_impl (true, _nrhs, _x, _ldx, _qx, _ldqx);

   }

/// @brief Multiply by Q (implementation)
//========================================================================================
   template < typename _FltVect > void CQrdMPI <
      _FltVect >::MvmQMPI_impl (bool _b_use_threads, int _nrhs, _FltVect * _x, int _ldx,
                                _FltVect * _qx, int _ldqx)
   {

      int myid = CMPIDataExchange::GetMyid (this->pComm);

// Check data on entry

      int node_myid = this->cpu2nd[myid];

      CQrdBase < _FltVect > *pqrd_childs_loc = this->pqrd_childs;
      CQrdSet < _FltVect > *pqrd_sets_loc = this->pqrd_sets;

      int *pnchilds = this->treeMPI.GetNchilds ();
      int *pfather = this->treeMPI.GetFather ();
      vector < int >*pchilds_list = this->treeMPI.GetChildsList ();

      int ncols_head = pqrd_childs_loc[node_myid].GetNCols ();

      if (myid == 0)
         if (ncols_head > _ldx)
            throw " CQrdMPI<_FltVect>::MvmQMPI: incorrect ldx on entry ";
      if (this->ni_myid > _ldqx)
         throw " CQrdMPI<_FltVect>::MvmQMPI: incorrect ldqx on entry ";

// Perform initial work on 0 cpu

      vector < _FltVect > qx_sndrcv (ncols_head * _nrhs + 1);

      _FltVect *pqx_sndrcv = &qx_sndrcv[0];

      int j;

      if (myid == 0) {
         for (j = 0; j < _nrhs; j++) {
            CVector < _FltVect >::CopyVector (ncols_head, _x + j * _ldx,
                                              pqx_sndrcv + j * ncols_head);
         }
      }

      int inode, inode1, iproc, nchildsloc, ifather, ichild, ibeg, k;

      inode = this->node_myid_up;

      while (true) {

         ifather = pfather[inode];

         if (this->nd2cpu[ifather] != myid) {

            iproc = this->nd2cpu[ifather];

            int isize = ncols_head * _nrhs * sizeof (_FltVect);

            CMPIDataExchange::Recv (this->pComm, iproc, ifather, isize,
                                    (char *) (pqx_sndrcv));

         }

         nchildsloc = pnchilds[inode];

         if (nchildsloc == 1)
            break;

         int ldqxloc = ncols_head * nchildsloc;

         vector < _FltVect > qxblk (ldqxloc * _nrhs + 1);

         _FltVect *pqxblk = &qxblk[0];

         pqrd_sets_loc[inode].MvmQ (_nrhs, pqx_sndrcv, ncols_head, pqxblk, ldqxloc);

         int *ppchilds_list = &pchilds_list[inode][0];

         for (j = 0; j < nchildsloc; j++) {

            inode1 = ppchilds_list[j];
            iproc = this->nd2cpu[inode1];

            if (iproc != myid) {

               ibeg = ncols_head * j;

               for (k = 0; k < _nrhs; k++) {
                  CVector < _FltVect >::CopyVector (ncols_head,
                                                    pqxblk + k * ldqxloc + ibeg,
                                                    pqx_sndrcv + k * ncols_head);
               }

               int isize = ncols_head * _nrhs * sizeof (_FltVect);

               CMPIDataExchange::Send (this->pComm, iproc, inode, isize,
                                       (char *) pqx_sndrcv);

            }

         }

         ichild = -1;

         for (j = 0; j < nchildsloc; j++) {

            inode1 = ppchilds_list[j];
            iproc = this->nd2cpu[inode1];

            if (iproc == myid) {

               ichild = inode1;

               ibeg = ncols_head * j;

               for (k = 0; k < _nrhs; k++) {
                  CVector < _FltVect >::CopyVector (ncols_head,
                                                    pqxblk + k * ldqxloc + ibeg,
                                                    pqx_sndrcv + k * ncols_head);
               }

            }

         }

         inode = ichild;

      }

// Perform local multiplications

      if (_b_use_threads) {
         pqrd_childs_loc[node_myid].MvmQ_thr (_nrhs, this->ni_myid, pqx_sndrcv,
                                              ncols_head, _qx, _ldqx);
      } else {
         pqrd_childs_loc[node_myid].MvmQ (_nrhs, this->ni_myid, pqx_sndrcv, ncols_head,
                                          _qx, _ldqx);
      }

   }

/// @brief Get R part
//========================================================================================
   template < typename _FltVect > void CQrdMPI < _FltVect >::GetRQrdMPI (int _ibegc,
                                                                         int _iendc,
                                                                         int _ibegr,
                                                                         int _iendr,
                                                                         _FltVect * _r,
                                                                         int _ldr)
   {

      int myid = CMPIDataExchange::GetMyid (this->pComm);

// Update local QR

      if (myid == 0) {

         int root_id = treeMPI.GetRootId ();

         CQrdBase < _FltVect > *pqrd_childs_loc = this->pqrd_childs;

         pqrd_childs_loc[root_id].GetRQrd (_ibegc, _iendc, _ibegr, _iendr, _r, _ldr);

      } else {
         throw
            " CQrdMPI<_FltVect>::GetRQrdMPI: error: this function must be called only on zero cpu ! ";
      }

   }

/// @brief Get R part
//========================================================================================
   template < typename _FltVect > void CQrdMPI < _FltVect >::FreeQrdMPI ()
   {

      int nnodes_loc = treeMPI.GetNnodes ();

      CQrdBase < _FltVect > *pqrd_childs_loc = this->pqrd_childs;

      int i;

      for (i = 0; i < nnodes_loc; i++) {
         pqrd_childs_loc[i].SetNqblk (0);
      }

   }

// Init MvmA data
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CMvmPar < _Int, _Flt,
      _FltVect >::InitMvmA (CBMatrix < _Int, _Flt > *_hmatr_arr)
   {

// Get control data

      void *pcomm_loc = this->pcomm;

      int nblks_loc = this->nblks;
      long long *pblks_loc = this->pblks;
      int *pblk2cpu_loc = this->pblk2cpu;
      int *pibsblk_loc = &this->ibsblk[0];
      int nlistblk_own_loc = this->nlistblk_own;
      int *plistblk_own_loc = &this->listblk_own[0];

      int nproc = CMPIDataExchange::GetNproc (pcomm_loc);
      int myid = CMPIDataExchange::GetMyid (pcomm_loc);

// Compute maximal block size

      int nimax = 0;

      int i, niloc;

      for (i = 0; i < nblks_loc; i++) {
         niloc = (int) (pblks_loc[i + 1] - pblks_loc[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

// Store Ptr to matrix data

      this->phmatr = _hmatr_arr;

// Compute list of external blocks

      vector < int >imaskblk (nblks_loc + 1);
      vector < int >listblk (nblks_loc + 1);
      vector < int >indblk (nblks_loc + 1);

      int *pimaskblk = &imaskblk[0];
      int *plistblk = &listblk[0];
      int *pindblk = &indblk[0];

      for (i = 0; i < nblks_loc; i++)
         pimaskblk[i] = -1;

      int icycleblk = -1;

      int j, iblk, jblk;

      icycleblk++;

      int nlistblk_ext = 0;

      for (i = 0; i < nlistblk_own_loc; i++) {
         iblk = plistblk_own_loc[i];
         CMatrix < int, float >*phmatr_str_loc = _hmatr_arr[iblk].GetHMatrStr ();
         int nzja_hblk = phmatr_str_loc->GetNzja ();
         int *pja_hblk = phmatr_str_loc->GetJaArr ();
         for (j = 0; j < nzja_hblk; j++) {
            jblk = pja_hblk[j];
            if (pblk2cpu_loc[jblk] != myid && pimaskblk[jblk] != icycleblk) {
               plistblk[nlistblk_ext] = jblk;
               nlistblk_ext++;
               pimaskblk[jblk] = icycleblk;
            }
         }
      }

      sort (plistblk, plistblk + nlistblk_ext);

      for (i = 0; i < nlistblk_ext; i++) {
         iblk = plistblk[i];
         pindblk[iblk] = i;
      }

      this->nblks_recvs = nlistblk_ext;
      this->listblk_recvs.resize (nlistblk_ext + 1);

      int *plistblk_recvs = &this->listblk_recvs[0];

      for (i = 0; i < nlistblk_ext; i++)
         plistblk_recvs[i] = plistblk[i];

// Compute the set of indices to be received and multiplications lists

      vector < int >ia_list_rcv (nlistblk_ext + 1);
      vector < vector < int > >ja_pair_rcv (nlistblk_ext + 1);

      int *pia_list_rcv = &ia_list_rcv[0];
      vector < int >*pja_pair_rcv = &ja_pair_rcv[0];

      for (i = 0; i <= nlistblk_ext; i++)
         pia_list_rcv[i] = 0;

      int ind;

      for (i = 0; i < nlistblk_own_loc; i++) {
         iblk = plistblk_own_loc[i];
         CMatrix < int, float >*phmatr_str_loc = _hmatr_arr[iblk].GetHMatrStr ();
         int nzja_hblk = phmatr_str_loc->GetNzja ();
         int *pja_hblk = phmatr_str_loc->GetJaArr ();
         for (j = 0; j < nzja_hblk; j++) {
            jblk = pja_hblk[j];
            if (pblk2cpu_loc[jblk] != myid) {
               ind = pindblk[jblk];
               pja_pair_rcv[ind].push_back (iblk);
               pja_pair_rcv[ind].push_back (j);
               pia_list_rcv[ind + 1]++;
            }
         }
      }

      for (i = 0; i < nlistblk_ext; i++)
         pia_list_rcv[i + 1] = pia_list_rcv[i] + pia_list_rcv[i + 1];

      this->ialist_recvs.resize (nlistblk_ext + 1);

      int *pialist_recvs = &this->ialist_recvs[0];

      for (i = 0; i <= nlistblk_ext; i++)
         pialist_recvs[i] = pia_list_rcv[i];

      int nzja_pairs = pialist_recvs[nlistblk_ext];

      this->japairs_recvs.resize (2 * nzja_pairs + 1);

      int *pjapairs_recvs = &this->japairs_recvs[0];

      int ibeg, jloc;

      for (i = 0; i < nlistblk_ext; i++) {
         int *ppja_pair_rcv = &(pja_pair_rcv[i][0]);
         ibeg = pia_list_rcv[i];
         for (j = pia_list_rcv[i]; j < pia_list_rcv[i + 1]; j++) {
            jloc = j - ibeg;
            pjapairs_recvs[j * 2] = ppja_pair_rcv[jloc * 2];
            pjapairs_recvs[j * 2 + 1] = ppja_pair_rcv[jloc * 2 + 1];
         }
      }

      vector < int >imask_work (nimax + 1);
      vector < int >list_work (nimax + 1);

      int *pimask_work = &imask_work[0];
      int *plist_work = &list_work[0];

      for (i = 0; i < nimax; i++)
         pimask_work[i] = -1;

      int icycle_work = -1;

      vector < int >ia_blk_rcv (nlistblk_ext + 1);
      vector < vector < int > >ja_blk_rcv (nlistblk_ext + 1);

      int *pia_blk_rcv = &ia_blk_rcv[0];
      vector < int >*pja_blk_rcv = &ja_blk_rcv[0];

      for (i = 0; i <= nlistblk_ext; i++)
         pia_blk_rcv[i] = 0;

      int nlistloc, k, jj;

      for (i = 0; i < nlistblk_ext; i++) {
         icycle_work++;
         nlistloc = 0;
         for (j = pialist_recvs[i]; j < pialist_recvs[i + 1]; j++) {
            iblk = pjapairs_recvs[j * 2];
            ind = pjapairs_recvs[j * 2 + 1];
            CMatrix < _Int, _Flt > *pasub_loc = _hmatr_arr[iblk].GetASubArr ();
            int nzjaloc = pasub_loc[ind].GetNzja ();
            _Int *pjaloc = pasub_loc[ind].GetJaArr ();
            for (k = 0; k < nzjaloc; k++) {
               jj = (int) pjaloc[k];
               if (pimask_work[jj] != icycle_work) {
                  plist_work[nlistloc] = jj;
                  nlistloc++;
                  pimask_work[jj] = icycle_work;
               }
            }
         }
         sort (plist_work, plist_work + nlistloc);
         pia_blk_rcv[i + 1] = nlistloc;
         pja_blk_rcv[i].resize (nlistloc + 1);
         int *ppja_blk_rcv = &(pja_blk_rcv[i][0]);
         for (j = 0; j < nlistloc; j++)
            ppja_blk_rcv[j] = plist_work[j];
      }

      for (i = 0; i < nlistblk_ext; i++)
         pia_blk_rcv[i + 1] = pia_blk_rcv[i] + pia_blk_rcv[i + 1];

      this->iablk_recvs.resize (nlistblk_ext + 1);

      int *piablk_recvs = &this->iablk_recvs[0];

      for (i = 0; i <= nlistblk_ext; i++)
         piablk_recvs[i] = pia_blk_rcv[i];

      int nzja_ind = pia_blk_rcv[nlistblk_ext];

      this->ind_recvs.resize (nzja_ind + 1);

      int *pind_recvs = &this->ind_recvs[0];

      for (i = 0; i < nlistblk_ext; i++) {
         int *ppja_pair_rcv = &(pja_blk_rcv[i][0]);
         ibeg = pia_blk_rcv[i];
         for (j = pia_blk_rcv[i]; j < pia_blk_rcv[i + 1]; j++) {
            jloc = j - ibeg;
            pind_recvs[j] = ppja_pair_rcv[jloc];
         }
      }

      this->x_recv.resize (nzja_ind + 1);

// Finally create cpu recv data

      vector < int >imaskcpu (nproc);
      vector < int >listcpu (nproc);
      vector < int >indcpu (nproc);

      int *pimaskcpu = &imaskcpu[0];
      int *plistcpu = &listcpu[0];
      int *pindcpu = &indcpu[0];

      for (i = 0; i < nproc; i++)
         pimaskcpu[i] = -1;

      int icyclecpu = -1;

      icyclecpu++;

      int nlistcpu = 0;

      int jcpu;

      for (i = 0; i < nlistblk_ext; i++) {
         jblk = plistblk_recvs[i];
         jcpu = pblk2cpu_loc[jblk];
         if (pimaskcpu[jcpu] != icyclecpu) {
            plistcpu[nlistcpu] = jcpu;
            nlistcpu++;
            pimaskcpu[jcpu] = icyclecpu;
         }
      }

      sort (plistcpu, plistcpu + nlistcpu);

      for (i = 0; i < nlistcpu; i++) {
         jcpu = plistcpu[i];
         pindcpu[jcpu] = i;
      }

      this->nrecvs = nlistcpu;

      this->rcv2cpu.resize (nlistcpu + 1);
      this->ia_recvs.resize (nlistcpu + 1);
      this->ja_recvs.resize (2 * nzja_ind + 1);

      int *prcv2cpu = &this->rcv2cpu[0];
      int *pia_recvs = &this->ia_recvs[0];
      int *pja_recvs = &this->ja_recvs[0];

      for (i = 0; i < nlistcpu; i++)
         prcv2cpu[i] = plistcpu[i];
      for (i = 0; i <= nlistcpu; i++)
         pia_recvs[i] = 0;

      for (i = 0; i < nlistblk_ext; i++) {
         jblk = plistblk_recvs[i];
         jcpu = pblk2cpu_loc[jblk];
         ind = pindcpu[jcpu];
         pia_recvs[ind + 1] += (pia_blk_rcv[i + 1] - pia_blk_rcv[i]);
      }

      for (i = 0; i < nlistcpu; i++)
         pia_recvs[i + 1] = pia_recvs[i] + pia_recvs[i + 1];

      for (i = 0; i < nlistcpu; i++)
         plistcpu[i] = pia_recvs[i];

      for (i = 0; i < nlistblk_ext; i++) {
         jblk = plistblk_recvs[i];
         jcpu = pblk2cpu_loc[jblk];
         ind = pindcpu[jcpu];
         k = plistcpu[ind];
         for (j = pia_blk_rcv[i]; j < pia_blk_rcv[i + 1]; j++) {
            jj = pind_recvs[j];
            pja_recvs[k * 2] = jj;
            pja_recvs[k * 2 + 1] = jblk;
            pind_recvs[j] = k;
            k++;
         }
         plistcpu[ind] = k;
      }

// Prepare exchange data

      vector < CBMatrix < int, _Flt > >hblk_send (nlistcpu + 1);

      CBMatrix < int, _Flt > *phblk_send = &hblk_send[0];

      for (i = 0; i < nlistcpu; i++) {
         phblk_send[i].SetNzblk (1);
         phblk_send[i].ResizeASub (1);
         CMatrix < int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
         CMatrix < int, _Flt > ablk_temp;
         int niloc = pia_recvs[i + 1] - pia_recvs[i];
         ablk_temp.ResizeAndSetAllSp (0, 0, niloc * 2, 0);
         int *pjaloc = ablk_temp.GetJaArr ();
         ibeg = pia_recvs[i];
         for (j = pia_recvs[i]; j < pia_recvs[i + 1]; j++) {
            jloc = j - ibeg;
            pjaloc[jloc * 2] = pja_recvs[j * 2];
            pjaloc[jloc * 2 + 1] = pja_recvs[j * 2 + 1];
         }
         pA_sub->ReplaceFree (ablk_temp);
      }

// Pack send data

      vector < int >CpuIDSend (nlistcpu);
      vector < vector < char > >ObjSend (nlistcpu);

      int *pCpuIDSend = NULL;
      vector < char >*pObjSend = NULL;

      if (nlistcpu > 0) {

         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];

      }

      long long isize;
      char *pobj;

      for (i = 0; i < nlistcpu; i++) {
         pCpuIDSend[i] = prcv2cpu[i];
         isize = phblk_send[i].GetPackedSize ();
         pObjSend[i].resize ((size_t) isize);
         pobj = &(pObjSend[i][0]);
         phblk_send[i].FillPacked (isize, pobj);
         phblk_send[i].Clean ();
      }

// Exchange

      vector < int >CpuIDRecv;
      vector < vector < char > >ObjRecv;

      CMPIDataExchange::DataExchange (pcomm_loc, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      int nrecv_loc = (int) CpuIDRecv.size ();

      vector < char >*pObjRecv = NULL;
      int *pCpuIDRecv = NULL;

      if (nrecv_loc > 0) {
         pObjRecv = &ObjRecv[0];
         pCpuIDRecv = &CpuIDRecv[0];
      }

      vector < CBMatrix < int, _Flt > >hblk_recv (nrecv_loc + 1);

      CBMatrix < int, _Flt > *phblk_recv = &hblk_recv[0];

      for (i = 0; i < nrecv_loc; i++) {
         isize = (long long) pObjRecv[i].size ();
         pobj = &(pObjRecv[i][0]);
         phblk_recv[i].UnPack (isize, pobj);
      }

// Free recv data

      {
         vector < vector < char > >ObjRecv_temp;
         ObjRecv.swap (ObjRecv_temp);
      }

// Compute correct ordering of cpu data

      vector < CSortInt > iiarr (nrecv_loc + 1);
      CSortInt *piiarr = &iiarr[0];

      for (i = 0; i < nrecv_loc; i++) {
         piiarr[i].ival = pCpuIDRecv[i];
         piiarr[i].i2val = i;
      }

      sort (piiarr, piiarr + nrecv_loc);

// Store received data

      this->nsends = nrecv_loc;

      this->snd2cpu.resize (nrecv_loc + 1);
      this->ia_sends.resize (nrecv_loc + 1);

      int *psnd2cpu = &this->snd2cpu[0];
      int *pia_sends = &this->ia_sends[0];

      int nz_sends = 0;

      pia_sends[0] = 0;

      for (i = 0; i < nrecv_loc; i++) {
         ind = piiarr[i].i2val;
         psnd2cpu[i] = piiarr[i].ival;
         CMatrix < int, _Flt > *pA_sub = phblk_recv[ind].GetASubArr ();
         int nzjaloc = pA_sub->GetNzja () / 2;
         nz_sends += nzjaloc;
         pia_sends[i + 1] = nz_sends;
      }

      this->ind_sends.resize (nz_sends + 1);
      this->x_send.resize (nz_sends + 1);

      int *pind_sends = &this->ind_sends[0];

      nz_sends = 0;

      int jj2, ibs;

      for (i = 0; i < nrecv_loc; i++) {
         ind = piiarr[i].i2val;
         CMatrix < int, _Flt > *pA_sub = phblk_recv[ind].GetASubArr ();
         int nzjaloc = pA_sub->GetNzja () / 2;
         int *pjaloc = pA_sub->GetJaArr ();
         for (j = 0; j < nzjaloc; j++) {
            jj = pjaloc[j * 2];
            jj2 = pjaloc[j * 2 + 1];
            ibs = pibsblk_loc[jj2];
            pind_sends[nz_sends] = ibs + jj;
            nz_sends++;
         }
      }

      this->x_temp.resize (nimax + 1);

   }

// Perform multiplication by A
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CMvmPar < _Int, _Flt,
      _FltVect >::MvmA (const _FltVect * _x, _FltVect * _ax)
   {

// Open mvm structure

      void *pcomm_loc = this->pcomm;

      int *pblk2cpu_loc = this->pblk2cpu;
      int ni_cpu_loc = this->ni_cpu;
      int *pibsblk_loc = &this->ibsblk[0];
      int nlistblk_own_loc = this->nlistblk_own;
      int *plistblk_own_loc = &this->listblk_own[0];
      CBMatrix < _Int, _Flt > *phmatr_loc = this->phmatr;
      int nsends_loc = this->nsends;
      int *psnd2cpu_loc = &this->snd2cpu[0];
      int *pia_sends_loc = &this->ia_sends[0];
      int *pind_sends_loc = &this->ind_sends[0];
      _FltVect *px_send_loc = &this->x_send[0];
      int nrecvs_loc = this->nrecvs;
      int *prcv2cpu_loc = &this->rcv2cpu[0];
      int *pia_recvs_loc = &this->ia_recvs[0];
      int *pja_recvs_loc = &this->ja_recvs[0];
      _FltVect *px_recv_loc = &this->x_recv[0];
      int nblks_recvs_loc = this->nblks_recvs;
      int *plistblk_recvs_loc = &this->listblk_recvs[0];
      int *pialist_recvs_loc = &this->ialist_recvs[0];
      int *pjapairs_recvs_loc = &this->japairs_recvs[0];
      int *piablk_recvs_loc = &this->iablk_recvs[0];
      int *pind_recvs_loc = &this->ind_recvs[0];
      _FltVect *px_temp_loc = &this->x_temp[0];

      int myid = CMPIDataExchange::GetMyid (pcomm_loc);

// Init array ax by zeroes

      CVector < _FltVect >::SetByZeroes (ni_cpu_loc, _ax);

// Prepare send

      int ni_send_loc = pia_sends_loc[nsends_loc];

      int i, ind;

      for (i = 0; i < ni_send_loc; i++) {
         ind = pind_sends_loc[i];
         px_send_loc[i] = _x[ind];
      }

      int ni_recv_loc = pia_recvs_loc[nrecvs_loc];

      CVector < _FltVect >::SetByZeroes (ni_recv_loc, px_recv_loc);

// Init async recvs and sends

      void *psndrcv_recvs_loc;
      void *psndrcv_stats_loc;

      CMPIDataExchange::AllocateRecvs (nrecvs_loc + nsends_loc, psndrcv_recvs_loc);
      CMPIDataExchange::AllocateStats (nrecvs_loc + nsends_loc, psndrcv_stats_loc);

      int icpu, isize, ibs;

      for (i = 0; i < nrecvs_loc; i++) {
         icpu = prcv2cpu_loc[i];
         isize = (pia_recvs_loc[i + 1] - pia_recvs_loc[i]) * sizeof (_FltVect);
         ibs = pia_recvs_loc[i];
         CMPIDataExchange::IRecv (pcomm_loc, icpu, icpu, isize,
                                  (char *) (px_recv_loc + ibs), i, psndrcv_recvs_loc);
      }

      for (i = 0; i < nsends_loc; i++) {
         icpu = psnd2cpu_loc[i];
         isize = (pia_sends_loc[i + 1] - pia_sends_loc[i]) * sizeof (_FltVect);
         ibs = pia_sends_loc[i];
         CMPIDataExchange::ISend (pcomm_loc, icpu, myid, isize,
                                  (char *) (px_send_loc + ibs), i + nrecvs_loc,
                                  psndrcv_recvs_loc);
      }

// Perform local multiplicaions

      int iblk, ibs_i, j, jblk, ibs_j;

      for (i = 0; i < nlistblk_own_loc; i++) {
         iblk = plistblk_own_loc[i];
         ibs_i = pibsblk_loc[iblk];
         CMatrix < _Int, _Flt > *pasub_loc = phmatr_loc[iblk].GetASubArr ();
         CMatrix < int, float >*phmatr_str_loc = phmatr_loc[iblk].GetHMatrStr ();
         int nzja_hblk = phmatr_str_loc->GetNzja ();
         int *pja_hblk = phmatr_str_loc->GetJaArr ();
         for (j = 0; j < nzja_hblk; j++) {
            jblk = pja_hblk[j];
            if (pblk2cpu_loc[jblk] == myid) {
               ibs_j = pibsblk_loc[jblk];
               CMvmSlv < _Int, _Flt, _FltVect >::MvmA ('+', pasub_loc[j], _x + ibs_j,
                                                       _ax + ibs_i);
            }
         }
      }

// Wait for completetion of sends/recvs

      CMPIDataExchange::WaitAll (nrecvs_loc + nsends_loc, psndrcv_recvs_loc,
                                 psndrcv_stats_loc);

// Perform remaining multiplications

      int jj, jj2;

      for (i = 0; i < nblks_recvs_loc; i++) {
         jblk = plistblk_recvs_loc[i];
         for (j = piablk_recvs_loc[i]; j < piablk_recvs_loc[i + 1]; j++) {
            ind = pind_recvs_loc[j];
            jj = pja_recvs_loc[ind * 2];
            jj2 = pja_recvs_loc[ind * 2 + 1];
            if (jj2 != jblk) {
               throw
                  " CTMvmSlvPar<_Int,_Flt,_FltVect>::MvmA: error: incorrect block number !";
            }
            px_temp_loc[jj] = px_recv_loc[ind];
         }
         for (j = pialist_recvs_loc[i]; j < pialist_recvs_loc[i + 1]; j++) {
            iblk = pjapairs_recvs_loc[j * 2];
            ind = pjapairs_recvs_loc[j * 2 + 1];
            ibs_i = pibsblk_loc[iblk];
            CMatrix < _Int, _Flt > *pasub_loc = phmatr_loc[iblk].GetASubArr ();
            CMatrix < int, float >*phmatr_str_loc = phmatr_loc[iblk].GetHMatrStr ();
            int *pja_hblk = phmatr_str_loc->GetJaArr ();
            if (pja_hblk[ind] != jblk) {
               throw
                  " CTMvmSlvPar<_Int,_Flt,_FltVect>::MvmA: error 2: incorrect block number !";
            }
            CMvmSlv < _Int, _Flt, _FltVect >::MvmA ('+', pasub_loc[ind], px_temp_loc,
                                                    _ax + ibs_i);
         }
      }

      CMPIDataExchange::DeleteRecvs (psndrcv_recvs_loc);
      CMPIDataExchange::DeleteStats (psndrcv_stats_loc);

   }

// Clean MvmA structure
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CMvmPar < _Int, _Flt,
      _FltVect >::Clean ()
   {

      //cout << " CMvmPar::Clean() " << endl;//db!

      pcomm = NULL;
      nblks = 0;
      pblks = NULL;
      pblk2cpu = NULL;
      ni_cpu = 0;
      vector < int >ibsblk_dummy;
      ibsblk.swap (ibsblk_dummy);
      nlistblk_own = 0;
      vector < int >listblk_own_dummy;
      listblk_own.swap (listblk_own_dummy);
      phmatr = NULL;
      nsends = 0;
      vector < int >snd2cpu_dummy;
      vector < int >ia_sends_dummy;
      vector < int >ind_sends_dummy;
      vector < _FltVect > x_send_dummy;
      snd2cpu.swap (snd2cpu_dummy);
      ia_sends.swap (ia_sends_dummy);
      ind_sends.swap (ind_sends_dummy);
      x_send.swap (x_send_dummy);
      nrecvs = 0;
      vector < int >rcv2cpu_dummy;
      vector < int >ia_recvs_dummy;
      vector < int >ja_recvs_dummy;
      vector < _FltVect > x_recv_dummy;
      rcv2cpu.swap (rcv2cpu_dummy);
      ia_recvs.swap (ia_recvs_dummy);
      ja_recvs.swap (ja_recvs_dummy);
      x_recv.swap (x_recv_dummy);
      nblks_recvs = 0;
      vector < int >listblk_recvs_dummy;
      vector < int >ialist_recvs_dummy;
      vector < int >japairs_recvs_dummy;
      vector < int >iablk_recvs_dummy;
      vector < int >ind_recvs_dummy;
      vector < _FltVect > x_temp_dummy;
      listblk_recvs.swap (listblk_recvs_dummy);
      ialist_recvs.swap (ialist_recvs_dummy);
      japairs_recvs.swap (japairs_recvs_dummy);
      iablk_recvs.swap (iablk_recvs_dummy);
      ind_recvs.swap (ind_recvs_dummy);
      x_temp.swap (x_temp_dummy);

   }

// Init SolveLU data
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CSlvPar < _Int, _Flt,
      _FltVect >::InitSolveLU (vector < int >*_listpairs_ext, CMatrix < _Int,
                               _Flt > *_matrL, CMatrix < _Int, _Flt > *_matrU,
                               vector < int >*_orderLU)
   {

// Get control data

      void *pcomm_loc = this->pcomm;

      int nblks_loc = this->nblks;
      long long *pblks_loc = this->pblks;
      long long *pblks_ext_loc = this->pblks_ext;
      int *pblk2cpu_loc = this->pblk2cpu;
      int *pibsblk_loc = &this->ibsblk[0];
      int nlistblk_own_loc = this->nlistblk_own;
      int *plistblk_own_loc = &this->listblk_own[0];

      int nproc = CMPIDataExchange::GetNproc (pcomm_loc);
      int myid = CMPIDataExchange::GetMyid (pcomm_loc);

// Compute maximal block size

      int nimax_ext = 0;

      int i, niloc;

      for (i = 0; i < nblks_loc; i++) {
         niloc = (int) (pblks_ext_loc[i + 1] - pblks_ext_loc[i]);
         if (niloc > nimax_ext)
            nimax_ext = niloc;
      }

// Store Ptrs to data

      this->plistpairs_ext = _listpairs_ext;
      this->pmatrL = _matrL;
      this->pmatrU = _matrU;
      this->porderLU = _orderLU;

// Create cpu recv data

      vector < int >imaskcpu (nproc);
      vector < int >listcpu (nproc);
      vector < int >indcpu (nproc);

      int *pimaskcpu = &imaskcpu[0];
      int *plistcpu = &listcpu[0];
      int *pindcpu = &indcpu[0];

      for (i = 0; i < nproc; i++)
         pimaskcpu[i] = -1;

      int icyclecpu = -1;

      icyclecpu++;

      int nlistcpu = 0;

      int jcpu, iblk, jj2, ni_ext, j;

      for (i = 0; i < nlistblk_own_loc; i++) {
         iblk = plistblk_own_loc[i];
         ni_ext =
            (int) ((pblks_ext_loc[iblk + 1] - pblks_ext_loc[iblk]) -
                   (pblks_loc[iblk + 1] - pblks_loc[iblk]));
         int *pplistpairs_ext = &(_listpairs_ext[iblk][0]);
         for (j = 0; j < ni_ext; j++) {
            jj2 = pplistpairs_ext[2 * j + 1];
            jcpu = pblk2cpu_loc[jj2];
            if (jcpu != myid) {
               if (pimaskcpu[jcpu] != icyclecpu) {
                  plistcpu[nlistcpu] = jcpu;
                  nlistcpu++;
                  pimaskcpu[jcpu] = icyclecpu;
               }
            }
         }
      }

      sort (plistcpu, plistcpu + nlistcpu);

      for (i = 0; i < nlistcpu; i++) {
         jcpu = plistcpu[i];
         pindcpu[jcpu] = i;
      }

      this->nrecvs = nlistcpu;

      this->rcv2cpu.resize (nlistcpu + 1);
      this->ia_recvs.resize (nlistcpu + 1);

      int *prcv2cpu = &this->rcv2cpu[0];
      int *pia_recvs = &this->ia_recvs[0];

      for (i = 0; i < nlistcpu; i++)
         prcv2cpu[i] = plistcpu[i];
      for (i = 0; i <= nlistcpu; i++)
         pia_recvs[i] = 0;

      int ind;

      for (i = 0; i < nlistblk_own_loc; i++) {
         iblk = plistblk_own_loc[i];
         ni_ext =
            (int) ((pblks_ext_loc[iblk + 1] - pblks_ext_loc[iblk]) -
                   (pblks_loc[iblk + 1] - pblks_loc[iblk]));
         int *pplistpairs_ext = &(_listpairs_ext[iblk][0]);
         for (j = 0; j < ni_ext; j++) {
            jj2 = pplistpairs_ext[2 * j + 1];
            jcpu = pblk2cpu_loc[jj2];
            if (jcpu != myid) {
               ind = pindcpu[jcpu];
               pia_recvs[ind + 1]++;
            }
         }
      }

      for (i = 0; i < nlistcpu; i++)
         pia_recvs[i + 1] = pia_recvs[i] + pia_recvs[i + 1];

      int nz_recvs = pia_recvs[nlistcpu];

      this->x_recv.resize (nz_recvs + 1);

      this->ialist_recvs.resize (nlistblk_own_loc + 1);
      this->jalist_recvs.resize (2 * nz_recvs + 1);

      int *pialist_recvs = &this->ialist_recvs[0];
      int *pjalist_recvs = &this->jalist_recvs[0];

      nz_recvs = 0;

      for (i = 0; i < nlistcpu; i++)
         plistcpu[i] = pia_recvs[i];

      pialist_recvs[0] = 0;

      int k;

      for (i = 0; i < nlistblk_own_loc; i++) {
         iblk = plistblk_own_loc[i];
         ni_ext =
            (int) ((pblks_ext_loc[iblk + 1] - pblks_ext_loc[iblk]) -
                   (pblks_loc[iblk + 1] - pblks_loc[iblk]));
         int *pplistpairs_ext = &(_listpairs_ext[iblk][0]);
         for (j = 0; j < ni_ext; j++) {
            jj2 = pplistpairs_ext[2 * j + 1];
            jcpu = pblk2cpu_loc[jj2];
            if (jcpu != myid) {
               ind = pindcpu[jcpu];
               k = plistcpu[ind];
               pjalist_recvs[nz_recvs * 2] = k;
               pjalist_recvs[nz_recvs * 2 + 1] = j;
               nz_recvs++;
               plistcpu[ind]++;
            }
         }
         pialist_recvs[i + 1] = nz_recvs;
      }

// Prepare exchange data

      vector < CBMatrix < int, _Flt > >hblk_send (nlistcpu + 1);

      CBMatrix < int, _Flt > *phblk_send = &hblk_send[0];

      for (i = 0; i < nlistcpu; i++) {
         phblk_send[i].SetNzblk (1);
         phblk_send[i].ResizeASub (1);
         CMatrix < int, _Flt > *pA_sub = phblk_send[i].GetASubArr ();
         CMatrix < int, _Flt > ablk_temp;
         int niloc = pia_recvs[i + 1] - pia_recvs[i];
         ablk_temp.ResizeAndSetAllSp (0, 0, niloc * 2, 0);
         pA_sub->ReplaceFree (ablk_temp);
      }

      nz_recvs = 0;

      for (i = 0; i < nlistcpu; i++)
         plistcpu[i] = pia_recvs[i];

      int jj;

      for (i = 0; i < nlistblk_own_loc; i++) {
         iblk = plistblk_own_loc[i];
         ni_ext =
            (int) ((pblks_ext_loc[iblk + 1] - pblks_ext_loc[iblk]) -
                   (pblks_loc[iblk + 1] - pblks_loc[iblk]));
         int *pplistpairs_ext = &(_listpairs_ext[iblk][0]);
         for (j = 0; j < ni_ext; j++) {
            jj = pplistpairs_ext[2 * j];
            jj2 = pplistpairs_ext[2 * j + 1];
            jcpu = pblk2cpu_loc[jj2];
            if (jcpu != myid) {
               ind = pindcpu[jcpu];
               CMatrix < int, _Flt > *pA_sub = phblk_send[ind].GetASubArr ();
               int *pjaloc = pA_sub->GetJaArr ();
               k = plistcpu[ind] - pia_recvs[ind];
               pjaloc[k * 2] = jj;
               pjaloc[k * 2 + 1] = jj2;
               plistcpu[ind]++;
            }
         }
      }

// Pack send data

      vector < int >CpuIDSend (nlistcpu);
      vector < vector < char > >ObjSend (nlistcpu);

      int *pCpuIDSend = NULL;
      vector < char >*pObjSend = NULL;

      if (nlistcpu > 0) {
         pCpuIDSend = &CpuIDSend[0];
         pObjSend = &ObjSend[0];
      }

      long long isize;
      char *pobj;

      for (i = 0; i < nlistcpu; i++) {
         pCpuIDSend[i] = prcv2cpu[i];
         isize = phblk_send[i].GetPackedSize ();
         pObjSend[i].resize ((size_t) isize);
         pobj = &(pObjSend[i][0]);
         phblk_send[i].FillPacked (isize, pobj);
         phblk_send[i].Clean ();
      }

// Exchange

      vector < int >CpuIDRecv;
      vector < vector < char > >ObjRecv;

      CMPIDataExchange::DataExchange (pcomm_loc, CpuIDSend, ObjSend, CpuIDRecv, ObjRecv);

// Free send data

      {
         vector < int >CpuIDSend_temp;
         vector < vector < char > >ObjSend_temp;
         CpuIDSend.swap (CpuIDSend_temp);
         ObjSend.swap (ObjSend_temp);
      }

// Unpack receive data

      int nrecv_loc = (int) CpuIDRecv.size ();

      vector < char >*pObjRecv = NULL;
      int *pCpuIDRecv = NULL;

      if (nrecv_loc > 0) {
         pObjRecv = &ObjRecv[0];
         pCpuIDRecv = &CpuIDRecv[0];
      }

      vector < CBMatrix < int, _Flt > >hblk_recv (nrecv_loc + 1);

      CBMatrix < int, _Flt > *phblk_recv = &hblk_recv[0];

      for (i = 0; i < nrecv_loc; i++) {
         isize = (long long) pObjRecv[i].size ();
         pobj = &(pObjRecv[i][0]);
         phblk_recv[i].UnPack (isize, pobj);
      }

// Free recv data

      {
         vector < vector < char > >ObjRecv_temp;
         ObjRecv.swap (ObjRecv_temp);
      }

// Compute correct ordering of cpu data

      vector < CSortInt > iiarr (nrecv_loc + 1);
      CSortInt *piiarr = &iiarr[0];

      for (i = 0; i < nrecv_loc; i++) {
         piiarr[i].ival = pCpuIDRecv[i];
         piiarr[i].i2val = i;
      }

      sort (piiarr, piiarr + nrecv_loc);

// Store received data

      this->nsends = nrecv_loc;

      this->snd2cpu.resize (nrecv_loc + 1);
      this->ia_sends.resize (nrecv_loc + 1);

      int *psnd2cpu = &this->snd2cpu[0];
      int *pia_sends = &this->ia_sends[0];

      int nz_sends = 0;

      pia_sends[0] = 0;

      for (i = 0; i < nrecv_loc; i++) {
         ind = piiarr[i].i2val;
         psnd2cpu[i] = piiarr[i].ival;
         CMatrix < int, _Flt > *pA_sub = phblk_recv[ind].GetASubArr ();
         int nzjaloc = pA_sub->GetNzja () / 2;
         nz_sends += nzjaloc;
         pia_sends[i + 1] = nz_sends;
      }

      this->ind_sends.resize (nz_sends + 1);
      this->x_send.resize (nz_sends + 1);

      int *pind_sends = &this->ind_sends[0];

      nz_sends = 0;

      int ibs;

      for (i = 0; i < nrecv_loc; i++) {
         ind = piiarr[i].i2val;
         CMatrix < int, _Flt > *pA_sub = phblk_recv[ind].GetASubArr ();
         int nzjaloc = pA_sub->GetNzja () / 2;
         int *pjaloc = pA_sub->GetJaArr ();
         for (j = 0; j < nzjaloc; j++) {
            jj = pjaloc[j * 2];
            jj2 = pjaloc[j * 2 + 1];
            ibs = pibsblk_loc[jj2];
            pind_sends[nz_sends] = ibs + jj;
            nz_sends++;
         }
      }

      this->x_temp.resize (nimax_ext * 2 + 1);

   }

// Perform SolveLU computations
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CSlvPar < _Int, _Flt,
      _FltVect >::SolveLU (const _FltVect * _x, _FltVect * _px)
   {

// Open mvm structure

      void *pcomm_loc = this->pcomm;

      long long *pblks_loc = this->pblks;
      long long *pblks_ext_loc = this->pblks_ext;
      int *pblk2cpu_loc = this->pblk2cpu;
      int ni_cpu_loc = this->ni_cpu;
      int *pibsblk_loc = &this->ibsblk[0];
      int nlistblk_own_loc = this->nlistblk_own;
      int *plistblk_own_loc = &this->listblk_own[0];
      vector < int >*plistpairs_ext_loc = this->plistpairs_ext;
      CMatrix < _Int, _Flt > *pmatrL_loc = this->pmatrL;
      CMatrix < _Int, _Flt > *pmatrU_loc = this->pmatrU;
      int nsends_loc = this->nsends;
      int *psnd2cpu_loc = &this->snd2cpu[0];
      int *pia_sends_loc = &this->ia_sends[0];
      int *pind_sends_loc = &this->ind_sends[0];
      _FltVect *px_send_loc = &this->x_send[0];
      int nrecvs_loc = this->nrecvs;
      int *prcv2cpu_loc = &this->rcv2cpu[0];
      int *pia_recvs_loc = &this->ia_recvs[0];
      _FltVect *px_recv_loc = &this->x_recv[0];
      int *pialist_recvs_loc = &this->ialist_recvs[0];
      int *pjalist_recvs_loc = &this->jalist_recvs[0];
      _FltVect *px_temp_loc = &this->x_temp[0];

      int myid = CMPIDataExchange::GetMyid (pcomm_loc);

// Init array ax by zeroes

      CVector < _FltVect >::SetByZeroes (ni_cpu_loc, _px);

// Prepare send

      int ni_send_loc = pia_sends_loc[nsends_loc];

      int i, ind;

      for (i = 0; i < ni_send_loc; i++) {
         ind = pind_sends_loc[i];
         px_send_loc[i] = _x[ind];
      }

      int ni_recv_loc = pia_recvs_loc[nrecvs_loc];

      CVector < _FltVect >::SetByZeroes (ni_recv_loc, px_recv_loc);

// Init async recvs and sends

      void *psndrcv_recvs_loc;
      void *psndrcv_stats_loc;

      CMPIDataExchange::AllocateRecvs (nrecvs_loc + nsends_loc, psndrcv_recvs_loc);
      CMPIDataExchange::AllocateStats (nrecvs_loc + nsends_loc, psndrcv_stats_loc);

      int icpu, isize, ibs;

      for (i = 0; i < nrecvs_loc; i++) {
         icpu = prcv2cpu_loc[i];
         isize = (pia_recvs_loc[i + 1] - pia_recvs_loc[i]) * sizeof (_FltVect);
         ibs = pia_recvs_loc[i];
         CMPIDataExchange::IRecv (pcomm_loc, icpu, myid, isize,
                                  (char *) (px_recv_loc + ibs), i, psndrcv_recvs_loc);
      }

      for (i = 0; i < nsends_loc; i++) {
         icpu = psnd2cpu_loc[i];
         isize = (pia_sends_loc[i + 1] - pia_sends_loc[i]) * sizeof (_FltVect);
         ibs = pia_sends_loc[i];
         CMPIDataExchange::ISend (pcomm_loc, icpu, icpu, isize,
                                  (char *) (px_send_loc + ibs), i + nrecvs_loc,
                                  psndrcv_recvs_loc);
      }

// Wait for completetion of sends/recvs

      CMPIDataExchange::WaitAll (nrecvs_loc + nsends_loc, psndrcv_recvs_loc,
                                 psndrcv_stats_loc);

      CVector < _FltVect >::SetByZeroes (ni_send_loc, px_send_loc);

// Perform local computations

      int iblk, ibs_i, j, jj, jj2, ibs_j, ind1, niloc, niextloc, ni_ini;

      _FltVect *px1_temp;
      _FltVect *px2_temp;

      for (i = 0; i < nlistblk_own_loc; i++) {
         iblk = plistblk_own_loc[i];
         ibs_i = pibsblk_loc[iblk];
         niloc = (int) (pblks_loc[iblk + 1] - pblks_loc[iblk]);
         niextloc = (int) (pblks_ext_loc[iblk + 1] - pblks_ext_loc[iblk]);
         ni_ini = niextloc - niloc;
         px1_temp = px_temp_loc;
         px2_temp = px1_temp + niextloc;
         CVector < _FltVect >::SetByZeroes (ni_ini, px1_temp);
         memcpy (px1_temp + ni_ini, _x + ibs_i, (size_t) (niloc * sizeof (_FltVect)));
         int *pplistpairs_loc = &(plistpairs_ext_loc[iblk][0]);
         for (j = 0; j < ni_ini; j++) {
            jj = pplistpairs_loc[j * 2];
            jj2 = pplistpairs_loc[j * 2 + 1];
            if (pblk2cpu_loc[jj2] == myid) {
               ibs_j = pibsblk_loc[jj2];
               px1_temp[j] = _x[ibs_j + jj];
            }
         }
         for (j = pialist_recvs_loc[i]; j < pialist_recvs_loc[i + 1]; j++) {
            ind = pjalist_recvs_loc[2 * j];
            ind1 = pjalist_recvs_loc[2 * j + 1];
            px1_temp[ind1] = px_recv_loc[ind];
         }
         if (porderLU != NULL) {
            int *pporderLU = &this->porderLU[iblk][0];
            CVector < _FltVect >::OrderVector (niextloc, pporderLU, px1_temp, px2_temp);
            CMvmSlv < _Int, _Flt, _FltVect >::SolveL (pmatrL_loc[iblk], px2_temp,
                                                      px1_temp);
            CVector < _FltVect >::SetByZeroes (ni_ini, px1_temp);
            CMvmSlv < _Int, _Flt, _FltVect >::SolveU (pmatrU_loc[iblk], px1_temp,
                                                      px2_temp);
            CVector < _FltVect >::InvOrderVector (niextloc, pporderLU, px2_temp,
                                                  px1_temp);
         } else {
            CMvmSlv < _Int, _Flt, _FltVect >::SolveL (pmatrL_loc[iblk], px1_temp,
                                                      px2_temp);
            CVector < _FltVect >::SetByZeroes (ni_ini, px2_temp);
            CMvmSlv < _Int, _Flt, _FltVect >::SolveU (pmatrU_loc[iblk], px2_temp,
                                                      px1_temp);
         }
         for (j = pialist_recvs_loc[i]; j < pialist_recvs_loc[i + 1]; j++) {
            ind = pjalist_recvs_loc[2 * j];
            ind1 = pjalist_recvs_loc[2 * j + 1];
            px_recv_loc[ind] = px1_temp[ind1];
         }
         for (j = 0; j < ni_ini; j++) {
            jj = pplistpairs_loc[j * 2];
            jj2 = pplistpairs_loc[j * 2 + 1];
            if (pblk2cpu_loc[jj2] == myid) {
               ibs_j = pibsblk_loc[jj2];
               _px[ibs_j + jj] += px1_temp[j];
            }
         }
         CVector < _FltVect >::AddReplaceVector (niloc, px1_temp + ni_ini, _px + ibs_i);
      }

// Backward exchanges

      for (i = 0; i < nsends_loc; i++) {
         icpu = psnd2cpu_loc[i];
         isize = (pia_sends_loc[i + 1] - pia_sends_loc[i]) * sizeof (_FltVect);
         ibs = pia_sends_loc[i];
         CMPIDataExchange::IRecv (pcomm_loc, icpu, myid, isize,
                                  (char *) (px_send_loc + ibs), i + nrecvs_loc,
                                  psndrcv_recvs_loc);
      }

      for (i = 0; i < nrecvs_loc; i++) {
         icpu = prcv2cpu_loc[i];
         isize = (pia_recvs_loc[i + 1] - pia_recvs_loc[i]) * sizeof (_FltVect);
         ibs = pia_recvs_loc[i];
         CMPIDataExchange::ISend (pcomm_loc, icpu, icpu, isize,
                                  (char *) (px_recv_loc + ibs), i, psndrcv_recvs_loc);
      }

// Wait for completetion of sends/recvs

      CMPIDataExchange::WaitAll (nrecvs_loc + nsends_loc, psndrcv_recvs_loc,
                                 psndrcv_stats_loc);

// Finally update received data

      for (i = 0; i < ni_send_loc; i++) {
         ind = pind_sends_loc[i];
         _px[ind] += px_send_loc[i];
      }

      CMPIDataExchange::DeleteRecvs (psndrcv_recvs_loc);
      CMPIDataExchange::DeleteStats (psndrcv_stats_loc);

   }

// Clean Slv structure
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CSlvPar < _Int, _Flt,
      _FltVect >::Clean ()
   {

      //cout << " CSlvPar::Clean() " << endl;//db!

      pcomm = NULL;
      nblks = 0;
      pblks = NULL;
      pblks_ext = NULL;
      pblk2cpu = NULL;
      ni_cpu = 0;
      vector < int >ibsblk_dummy;
      ibsblk.swap (ibsblk_dummy);
      nlistblk_own = 0;
      vector < int >listblk_own_dummy;
      listblk_own.swap (listblk_own_dummy);
      pmatrL = NULL;
      pmatrU = NULL;
      porderLU = NULL;
      nsends = 0;
      vector < int >snd2cpu_dummy;
      vector < int >ia_sends_dummy;
      vector < int >ind_sends_dummy;
      vector < _FltVect > x_send_dummy;
      snd2cpu.swap (snd2cpu_dummy);
      ia_sends.swap (ia_sends_dummy);
      ind_sends.swap (ind_sends_dummy);
      x_send.swap (x_send_dummy);
      nrecvs = 0;
      vector < int >rcv2cpu_dummy;
      vector < int >ia_recvs_dummy;
      vector < _FltVect > x_recv_dummy;
      vector < int >ialist_recvs_dummy;
      vector < int >jalist_recvs_dummy;
      vector < _FltVect > x_temp_dummy;
      rcv2cpu.swap (rcv2cpu_dummy);
      ia_recvs.swap (ia_recvs_dummy);
      x_recv.swap (x_recv_dummy);
      ialist_recvs.swap (ialist_recvs_dummy);
      jalist_recvs.swap (jalist_recvs_dummy);
      x_temp.swap (x_temp_dummy);

   }

// Prepare solver structures
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CK3D_Solver < _Int,
      _Flt, _FltVect >::PrepareMatrix (void *_pcomm, int _nblks, long long *_blks,
                                       int *_blk2cpu, _Int * _ia, _Int * _ja, _Flt * _a)
   {

// Store control data

      this->pcomm = _pcomm;
      this->nblks = _nblks;

      this->blks.resize (_nblks + 1);
      this->blk2cpu.resize (_nblks + 1);

      long long *pblks = &this->blks[0];
      int *pblk2cpu = &this->blk2cpu[0];

      int i;

      for (i = 0; i <= _nblks; i++)
         pblks[i] = _blks[i];
      for (i = 0; i < _nblks; i++)
         pblk2cpu[i] = _blk2cpu[i];

      int myid = CMPIDataExchange::GetMyid (_pcomm);

// Allocate arrays for data

      this->hmatr_arr.resize (_nblks);

      CBMatrix < _Int, _Flt > *phmatr_arr = &this->hmatr_arr[0];

// Create matrix as set of hblocks

      int nimax = 0;

      int niloc;

      for (i = 0; i < _nblks; i++) {
         niloc = (int) (pblks[i + 1] - pblks[i]);
         if (niloc > nimax)
            nimax = niloc;
      }

      vector < _Int > listloc (nimax + 1);
      vector < _Int > ialoc (nimax + 1);

      _Int *plistloc = &listloc[0];
      _Int *pialoc = &ialoc[0];

      vector < int >imaskblk (3 * _nblks + 1);
      int *pimaskblk = &imaskblk[0];

      for (i = 0; i < _nblks; i++)
         pimaskblk[i] = -1;

      int icycleblk = -1;

      int ibeg = 0;

      int ishift, j;

      for (i = 0; i < _nblks; i++) {
         if (pblk2cpu[i] == myid) {
            niloc = (int) (pblks[i + 1] - pblks[i]);
            ishift = (int) _ia[ibeg];
            for (j = 0; j < niloc; j++) {
               plistloc[j] = (_Int) (j + pblks[i]);
            }
            for (j = 0; j <= niloc; j++) {
               pialoc[j] = _ia[ibeg + j] - _ia[ibeg];
            }
            CBMatrix < _Int, _Flt > hblk (i, niloc, plistloc, pialoc, _ja + ishift,
                                          _a + ishift, _nblks, pblks, icycleblk,
                                          pimaskblk);
            ibeg += niloc;
            phmatr_arr[i].ReplaceFree (hblk);
         }
      }

// Symmetrize hmatr

      vector < CBMatrix < _Int, _Flt > >hmatr_symm_arr (_nblks);
      CBMatrix < _Int, _Flt > *phmatr_symm_arr = &hmatr_symm_arr[0];

      CBMatrix < _Int, _Flt >::SymmetrizeSubmatrices (_pcomm, _nblks, pblks, pblk2cpu,
                                                      phmatr_arr, phmatr_symm_arr);

      for (i = 0; i < _nblks; i++) {
         if (pblk2cpu[i] == myid) {
            phmatr_arr[i].ReplaceFree (phmatr_symm_arr[i]);
         }
      }

// Init MvmA structures

      this->mvm.InitControl (_pcomm, _nblks, pblks, pblk2cpu);
      this->mvm.InitMvmA (phmatr_arr);

   }

// Prepare solver structures including performing parallel fct
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CK3D_Solver < _Int,
      _Flt, _FltVect >::ComputeBILU2 (SParams * _params, double &_prec_extend,
                                      double &_density, double &_scpiv_min,
                                      double &_scpiv_max, int &_nmodif, double &_piv_min,
                                      double &_piv_max, double &_dtime_fct)
   {

// Init output data

      _prec_extend = 1.0;
      _density = 0.0e0;
      _scpiv_min = 1.0e100;
      _scpiv_max = -1.0e100;
      _nmodif = 0;
      _piv_min = 1.0e100;
      _piv_max = -1.0e100;
      _dtime_fct = 0.0e0;

// Init timer

      void *pcommloc = this->pcomm;

      CMPIDataExchange::Synchronize (pcommloc);

      double time0;

      time0 = CMPIDataExchange::GetWallTimeMPI ();

// Store control data

      int nblksloc = this->nblks;

      this->params = *_params;

      this->blks_ext.resize (nblksloc + 1);

      long long *pblks = &this->blks[0];
      long long *pblks_ext = &this->blks_ext[0];
      int *pblk2cpu = &this->blk2cpu[0];

      int i;

      int myid = CMPIDataExchange::GetMyid (pcommloc);

// Allocate arrays for data

      CBMatrix < _Int, _Flt > *phmatr_arr = &this->hmatr_arr[0];

      this->nlist_ext_arr.resize (nblksloc);
      this->list_ext_arr.resize (nblksloc);
      this->order_LU.resize (nblksloc);
      this->matrL_float.resize (nblksloc);
      this->matrL_double.resize (nblksloc);
      this->matrU_float.resize (nblksloc);
      this->matrU_double.resize (nblksloc);

      int *pnlist_ext_arr = &this->nlist_ext_arr[0];
      vector < int >*plist_ext_arr = &this->list_ext_arr[0];
      vector < int >*porder_LU = &this->order_LU[0];
      CMatrix < _Int, float >*pmatrL_float = &this->matrL_float[0];
      CMatrix < _Int, double >*pmatrL_double = &this->matrL_double[0];
      CMatrix < _Int, float >*pmatrU_float = &this->matrU_float[0];
      CMatrix < _Int, double >*pmatrU_double = &this->matrU_double[0];

// Get nzatot

      long long nza_tot = 0;

      for (i = 0; i < nblksloc; i++) {
         if (pblk2cpu[i] == myid) {
            nza_tot += phmatr_arr[i].GetNzatot ();
         }
      }

      CMPIDataExchange::ExchangeArray (pcommloc, 'L', '+', 1, (void *) (&nza_tot));

// Compute extended lists

      int ncycle_loc = _params->ncycle;

      CBMatrix < _Int, _Flt >::ExtendedLists (pcommloc, ncycle_loc, nblksloc, pblks,
                                              pblk2cpu, phmatr_arr, pnlist_ext_arr,
                                              plist_ext_arr);

// Perform filtering of the lists

      CBMatrix < _Int, _Flt >::FilterListsBack (myid, nblksloc, pblk2cpu, pnlist_ext_arr,
                                                plist_ext_arr);

// Create extended blocks partitioning

      for (i = 0; i <= nblksloc; i++)
         pblks_ext[i] = 0;

      for (i = 0; i < nblksloc; i++) {
         if (pblk2cpu[i] == myid) {
            pblks_ext[i + 1] = (pblks[i + 1] - pblks[i]) + pnlist_ext_arr[i];
         }
      }

      CMPIDataExchange::ExchangeArray (pcommloc, 'L', '+', nblksloc + 1,
                                       (void *) pblks_ext);

      for (i = 0; i < nblksloc; i++)
         pblks_ext[i + 1] = pblks_ext[i] + pblks_ext[i + 1];

// Get extended submatrices

      vector < CMatrix < _Int, _Flt > >matr_ext_arr (nblksloc);
      CMatrix < _Int, _Flt > *pmatr_ext_arr = &matr_ext_arr[0];

      CBMatrix < _Int, _Flt >::GetExtendedSubmatrices (pcommloc, nblksloc, pblks,
                                                       pblk2cpu, phmatr_arr,
                                                       pnlist_ext_arr, plist_ext_arr,
                                                       pmatr_ext_arr);

      long long ntot = pblks[nblksloc];
      long long ntot_ext = pblks_ext[nblksloc];

      _prec_extend = ((double) (ntot_ext) / (double) (ntot));

      int collap_loc = _params->collap;

      char strbuff[256];

      int blks_2[3];

      if (collap_loc > 0) {
         for (i = 0; i < nblksloc; i++) {
            if (pblk2cpu[i] == myid) {
               sprintf (strbuff, "BlkStrExt_%i.ps", i);
               blks_2[0] = 0;
               blks_2[1] = pnlist_ext_arr[i];
               blks_2[2] = pmatr_ext_arr[i].GetNlist ();
               CBMatrix < _Int, _Flt >::Str2PsBox (collap_loc, pmatr_ext_arr[i], strbuff,
                                                   2, blks_2);
            }
         }
      }
// Compute new ordering

      vector < int >n2_blocks (nblksloc + 1);

      int *pn2_blocks = &n2_blocks[0];

      for (i = 0; i < nblksloc; i++)
         pn2_blocks[i] = pmatr_ext_arr[i].GetNlist ();

      int blks_3[4];

      int ordtype_loc = _params->ordtype;

      if (ordtype_loc > 0) {

         vector < CMatrix < _Int, _Flt > >matr_ord_arr (nblksloc);
         CMatrix < _Int, _Flt > *pmatr_ord_arr = &matr_ord_arr[0];

         for (i = 0; i < nblksloc; i++) {
            if (pblk2cpu[i] == myid) {
               CFct_impl < _Int, _Flt >::ComputeOptimalOrderSchur (ordtype_loc,
                                                                   pmatr_ext_arr
                                                                   [i].GetNlist (),
                                                                   pnlist_ext_arr[i],
                                                                   *(pmatr_ext_arr
                                                                     [i].GetIa ()),
                                                                   *(pmatr_ext_arr
                                                                     [i].GetJa ()),
                                                                   pn2_blocks[i],
                                                                   porder_LU[i]);
               CFct < _Int, _Flt >::ReorderMatrix (pmatr_ext_arr[i], porder_LU[i],
                                                   pmatr_ord_arr[i]);
               if (collap_loc > 0) {
                  sprintf (strbuff, "BlkStrExtOrd_%i.ps", i);
                  blks_3[0] = 0;
                  blks_3[1] = pnlist_ext_arr[i];
                  blks_3[2] = pn2_blocks[i];
                  blks_3[3] = pmatr_ext_arr[i].GetNlist ();
                  CBMatrix < _Int, _Flt >::Str2PsBox (collap_loc, pmatr_ord_arr[i],
                                                      strbuff, 3, blks_3);
               }
               pmatr_ext_arr[i].ReplaceFree (pmatr_ord_arr[i]);
            }
         }

      }
// Perform computation of the ILU decomposition for all local ordered blocks

      int prec_float_loc = _params->prec_float;

      vector < double >sclmin_arr (nblksloc + 1);
      vector < double >sclmax_arr (nblksloc + 1);
      vector < double >eigmin_arr (nblksloc + 1);
      vector < double >eigmax_arr (nblksloc + 1);

      double *psclmin_arr = &sclmin_arr[0];
      double *psclmax_arr = &sclmax_arr[0];
      double *peigmin_arr = &eigmin_arr[0];
      double *peigmax_arr = &eigmax_arr[0];

      for (i = 0; i < nblksloc; i++)
         psclmin_arr[i] = 0;
      for (i = 0; i < nblksloc; i++)
         psclmax_arr[i] = 0;
      for (i = 0; i < nblksloc; i++)
         peigmin_arr[i] = 0;
      for (i = 0; i < nblksloc; i++)
         peigmax_arr[i] = 0;

      long long nzlu_tot = 0;

      _nmodif = 0;

      int nmodif_loc = 0;

      for (i = 0; i < nblksloc; i++) {
         if (pblk2cpu[i] == myid) {
            if (prec_float_loc == 1) {
               CMatrix < _Int, float >*ptr_matr = NULL;
               CMatrix < _Int, float >matr_conv;
               if (sizeof (_Flt) == sizeof (float)) {
                  ptr_matr = (CMatrix < _Int, float >*) (pmatr_ext_arr + i);
               } else {
                  int nlist_temp = pmatr_ext_arr[i].GetNlist ();
                  _Int *pia_temp = pmatr_ext_arr[i].GetIaArr ();
                  _Int *pja_temp = pmatr_ext_arr[i].GetJaArr ();
                  _Flt *pa_temp = pmatr_ext_arr[i].GetAArr ();
                  CMatrixConv < _Int, _Flt, float >::InitAndConv (nlist_temp, pia_temp,
                                                                  pja_temp, pa_temp,
                                                                  matr_conv);
                  ptr_matr = &matr_conv;
               }
               CFct < _Int, float >::Ilu2Matrix (*ptr_matr, *_params, pmatrL_float[i],
                                                 pmatrU_float[i], psclmin_arr[i],
                                                 psclmax_arr[i], nmodif_loc,
                                                 peigmin_arr[i], peigmax_arr[i]);
               _nmodif += nmodif_loc;
               nzlu_tot += pmatrL_float[i].GetNza ();
               nzlu_tot += pmatrU_float[i].GetNza ();
            } else {
               CMatrix < _Int, double >*ptr_matr = NULL;
               CMatrix < _Int, double >matr_conv;
               if (sizeof (_Flt) == sizeof (double)) {
                  ptr_matr = (CMatrix < _Int, double >*) (pmatr_ext_arr + i);
               } else {
                  int nlist_temp = pmatr_ext_arr[i].GetNlist ();
                  _Int *pia_temp = pmatr_ext_arr[i].GetIaArr ();
                  _Int *pja_temp = pmatr_ext_arr[i].GetJaArr ();
                  _Flt *pa_temp = pmatr_ext_arr[i].GetAArr ();
                  CMatrixConv < _Int, _Flt, double >::InitAndConv (nlist_temp, pia_temp,
                                                                   pja_temp, pa_temp,
                                                                   matr_conv);
                  ptr_matr = &matr_conv;
               }
               CFct < _Int, double >::Ilu2Matrix (*ptr_matr, *_params, pmatrL_double[i],
                                                  pmatrU_double[i], psclmin_arr[i],
                                                  psclmax_arr[i], nmodif_loc,
                                                  peigmin_arr[i], peigmax_arr[i]);
               _nmodif += nmodif_loc;
               nzlu_tot += pmatrL_double[i].GetNza ();
               nzlu_tot += pmatrU_double[i].GetNza ();
            }
            if (collap_loc > 0) {
               sprintf (strbuff, "BlkStrU_%i.ps", i);
               blks_3[0] = 0;
               blks_3[1] = pnlist_ext_arr[i];
               blks_3[2] = pn2_blocks[i];
               blks_3[3] = pmatr_ext_arr[i].GetNlist ();
               if (prec_float_loc == 1) {
                  CBMatrix < _Int, float >::Str2PsBox (collap_loc, pmatrU_float[i],
                                                       strbuff, 3, blks_3);
               } else {
                  CBMatrix < _Int, double >::Str2PsBox (collap_loc, pmatrU_double[i],
                                                        strbuff, 3, blks_3);
               }
            }
            pmatr_ext_arr[i].Clean ();
         }
      }

      CMPIDataExchange::ExchangeArray (pcommloc, 'I', '+', 1, (void *) (&_nmodif));

      CMPIDataExchange::ExchangeArray (pcommloc, 'D', '+', nblksloc,
                                       (void *) (psclmin_arr));
      CMPIDataExchange::ExchangeArray (pcommloc, 'D', '+', nblksloc,
                                       (void *) (psclmax_arr));
      CMPIDataExchange::ExchangeArray (pcommloc, 'D', '+', nblksloc,
                                       (void *) (peigmin_arr));
      CMPIDataExchange::ExchangeArray (pcommloc, 'D', '+', nblksloc,
                                       (void *) (peigmax_arr));

      _scpiv_min = psclmin_arr[0];
      _scpiv_max = psclmax_arr[0];
      _piv_min = peigmin_arr[0];
      _piv_max = peigmax_arr[0];

      for (i = 1; i < nblksloc; i++) {
         if (psclmin_arr[i] < _scpiv_min)
            _scpiv_min = psclmin_arr[i];
         if (psclmax_arr[i] > _scpiv_max)
            _scpiv_max = psclmax_arr[i];
         if (peigmin_arr[i] < _piv_min)
            _piv_min = peigmin_arr[i];
         if (peigmax_arr[i] > _piv_max)
            _piv_max = peigmax_arr[i];
      }

      CMPIDataExchange::ExchangeArray (pcommloc, 'L', '+', 1, (void *) (&nzlu_tot));

      nzlu_tot -= ntot_ext;

      _density = ((double) (nzlu_tot) / (double) (nza_tot));

// Init solve control structures

      if (prec_float_loc == 1) {

         this->slv_float.InitControl (pcommloc, nblksloc, pblks, pblks_ext, pblk2cpu);
         if (ordtype_loc > 0) {
            this->slv_float.InitSolveLU (plist_ext_arr, pmatrL_float, pmatrU_float,
                                         porder_LU);
         } else {
            this->slv_float.InitSolveLU (plist_ext_arr, pmatrL_float, pmatrU_float, NULL);
         }

      } else {

         this->slv_double.InitControl (pcommloc, nblksloc, pblks, pblks_ext, pblk2cpu);
         if (ordtype_loc > 0) {
            this->slv_double.InitSolveLU (plist_ext_arr, pmatrL_double, pmatrU_double,
                                          porder_LU);
         } else {
            this->slv_double.InitSolveLU (plist_ext_arr, pmatrL_double, pmatrU_double,
                                          NULL);
         }

      }

// Finalize timer

      CMPIDataExchange::Synchronize (pcommloc);

      double time1;

      time1 = CMPIDataExchange::GetWallTimeMPI ();

      _dtime_fct = time1 - time0;

   }

// Perform iterations of the BiCGStab iterative scheme
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CK3D_Solver < _Int,
      _Flt, _FltVect >::BiCGStab (bool _b_use_poly, int _niter_max, double _eps,
                                  int _ichk, int _msglev, ofstream * _fout,
                                  _FltVect * _rhs, _FltVect * _sol, double &_rhs_norm,
                                  double &_res_ini, int &_niter, int &_nmvm,
                                  double &_res_fin, double &_dtime_iter)
   {

// Init output data

      _rhs_norm = 0.0e0;
      _res_ini = 0.0e0;
      _niter = 0;
      _nmvm = 0;
      _res_fin = 0.0e0;
      _dtime_iter = 0.0e0;

// Get control data

      void *pcomm_loc = this->GetComm ();
      int nblks_loc = this->GetNblks ();
      long long *pblks_loc = this->GetBlks ();
      int *pblks2cpu_loc = this->GetBlk2cpu ();

      int myid_loc = CMPIDataExchange::GetMyid (pcomm_loc);

// Init timer

      CMPIDataExchange::Synchronize (pcomm_loc);

      double time0;

      time0 = CMPIDataExchange::GetWallTimeMPI ();

// Get the local size of vector data

      int i;

      int n_local = 0;

      for (i = 0; i < nblks_loc; i++) {
         if (pblks2cpu_loc[i] == myid_loc) {
            n_local += (int) (pblks_loc[i + 1] - pblks_loc[i]);
         }
      }

// Allocate work vector arrays

      vector < _FltVect > rhs (n_local + 1);
      vector < _FltVect > r (n_local + 1);
      vector < _FltVect > p (n_local + 1);
      vector < _FltVect > x (n_local + 1);
      vector < _FltVect > u (n_local + 1);
      vector < _FltVect > z (n_local + 1);
      vector < _FltVect > v (n_local + 1);
      vector < _FltVect > q (n_local + 1);

      _FltVect *pr = &r[0];
      _FltVect *pp = &p[0];
      _FltVect *px = &x[0];
      _FltVect *pu = &u[0];
      _FltVect *pz = &z[0];
      _FltVect *pv = &v[0];
      _FltVect *pq = &q[0];

// Compute initial residual vector and its norm

      CVector < _FltVect >::CopyVector (n_local, _sol, px);
      CVector < _FltVect >::CopyVector (n_local, _rhs, pr);

      this->MvmA (px, pz);

      CVector < _FltVect >::SubtractReplaceVector (n_local, pz, pr);

      _FltVect rhs_norm = 0.0e0;
      _FltVect resi0_norm = 0.0e0;

      rhs_norm = CVector < _FltVect >::ScProd (n_local, _rhs, _rhs);
      resi0_norm = CVector < _FltVect >::ScProd (n_local, pr, pr);

      double sum2_arr[2];

      sum2_arr[0] = (double) rhs_norm;
      sum2_arr[1] = (double) resi0_norm;

      CMPIDataExchange::ExchangeArray (pcomm_loc, 'D', '+', 2, sum2_arr);

      double d_rhs_norm = sum2_arr[0];
      double d_resi0_norm = sum2_arr[1];

      d_rhs_norm = sqrt (d_rhs_norm);
      d_resi0_norm = sqrt (d_resi0_norm);

      _rhs_norm = d_rhs_norm;
      _res_ini = d_resi0_norm;

      if (_res_ini < _eps * _rhs_norm) {
         _res_fin = _res_ini;
         _niter = 0;
         return;
      }

      if (_msglev >= 2)
         std::cout << " Log10 || Rhs || = " << log10 (_rhs_norm) << std::endl;
      if (_msglev >= 1 && _fout != NULL)
         *_fout << " Log10 || Rhs || = " << log10 (_rhs_norm) << std::endl;

      if (_msglev >= 2)
         std::cout << " Initial Log10 || Resi || = " << log10 (d_resi0_norm) << std::endl;
      if (_msglev >= 1 && _fout != NULL)
         *_fout << " Initial Log10 || Resi || = " << log10 (d_resi0_norm) << std::endl;

// Perform iterations starting from residual data

      int niter_perf = 0;
      double resi_norm = d_resi0_norm;
      double d_res_min = resi_norm;

// Choose initial direction vector

      CVector < _FltVect >::CopyVector (n_local, pr, pz);       // z=r(0)

// p(1) = r(0)

      CVector < _FltVect >::CopyVector (n_local, pr, pp);       // p=r(0)

// Main iterative cycle

      _FltVect alpha = 0.0e0, beta, omega = 0.0e0, rho, rhoold; // method parameters
      _FltVect uu, ur, zv;      // inner products

      _FltVect fone = (_FltVect) 1.0e0;

      rho = fone;

      int k, it;

      _FltVect faux;
      double daux;

      double d_resi;

      bool conv = false;

      for (k = 1; k <= _niter_max; k++) {

         it = k - 1;            // the number of MVM is equal to 2*it

// rho(i-1) = z^T * r(i-1)

         rhoold = rho;

         rho = CVector < _FltVect >::ScProd (n_local, pz, pr);

         daux = (double) rho;

         CMPIDataExchange::ExchangeArray (pcomm_loc, 'D', '+', 1, &daux);

         rho = (_FltVect) daux;

         if (k == 1) {
            alpha = omega = fone;
         } else {

// beta(i-1) = (rho(i-1) / rho(i-2)) * (alpha(i-1) / omega(i-1))

            beta = (rho / rhoold) * (alpha / omega);

// p(i) = r(i-1) + beta(i-1) * (p(i-1) - omega(i-1) * v(i-1))

            CVector < _FltVect >::UpdateVectorMinus (n_local, &omega, pv, pp);
            CVector < _FltVect >::UpdateVectorReversed (n_local, &beta, pr, pp);

         }

// q = M_solve * p(i)

         this->PolySlvLU (_b_use_poly, pp, pq);

// v(i) = A * q

         this->MvmA (pq, pv);

// alpha(i) = rho(i-1) / z^T * v(i)

         zv = CVector < _FltVect >::ScProd (n_local, pz, pv);

         daux = (double) zv;

         CMPIDataExchange::ExchangeArray (pcomm_loc, 'D', '+', 1, &daux);

         zv = (_FltVect) daux;

         alpha = rho / zv;

// x(i-1/2) = x(i-1) + alpha(i) * q

         CVector < _FltVect >::UpdateVector (n_local, &alpha, pq, px);

// r(i-1/2) = r(i-1) - alpha(i) * v(i)

         CVector < _FltVect >::UpdateVectorMinus (n_local, &alpha, pv, pr);

// The intermediate check of convergence can be added here

// q = M_solve * r(i-1/2)

         this->PolySlvLU (_b_use_poly, pr, pq);

// u = A * q

         this->MvmA (pq, pu);

// omega(i) = u^T * r(i-1/2) / u^T * u

         ur = CVector < _FltVect >::ScProd (n_local, pu, pr);
         uu = CVector < _FltVect >::ScProd (n_local, pu, pu);

         sum2_arr[0] = (double) ur;
         sum2_arr[1] = (double) uu;

         CMPIDataExchange::ExchangeArray (pcomm_loc, 'D', '+', 2, sum2_arr);

         ur = (_FltVect) sum2_arr[0];
         uu = (_FltVect) sum2_arr[1];

         omega = ur / uu;

// x(i) = x(i-1/2) + omega(i) * q

         CVector < _FltVect >::UpdateVector (n_local, &omega, pq, px);

// r(i) = r(i-1/2) - omega(i) * u

         CVector < _FltVect >::UpdateVectorMinus (n_local, &omega, pu, pr);

// Check the convergence

         niter_perf = (int) (it + 1);

         faux = CVector < _FltVect >::ScProd (n_local, pr, pr);

         daux = (double) faux;

         CMPIDataExchange::ExchangeArray (pcomm_loc, 'D', '+', 1, &daux);

         d_resi = sqrt (daux);

         if ((it + _ichk) % _ichk == 0 && _msglev >= 2)
            std::cout << " It = " << it << " Log10 || Resi || = " << log10 (d_resi) <<
               std::endl;
         if ((it + _ichk) % _ichk == 0 && _msglev >= 1 && _fout != NULL)
            *_fout << " It = " << it << " Log10 || Resi || = " << log10 (d_resi) << std::
               endl;

         if (d_resi < _eps * d_rhs_norm)
            conv = true;

// Save the best attained solution

         if (d_resi < d_res_min) {
            d_res_min = d_resi;
            CVector < _FltVect >::CopyVector (n_local, px, _sol);
         }
// Break from iterations if converged

         if (conv) {
            break;
         }

      }                         // end of iterations

// Compute the final residual

      this->MvmA (_sol, pr);

      CVector < _FltVect >::SubtractReplaceVector (n_local, _rhs, pr);  // r=b-A*x

// Compute the final residual norm

      resi_norm = CVector < _FltVect >::ScProd (n_local, pr, pr);

      daux = (double) resi_norm;

      CMPIDataExchange::ExchangeArray (pcomm_loc, 'D', '+', 1, &daux);

      double d_resi_fin = sqrt (daux);

      if (_msglev >= 2)
         std::cout << " Final Log10 || Resi || = " << log10 (d_resi_fin) << std::endl;
      if (_msglev >= 1 && _fout != NULL)
         *_fout << " Final Log10 || Resi || = " << log10 (d_resi_fin) << std::endl;

// Finalize timer

      CMPIDataExchange::Synchronize (pcomm_loc);

      double time1;

      time1 = CMPIDataExchange::GetWallTimeMPI ();

      _dtime_iter = time1 - time0;

// Return statistics data

      _niter = niter_perf;
      _res_fin = d_resi_fin;
      _nmvm = _niter * 2;
      if (_b_use_poly) {
         int ncoef_loc = this->ncoef_slv;
         _nmvm = _niter * 2 * ncoef_loc;
      }

   }

// Perform iterations of the Gmres iterative scheme
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CK3D_Solver < _Int,
      _Flt, _FltVect >::Gmres (bool _b_use_poly, int _niter_max, int _niter_cycle,
                               int _ncoef, double _eps, int _ichk, int _msglev,
                               ofstream * _fout, _FltVect * _rhs, _FltVect * _sol,
                               double &_rhs_norm, double &_res_ini, int &_niter,
                               int &_nmvm, double &_res_fin, double &_dtime_iter)
   {

// Init output data

      _rhs_norm = 0.0e0;
      _res_ini = 0.0e0;
      _niter = 0;
      _res_fin = 0.0e0;
      _dtime_iter = 0.0e0;

// Get control data

      void *pcomm_loc = this->GetComm ();
      int nblks_loc = this->GetNblks ();
      long long *pblks_loc = this->GetBlks ();
      int *pblks2cpu_loc = this->GetBlk2cpu ();

      int myid_loc = CMPIDataExchange::GetMyid (pcomm_loc);

// Init timer

      CMPIDataExchange::Synchronize (pcomm_loc);

      double time0;

      time0 = CMPIDataExchange::GetWallTimeMPI ();

// Get the local size of vector data

      int i;

      int n_local = 0;

      for (i = 0; i < nblks_loc; i++) {
         if (pblks2cpu_loc[i] == myid_loc) {
            n_local += (int) (pblks_loc[i + 1] - pblks_loc[i]);
         }
      }

// Allocate work vector arrays

      vector < _FltVect > r (n_local + 1);
      vector < _FltVect > x (n_local + 1);
      vector < _FltVect > u (n_local + 1);
      vector < _FltVect > z (n_local + 1);
      vector < _FltVect > v (n_local + 1);

      _FltVect *pr = &r[0];
      _FltVect *px = &x[0];
      _FltVect *pu = &u[0];
      _FltVect *pz = &z[0];
      _FltVect *pv = &v[0];

// Compute initial residual vector and its norm

      CVector < _FltVect >::CopyVector (n_local, _sol, px);
      CVector < _FltVect >::CopyVector (n_local, _rhs, pr);

      this->MvmA (px, pz);

      CVector < _FltVect >::SubtractReplaceVector (n_local, pz, pr);

      CVector < _FltVect >::CopyVector (n_local, pr, pu);

      _FltVect rhs_norm = 0.0e0;
      _FltVect resi0_norm = 0.0e0;

      rhs_norm = CVector < _FltVect >::ScProd (n_local, _rhs, _rhs);
      resi0_norm = CVector < _FltVect >::ScProd (n_local, pr, pr);

      double sum2_arr[2];

      sum2_arr[0] = (double) rhs_norm;
      sum2_arr[1] = (double) resi0_norm;

      CMPIDataExchange::ExchangeArray (pcomm_loc, 'D', '+', 2, sum2_arr);

      double d_rhs_norm = sum2_arr[0];
      double d_resi0_norm = sum2_arr[1];

      d_rhs_norm = sqrt (d_rhs_norm);
      d_resi0_norm = sqrt (d_resi0_norm);

      _rhs_norm = d_rhs_norm;
      _res_ini = d_resi0_norm;

      if (_res_ini < _eps * _rhs_norm) {
         _res_fin = _res_ini;
         _niter = 0;
         return;
      }

      if (myid_loc == 0 && _msglev >= 2)
         std::cout << " Log10 || Rhs || = " << log10 (_rhs_norm) << std::endl;
      if (myid_loc == 0 && _msglev >= 1 && _fout != NULL)
         *_fout << " Log10 || Rhs || = " << log10 (_rhs_norm) << std::endl;

      if (myid_loc == 0 && _msglev >= 2)
         std::cout << " Initial Log10 || Resi || = " << log10 (d_resi0_norm) << std::endl;
      if (myid_loc == 0 && _msglev >= 1 && _fout != NULL)
         *_fout << " Initial Log10 || Resi || = " << log10 (d_resi0_norm) << std::endl;

// Perform iterations starting from residual data

// Create qrd data

      CQrdMPI < _FltVect > qrdMPI_P;

      qrdMPI_P.Init (pcomm_loc, n_local);

      CQrdBase < _FltVect > qrdGIVENS;

// Get parameters

      int niter = _niter_max;
      double eps = _eps;
      int nitcycle = _niter_cycle;
      int ichk = _ichk;

      int nitmax = niter;

      int nitcycle2 = nitcycle + 2;

      int nitmax_alloc = nitmax;
      if (nitcycle > nitmax_alloc)
         nitmax_alloc = nitcycle;

// double eps_achieved = 1; //done_static;

// Estimate the maximal number of columns in R

      int ncolsRmax = nitcycle + 2;

// Determine the sizes arrays

      int ncolsmax = ncolsRmax;

// Allocate work arrays

      vector < _FltVect > alpha (ncolsmax + 1);
      vector < _FltVect > hmatr (ncolsmax * nitcycle2 + 1),
         rmatr (ncolsmax * nitcycle2 + 1);
      vector < double >diagR (ncolsmax + 1);

      _FltVect *palpha, *phmatr, *prmatr;
      double *pdiagR;

      palpha = &alpha[0];
      phmatr = &hmatr[0];
      prmatr = &rmatr[0];
      pdiagR = &diagR[0];

      CVector < _FltVect >::SetByZeroes (ncolsmax * nitcycle2, phmatr);
      CVector < _FltVect >::SetByZeroes (ncolsmax * nitcycle2, prmatr);

// Perform Gmres iterations

      int iterloc, ncolsP;
      double d_resi_norm;

      d_resi_norm = d_resi0_norm;

      int itgl = 0;
      bool conv = false;
      int iter = 0;

      while (iter < nitmax && !conv) {

         if (myid_loc == 0 && _msglev >= 2)
            std::cout << " ItGl = " << itgl << std::endl;
         if (myid_loc == 0 && _msglev >= 1 && _fout != NULL)
            *_fout << " ItGl = " << itgl << std::endl;

// Check convergence for current guess

         {

            _FltVect resi0_2;

            resi0_2 = CVector < _FltVect >::ScProd (n_local, pu, pu);

            double d_resi0_2 = (double) resi0_2;

            CMPIDataExchange::ExchangeArray (pcomm_loc, 'D', '+', 1, &d_resi0_2);

            d_resi_norm = sqrt (d_resi0_2);

//         if (myid_loc == 0 && _msglev >= 2) std::cout << "   It = " << iter << " Log10 || Resi || = " << log10(d_resi_norm) << std::endl;
//         if (myid_loc == 0 && _msglev >= 1 && _fout != NULL) *_fout   << "   It = " << iter << " Log10 || Resi || = " << log10(d_resi_norm) << std::endl;

            if (d_resi_norm < eps * d_rhs_norm)
               conv = true;

         }

// Fast return if necessary

         if (d_resi_norm == 0.0e0)
            conv = true;

         if (conv)
            break;

// Add residual data into the W qrd

         ncolsP = 0;

         qrdMPI_P.UpdateQrdMPI (1, n_local, pu, n_local);
         ncolsP++;

// Get local rhs coefs

         CVector < _FltVect >::SetByZeroes (ncolsmax, palpha);

         d_resi_norm = 0.0e0;

         if (myid_loc == 0) {
            qrdMPI_P.GetRQrdMPI (ncolsP - 1, ncolsP - 1, 0, ncolsP - 1, palpha, ncolsmax);
            d_resi_norm = palpha[0] * palpha[0];
         }

         CMPIDataExchange::ExchangeArray (pcomm_loc, 'D', '+', 1, &d_resi_norm);

         d_resi_norm = sqrt (d_resi_norm);

// Perform local iterations

         itgl++;

         iterloc = 0;

         while (iterloc < nitcycle && iter < nitmax) {

// Check or estimate the convergence

            if (iterloc % ichk == 0 && iterloc > 0) {
               if (myid_loc == 0 && _msglev >= 2)
                  std::cout << "   It = " << iter << " Log10 || Resi || = " <<
                     log10 (d_resi_norm) << std::endl;
               if (myid_loc == 0 && _msglev >= 1 && _fout != NULL)
                  *_fout << "   It = " << iter << " Log10 || Resi || = " <<
                     log10 (d_resi_norm) << std::endl;
            }

            if (d_resi_norm / d_rhs_norm < eps)
               conv = true;

            if (conv)
               break;

// New iteration

            iter++;
            iterloc++;

// Compute new direction vector

            if (myid_loc == 0) {
               CVector < _FltVect >::SetByZeroes (ncolsP, pz);
               CVector < _FltVect >::SetByOnes (1, pz + ncolsP - 1);
            }

            qrdMPI_P.MvmQMPI (1, pz, ncolsP, pv, n_local);

// Multiply by the preconditioned matrix

            this->PolySlvLU (_b_use_poly, pv, pz);
            this->MvmA (pz, pu);

// Update QR decomposition

            qrdMPI_P.UpdateQrdMPI (1, n_local, pu, n_local);
            ncolsP++;

// Get current R part

            if (myid_loc == 0) {

               CVector < _FltVect >::SetByZeroes (ncolsmax,
                                                  phmatr + (iterloc - 1) * ncolsmax);
               qrdMPI_P.GetRQrdMPI (ncolsP - 1, ncolsP - 1, 0, ncolsP - 1,
                                    phmatr + (iterloc - 1) * ncolsmax, ncolsmax);

// Compute new Givens rotation and apply it to the current column

               qrdGIVENS.UpdateQrdBlk (1, ncolsP, phmatr + (iterloc - 1) * ncolsmax,
                                       ncolsmax);

               qrdGIVENS.GetRQrd (ncolsP - 2, ncolsP - 2, 0, ncolsP - 2,
                                  prmatr + (iterloc - 1) * ncolsmax, ncolsmax);

// Compute new reduced residual vector

               qrdGIVENS.MvmQHPart (1, iterloc - 1, iterloc - 1, palpha, ncolsmax);

            }
// Estimate residual norm

            if (myid_loc == 0) {
               _FltVect resi;
               resi =
                  CVector < _FltVect >::ScProd (1, palpha + iterloc, palpha + iterloc);
               d_resi_norm = (double) resi;
               d_resi_norm = sqrt (d_resi_norm);
            } else {
               d_resi_norm = 0.0e0;
            }

            CMPIDataExchange::ExchangeArray (pcomm_loc, 'D', '+', 1, &d_resi_norm);

         }

// Compute new local guess to the solution and coefs if necessary

         int ncoef = _ncoef;
         vector < double >coefs;

         if (myid_loc == 0) {

// Compute diagonal values of R

            for (i = 0; i < iterloc; i++) {
               pdiagR[i] = (double) prmatr[i * ncolsmax + i];
               if (pdiagR[i] < 0.0e0)
                  pdiagR[i] = -pdiagR[i];
            }

            double diagR_min = pdiagR[0];
            double diagR_max = pdiagR[0];

            for (i = 0; i < iterloc; i++) {
               if (pdiagR[i] > diagR_max)
                  diagR_max = pdiagR[i];
               if (pdiagR[i] < diagR_min)
                  diagR_min = pdiagR[i];
            }

            if (_msglev >= 2)
               cout << "   DiagR_min = " << diagR_min << " DiagR_max = " << diagR_max <<
                  endl;
            if (_msglev >= 1 && _fout != NULL)
               *_fout << "   DiagR_min = " << diagR_min << " DiagR_max = " << diagR_max <<
                  endl;

            if (_msglev >= 4)
               PrintArrayLow (cout, "DiagR", iterloc, pdiagR);
            if (_msglev >= 3 && _fout != NULL)
               PrintArrayLow (*_fout, "DiagR", iterloc, pdiagR);

// Compute new local guess

            CVector < _FltVect >::SolveR ('N', iterloc, prmatr, ncolsmax, palpha);

// Compute least squares polinomial if necessary

            if (ncoef > 1 && itgl == 1) {
               if (ncoef > iterloc)
                  ncoef = iterloc / 2;
               if (ncoef < 1) {
                  ncoef = -1;
               } else {
                  CVector < _FltVect >::Polynomial (iterloc, ncoef, phmatr, ncolsmax,
                                                    coefs);
               }
            }

         }
// Store coefs in preconditioner data if necessary

         if (itgl == 1) {
            if (myid_loc != 0)
               ncoef = 0;
            CMPIDataExchange::ExchangeArray (pcomm_loc, 'I', '+', 1, &ncoef);
            if (ncoef > 0) {
               if (myid_loc > 0) {
                  coefs.resize (ncoef + 1);
               }
               double *pcoefs = &coefs[0];
               if (myid_loc > 0) {
                  CVector < double >::SetByZeroes (ncoef, pcoefs);
               }
               CMPIDataExchange::ExchangeArray (pcomm_loc, 'D', '+', ncoef, pcoefs);
               this->SetNcoef (ncoef);
               vector < double >*ptr_coef_slv = this->GetCoef ();
               ptr_coef_slv->resize (ncoef + 1);
               double *pcoef_slv = &((*ptr_coef_slv)[0]);
               for (i = 0; i < ncoef; i++)
                  pcoef_slv[i] = pcoefs[i];
            }
         }
// Compute new guess to the solution

         qrdMPI_P.MvmQMPI (1, palpha, ncolsP, pv, n_local);

         this->PolySlvLU (_b_use_poly, pv, pu);

         CVector < _FltVect >::AddReplaceVector (n_local, pu, px);

         this->MvmA (px, pv);

         CVector < _FltVect >::CopyVector (n_local, _rhs, pr);

         CVector < _FltVect >::SubtractReplaceVector (n_local, pv, pr);

         CVector < _FltVect >::CopyVector (n_local, pr, pu);

         _FltVect resi;

         resi = CVector < _FltVect >::ScProd (n_local, pu, pu);

         d_resi_norm = (double) resi;

         CMPIDataExchange::ExchangeArray (pcomm_loc, 'D', '+', 1, &d_resi_norm);

         d_resi_norm = sqrt (d_resi_norm);

         if (myid_loc == 0 && _msglev >= 2)
            std::cout << " Computed Log10 || Resi || = " << log10 (d_resi_norm)
               << std::endl;
         if (myid_loc == 0 && _msglev >= 1 && _fout != NULL)
            *_fout << " Computed Log10 || Resi || = " << log10 (d_resi_norm)
               << std::endl;

// Free QRD structures

         qrdGIVENS.SetNqblk (0);

         qrdMPI_P.FreeQrdMPI ();

      }

// Store solution

      CVector < _FltVect >::CopyVector (n_local, px, _sol);

// Finalize timer

      CMPIDataExchange::Synchronize (pcomm_loc);

      double time1;

      time1 = CMPIDataExchange::GetWallTimeMPI ();

      _dtime_iter = time1 - time0;

// Return statistics data

      _niter = iter;
      _res_fin = d_resi_norm;
      _nmvm = _niter;
      if (_b_use_poly) {
         int ncoef_loc = this->ncoef_slv;
         _nmvm = _niter * ncoef_loc;
      }

   }

// Perform iterations of the iterative scheme
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CK3D_Solver < _Int,
      _Flt, _FltVect >::SolveIter (int _ittype, int _niter_max, int _niter_cycle,
                                   int _ncoef, int _niter_cycle2, double _eps, int _ichk,
                                   int _msglev, ofstream * _fout, _FltVect * _rhs,
                                   _FltVect * _sol, double &_rhs_norm, double &_res_ini,
                                   int &_niter, int &_nmvm, double &_res_fin,
                                   double &_dtime_iter)
   {

      if (_ittype == 0 || _niter_cycle == 1) {

         this->BiCGStab (false, _niter_max, _eps, _ichk, _msglev, _fout, _rhs, _sol,
                         _rhs_norm, _res_ini, _niter, _nmvm, _res_fin, _dtime_iter);

      } else if (_ittype == 1) {

         this->Gmres (false, _niter_max, _niter_cycle, -1, _eps, _ichk, _msglev, _fout,
                      _rhs, _sol, _rhs_norm, _res_ini, _niter, _nmvm, _res_fin,
                      _dtime_iter);

      } else if (_ittype == 2) {

         this->Gmres (false, _niter_cycle, _niter_cycle, _ncoef, _eps, _ichk, _msglev,
                      _fout, _rhs, _sol, _rhs_norm, _res_ini, _niter, _nmvm, _res_fin,
                      _dtime_iter);

         if (_res_fin > _eps * _rhs_norm) {

            int niter_max_temp = _niter_max - _niter;
            double res_ini_temp, dtime_iter_temp;
            int niter_temp, nmvm_temp;

            this->BiCGStab (true, niter_max_temp, _eps, _ichk, _msglev, _fout, _rhs, _sol,
                            _rhs_norm, res_ini_temp, niter_temp, nmvm_temp, _res_fin,
                            dtime_iter_temp);

            _niter += niter_temp;
            _nmvm += nmvm_temp;
            _dtime_iter += dtime_iter_temp;

         }

      } else if (_ittype == 3) {

         this->Gmres (false, _niter_cycle, _niter_cycle, _ncoef, _eps, _ichk, _msglev,
                      _fout, _rhs, _sol, _rhs_norm, _res_ini, _niter, _nmvm, _res_fin,
                      _dtime_iter);

         if (_res_fin > _eps * _rhs_norm) {

            int niter_max_temp = _niter_max - _niter;
            double res_ini_temp, dtime_iter_temp;
            int niter_temp, nmvm_temp;

            this->Gmres (true, niter_max_temp, _niter_cycle2, -1, _eps, _ichk, _msglev,
                         _fout, _rhs, _sol, _rhs_norm, res_ini_temp, niter_temp,
                         nmvm_temp, _res_fin, dtime_iter_temp);

            _niter += niter_temp;
            _nmvm += nmvm_temp;
            _dtime_iter += dtime_iter_temp;

         }

      }

   }

// Perform polynomial preconditioning
//========================================================================================
   template < typename _Int, typename _Flt, typename _FltVect > void CK3D_Solver < _Int,
      _Flt, _FltVect >::PolySlvLU (bool _b_use_poly, const _FltVect * _x, _FltVect * _px)
   {

// Fast return

      if (!_b_use_poly) {
         this->SlvLU (_x, _px);
         return;
      }
// Check and allocate work memory if necessary

      int ni_local = 0;

      if (this->params.prec_float == 1) {
         ni_local = slv_float.GetNiCpu ();
      } else {
         ni_local = slv_double.GetNiCpu ();
      }

      int isize = (int) (this->xwork.size ());
      int isize_work = 3 * ni_local + 1;

      if (isize != isize_work) {
         this->xwork.resize (isize_work);
      }

      double *pxwork = &this->xwork[0];

      _FltVect *pxwork_f = (_FltVect *) pxwork;

      _FltVect *pz1 = pxwork_f;
      _FltVect *pz2 = pz1 + ni_local;
      _FltVect *pz3 = pz2 + ni_local;

// Perform polynomially preconditioned computations

      int ncoef_loc = this->ncoef_slv;
      double *pcoef_loc = &(this->coef_slv[0]);

      CVector < _FltVect >::SetByZeroes (ni_local, pz3);
      CVector < _FltVect >::CopyVector (ni_local, _x, pz1);

      int i;
      _FltVect aux;

      for (i = 0; i < ncoef_loc; i++) {

         aux = (_FltVect) pcoef_loc[i];

         CVector < _FltVect >::UpdateVector (ni_local, &aux, pz1, pz3);

         if (i < ncoef_loc - 1) {

            this->SlvLU (pz1, _px);
            this->MvmA (_px, pz2);

            CVector < _FltVect >::SubtractReplaceVector (ni_local, pz2, pz1);

         }

      }

      this->SlvLU (pz3, _px);

   }

   template class CMvmSlv_impl < long long, double, double >;
   template class CMvmSlv_impl < int, double, double >;
   template class CMvmSlv_impl < long long, float, double >;
   template class CMvmSlv_impl < int, float, double >;
   template class CMvmSlv_impl < long long, float, float >;
   template class CMvmSlv_impl < int, float, float >;

   template class CMvmSlv < long long, double, double >;
   template class CMvmSlv < int, double, double >;
   template class CMvmSlv < long long, float, double >;
   template class CMvmSlv < int, float, double >;
   template class CMvmSlv < long long, float, float >;
   template class CMvmSlv < int, float, float >;

   template class CFct < long long, double >;
   template class CFct < int, double >;
   template class CFct < long long, float >;
   template class CFct < int, float >;

   template class CBMatrix < long long, double >;
   template class CBMatrix < int, double >;
   template class CBMatrix < long long, float >;
   template class CBMatrix < int, float >;

   template class CMatrixConv < long long, double, double >;
   template class CMatrixConv < int, double, double >;
   template class CMatrixConv < long long, double, float >;
   template class CMatrixConv < int, double, float >;
   template class CMatrixConv < long long, float, double >;
   template class CMatrixConv < int, float, double >;
   template class CMatrixConv < long long, float, float >;
   template class CMatrixConv < int, float, float >;

   template class CQrdBase < float >;
   template class CQrdBase < double >;
   template class CQrdSet < float >;
   template class CQrdSet < double >;
   template class CQrdMPI < float >;
   template class CQrdMPI < double >;

   template class CMvmPar < long long, double, double >;
   template class CMvmPar < int, double, double >;
   template class CMvmPar < long long, float, double >;
   template class CMvmPar < int, float, double >;

   template class CSlvPar < long long, double, double >;
   template class CSlvPar < int, double, double >;
   template class CSlvPar < long long, float, double >;
   template class CSlvPar < int, float, double >;

   template class CK3D_Solver < long long, double, double >;
   template class CK3D_Solver < int, double, double >;
   template class CK3D_Solver < long long, float, double >;
   template class CK3D_Solver < int, float, double >;

}                               // namespace k3d

#endif
